
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Firebase compat only -->
  <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-firestore-compat.js"></script>
  <script>
    // === Robust init: create DEFAULT app for legacy calls + named app guard ===
    window.firebaseConfig = window.firebaseConfig || {
      apiKey: "AIzaSyD-lQOz47WSM0BOT0oT29vDNbNjaWqH6r8",
      authDomain: "marlow-media-calendar.firebaseapp.com",
      projectId: "marlow-media-calendar",
      storageBucket: "marlow-media-calendar.appspot.com",
      messagingSenderId: "664519075124",
      appId: "1:664519075124:web:6380ee0e1ddb07b3c6f161"
    };
    (function(){
      var cfg = window.firebaseConfig;

      // Ensure DEFAULT app exists for any firebase.firestore() legacy calls
      try { firebase.app(); } catch(_){ firebase.initializeApp(cfg); }

      // Also create a named app so we can detect our own init
      try { firebase.app('forceProd'); } catch(_){ firebase.initializeApp(cfg, 'forceProd'); }

      // Choose the DEFAULT app's Firestore for compatibility
      var db = firebase.firestore();
      try { db.settings({ experimentalAutoDetectLongPolling: true }); } catch(_){}

      // Expose helpers and polyfill firestore getter if needed
      window.__db = db;
      window.getDb = function(){ return window.__db; };

      // If someone calls firebase.firestore() before our init, point it to our db
      try {
        var origFs = firebase.firestore;
        firebase.firestore = function(){ return window.__db || origFs.call(firebase); };
      } catch(_){}

      console.log('[init+] DEFAULT app ready, db wired');
    })();
  </script>

  <script>
    window.firebaseConfig = window.firebaseConfig || {
      apiKey: "AIzaSyD-lQOz47WSM0BOT0oT29vDNbNjaWqH6r8",
      authDomain: "marlow-media-calendar.firebaseapp.com",
      projectId: "marlow-media-calendar",
      storageBucket: "marlow-media-calendar.appspot.com",
      messagingSenderId: "664519075124",
      appId: "1:664519075124:web:6380ee0e1ddb07b3c6f161"
    };
    (function(){
      var base = window.firebaseConfig;
      var app;
      try { app = firebase.app('forceProd'); } catch(_){ app = firebase.initializeApp(base, 'forceProd'); }
      var db = app.firestore();
      try { db.settings({ experimentalAutoDetectLongPolling: true }); } catch(_){}
      window.getDb = function(){ return db; };
      window.__db  = db;
      console.log('[patch] forceProd app online');
    })();
  </script>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Marlow Media – Dashboard</title>
<style>
:root{
  --bg:#0f1115;
  --panel:#171923;
  --muted:#8b93a7;
  --text:#e6e9f2;
  --brand:#4f7cff;
  --ok:#18c964;
  --warn:#ffd166;
  --danger:#ff5b5b;
  --chip:#222737;
  --border:#293047;
  --card:#11131a;
  --shadow:0 12px 30px rgba(0,0,0,.35);
  --radius:16px;
  --radius-sm:12px;
  --radius-xs:8px;
  --gap:14px;
  --cellh:120px;

  /* Limit the dashboard width to prevent horizontal overflow. This cap
     ensures content fits on most screens and eliminates the need for
     sideways scrolling. */
  --max-width: 1200px;
}

/* Light theme overrides. When the body has the `light` class, these
   variables are swapped in to produce a bright appearance. Only the
   colors are changed; spacing and sizing remain the same. */
body.light{
  --bg:#fafbff;
  --panel:#ffffff;
  --card:#f7f8fc;
  --chip:#f1f3fa;
  --border:#d5d9e8;
  --muted:#5f6c91;
  --text:#262e46;
  --brand:#4f7cff;
  --ok:#0f7c47;
  --warn:#b58b00;
  --danger:#b83232;
}

/* Ensure form controls use the primary text color for entered text.
   Placeholders remain muted for contrast. */
input, textarea, select {
  color: var(--text) !important;
}
input::placeholder, textarea::placeholder {
  color: var(--muted);
}
}
*{box-sizing:border-box}
html,body{height:100%}
html,body{
  overflow-x: hidden;
}

/* Restrict the main screen container to the maximum width and center it */
/* Expand the main screen container to fill the viewport width and
   remove auto‑centering. This eliminates side padding on the overview
   calendars and weekly lists. */
#screen{
  max-width: none;
  width:100%;
  margin:0;
}
body{
  margin:0;font:500 15px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica Neue,Arial;
  color:var(--text);background:var(--bg);
  transition:background 0.3s,color 0.3s;
}
button,input,select,textarea{font:inherit;color:inherit}

/* Darken form input text. The default rule inherits the muted color from
   parent containers, causing typed text to appear dim. Force inputs
   (including selects) to use the primary text colour and lighten
   placeholders to use the muted colour. */
input, select, textarea{color:var(--text);}
input::placeholder, textarea::placeholder{color:var(--muted);opacity:1;}

/* Ensure form controls always display high‑contrast text. Some inputs were
   inheriting muted colours or browser defaults, resulting in very light
   grey text on dark backgrounds. Use !important to override any
   conflicting rules and make the entered text fully readable. */
input, select, textarea {
  color: var(--text) !important;
}
input::placeholder, textarea::placeholder {
  color: var(--muted) !important;
  opacity: 1;
}
a{color:var(--brand);text-decoration:none}
/* Expand the dashboard to use the available viewport width. Previously the
   application was constrained to 1180px which made the UI feel cramped.
   Allow it to grow to the full width while keeping a comfortable margin. */
#app{
  width:100%;
  max-width:none;
  margin:0;
  padding:0;
}
.topbar{display:flex;gap:12px;align-items:center;justify-content:space-between}
.hstack{display:flex;gap:10px;align-items:center}
.topbar .hstack:last-child{flex-wrap:wrap;gap:10px}
.brand{
  font-weight:800;
  letter-spacing:.4px;
  /* Increase the brand size for better prominence. Clients asked for a big
     text instead of a logo. */
  font-size:28px;
}
.badge{padding:5px 10px;border-radius:999px;background:var(--chip);color:#c9d1ff;border:1px solid var(--border);}
select, input[type="text"], input[type="number"], input[type="date"], input[type="time"], textarea{
  background:#0c0e13;border:1px solid var(--border);border-radius:10px;padding:10px 12px;outline:none;min-width:0;
}

/* Override form control colours in modals and cards for maximum contrast.
   Without these rules, some inputs inherited a muted grey colour from
   surrounding containers, making typed text hard to see on dark
   backgrounds. */
.modal input,
.modal select,
.modal textarea,
.card.deliverable input,
.card.deliverable textarea,
.card.deliverable select {
  color: var(--text) !important;
  background: var(--card) !important;
}
.modal option,
.card.deliverable option {
  color: var(--text);
  background: var(--panel);
}
textarea{min-height:110px;resize:vertical}
/* Use dark backgrounds on all form controls for better contrast with
   the light text. Without this rule some inputs remained light with
   dark text, resulting in poor readability. */
/* Apply dark backgrounds and high contrast text to almost all inputs,
   selects and textareas throughout the app. Exclude checkboxes,
   radios and file inputs from this rule. Without this, some fields
   inherit a light background and muted text, resulting in poor
   readability (e.g. New lead form and employee add form). */
input:not([type="checkbox"]):not([type="radio"]):not([type="file"]),
select,
textarea{
  background: var(--panel);
  color: var(--text);
  border: 1px solid var(--border);
  /* Ensure inputs fit nicely within their containers */
  border-radius: 6px;
  padding: 6px;
}
/* Reduce the minimum height for textareas inside deliverable cards so
   that the front of each card remains compact. This helps avoid
   extremely tall cards, particularly in editing and filming modals. */
.card.deliverable textarea{
  min-height:72px;
}
.btn{background:var(--brand);border:0;color:#fff;border-radius:12px;padding:10px 14px;cursor:pointer;box-shadow:var(--shadow)}
.btn.secondary{background:#23283a;color:#cbd5ff;border:1px solid var(--border);box-shadow:none}
.btn.ghost{background:transparent;border:1px solid var(--border);color:#cbd5ff;box-shadow:none}
.btn.small{padding:6px 10px;border-radius:10px}
.btn.danger{background:var(--danger)}

/* Emphasize small action buttons in sales table. Increase contrast of
   icons and text so that follow‑up, won and delete actions are easier
   to see on dark backgrounds. */
.btn.small.ok, .btn.small.danger{
  font-weight:600;
  color:#fff;
  padding:4px 8px;
}
.tabs{display:flex;gap:8px;margin:16px 0 8px}
.tab{padding:10px 14px;border-radius:12px;background:#141827;border:1px solid var(--border);cursor:pointer}
.tab.active{background:#1b2033;color:#fff;border-color:#3b4770}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
/* Make three‐column grids responsive. Auto–fit columns will wrap on narrow
   screens and expand evenly on wider screens. */
.grid3{display:grid;grid-template-columns:repeat(auto-fit, minmax(250px,1fr));gap:16px}
/* Styling for the durations fields in settings. Each duration input stacks its
   label above the input for clarity and consistency. */
.durations-grid .dur-field{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.durations-grid .dur-label{
  font-size:14px;
  font-weight:600;
  color:var(--muted);
}
.card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:16px;box-shadow:var(--shadow)}
.card h3{margin:0 0 12px 0;font-size:16px;opacity:.9}
.kv{display:flex;gap:10px;align-items:center}
.kv .k{color:var(--muted);width:140px}
.row{display:flex;gap:12px;align-items:center}
.row.wrap{flex-wrap:wrap}
.chips{display:flex;gap:8px;flex-wrap:wrap}
.chip{background:var(--chip);border:1px solid var(--border);padding:6px 10px;border-radius:999px;cursor:pointer;white-space:nowrap}
.chip.active{background:#233057;color:#d6e0ff;border-color:#425aa6}
.calendar{margin-top:10px;background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:10px}
.cal-header{display:flex;align-items:center;justify-content:space-between;padding:6px 8px 12px 8px}
.cal-header .title{font-weight:700}
.cal-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:10px}
.cal-cell{background:#11131a;border:1px solid #202436;border-radius:12px;height:var(--cellh);padding:8px;display:flex;flex-direction:column;gap:6px;position:relative;overflow-y:auto;overflow-x:hidden}
.cal-cell .d{position:absolute;top:6px;left:8px;color:#9aa3b6;font-size:12px}
.cal-cell.today{outline:2px solid var(--brand)}
.task{background:#0c0f19;border:1px solid #2a3350;border-radius:10px;padding:8px;box-shadow:var(--shadow);display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.task .dot{width:8px;height:8px;border-radius:999px;background:var(--brand);opacity:.9}
.task .name{flex:1;font-weight:700;white-space:normal}
.task .meta{font-size:12px;color:#b9c3da}
.task .assignee{font-size:12px;background:#1a1f33;border:1px solid #2e3a64;padding:2px 8px;border-radius:999px}
.task .actions{display:flex;gap:6px}
.iconbtn{width:28px;height:28px;border-radius:8px;border:1px solid var(--border);background:#1a1d2a;color:#d1d6f6;display:grid;place-items:center;cursor:pointer}
.iconbtn.ok{border-color:#2b6648;color:#baf3d0}
.iconbtn.warn{border-color:#6a5b2d;color:#ffe8b0}
.iconbtn.danger{border-color:#6b2b36;color:#ffb3b3}
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:20px}
.modal{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:14px;
  padding:18px;
  /* Allow the modal to grow wider on larger viewports so long forms
     (such as the Add task/event dialog) have enough space. The 630px
     maximum felt cramped when multiple fields were displayed inline. */
  /* Reduce the maximum modal width for a more compact appearance. A
     narrower modal makes the add/edit dialogs feel less like a
     full-screen overlay and more like a floating card. */
  max-width:600px;
  width:100%;
  box-shadow:var(--shadow)
}
.modal h3{margin:0 0 12px 0}
hr.sep{border:0;border-top:1px solid var(--border);margin:12px 0}
.small{font-size:12px;color:var(--muted)}
.list{display:flex;flex-direction:column;gap:10px}
.table{width:100%;border-collapse:collapse}
.table th,.table td{border-bottom:1px solid #21263a;padding:10px;text-align:left}
.table td,.table th{color:var(--text);}

/* Prevent action buttons in the leads table from wrapping to new lines. Without
   this rule the +7d/Won/Delete buttons stack vertically when the table
   container shrinks, causing layout issues. */
.table td:last-child{
  white-space:nowrap;
}
.table td:last-child .btn{
  margin-right:4px;
}
.right{margin-left:auto}
.warn{color:#ffd166}
.ok{color:#29d685}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
.hidden{display:none !important}
.client-dot{display:inline-block;width:10px;height:10px;border-radius:999px;margin-right:6px;vertical-align:middle}
  /* Add button inside calendar cells. It sits in the top-right corner and
     provides a quick way to create a new task or piece of content on
     that day. */
.cal-cell .add-btn{
  position:absolute;
  top:6px;
  right:8px;
  font-size:12px;
  color:var(--brand);
  cursor:pointer;
  text-decoration:underline;
}

/* Highlight alternating 14‑day intervals on client calendars. The first
   two weeks after onboarding are tinted, then the next two weeks are
   clear, and so on. A subtle tint of the brand colour helps users
   distinguish content and filming phases without overwhelming the
   schedule. */
.cal-cell.highlight{
  background: rgba(79, 124, 255, 0.08);
}

/* Days of week header for calendars */
.cal-days{
  display:grid;
  grid-template-columns:repeat(7,1fr);
  padding:0 4px;
  margin-bottom:4px;
  font-size:12px;
  color:var(--muted);
  text-align:center;
}

/* Color selector swatches for clients. A selected swatch gets a
   border indicating the active choice. */
.color-swatch{border:2px solid transparent;transition:border-color .2s;}
.color-swatch.selected{
  border-color:var(--brand);
  box-shadow:0 0 0 3px var(--brand);
}
.section-title{font-weight:800;margin:16px 0 8px 0}
/* revenue bar chart */
  /*
   * The revenue bar chart canvas was previously set to a very small height and lacked
   * any numeric context for the underlying values. Make the canvas taller so the
   * bars have more visual breathing room and are easier to differentiate. Labels
   * are drawn dynamically by JavaScript (see drawRevenue()) and will sit just
   * above each bar, so reserve extra vertical space here. The rest of the styling
   * is unchanged.
   */
  .canvas{
    width:100%;
    height:200px;
    background:#0d111a;
    border:1px solid var(--border);
    border-radius:12px;
    position:relative;
    overflow:hidden
  }

  /* Deliverable card styling. Each deliverable uses a 3D flip
     container so front/back sides animate smoothly when toggled. The
     perspective on the wrapper creates depth. */
  .card.deliverable{
    perspective: 1200px;
    overflow: visible;
    /* Increase the minimum height so that long captions and media previews on
       the back of the card have ample vertical space. When cards are
       flipped, the larger height prevents text overlapping the input
       fields. */
    min-height: 600px;
    padding: 0;
    border-radius: var(--radius-sm);
    margin-bottom: 16px;
  }
  .card.deliverable .inner{
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.6s ease;
    transform-style: preserve-3d;
  }
  .card.deliverable.flipped .inner{
    transform: rotateY(180deg);
  }
  .card.deliverable .front,
  .card.deliverable .front,
  .card.deliverable .back{
    position:absolute;
    top:0;
    left:0;
    width:100%;
    /* Allow the side to grow with its content rather than forcing a
       fixed height. Use inherit so that the card's min-height is
       respected but taller content can expand beyond it. */
    min-height:inherit;
    height:auto;
    backface-visibility:hidden;
    display:flex;
    flex-direction:column;
    gap:6px;
    background:var(--card);
    border-radius:var(--radius-sm);
    /* Enable scrolling on the inner sides so long content doesn’t overflow
       the parent card. When a user flips a card with a very long
       caption or preview, they can scroll within the card to read
       everything without overlapping the form inputs. */
    overflow-y:auto;
    padding:12px;
    box-sizing:border-box;
}
  .card.deliverable .back{
    transform: rotateY(180deg);
  }
  .card.deliverable label{
    display:flex;
    flex-direction:column;
    font-size:12px;
    gap:2px;
    /* Add bottom margin so labels don't butt up against each other */
    margin-bottom:6px;
  }
  .card.deliverable .small{
    font-size:12px;
    color:var(--muted);
    /* Separate the header from the rest of the card */
    margin-bottom:6px;
    display:block;
  }
  .trash-btn{
    position:absolute;
    top:8px;
    right:8px;
    /* Increase z-index so the trash button stays above other elements */
    z-index:100;
    font-size:14px;
    cursor:pointer;
    background:transparent;
    border:none;
    color:var(--danger);
  }

  /* Provide spacing on the inner sides of deliverable cards. Inputs fill
     the available width for a clean form layout. */
  .card.deliverable .front,
  .card.deliverable .back{
    padding:12px;
  }
  .card.deliverable textarea,
  .card.deliverable input[type="text"],
  .card.deliverable input[type="url"],
  .card.deliverable input[type="file"],
  .card.deliverable input[type="number"]{
    width:100%;
    background:var(--card);
    border:1px solid var(--border);
    border-radius:8px;
    padding:6px;
    color:var(--text);
  }

  /* Global placeholder color: lighten text in empty fields to be
     visible against dark inputs. Without this rule the default
     placeholder can appear extremely faint. */
  ::placeholder{
    color: var(--muted);
  }

  /* Instagram-style post components used on the back of deliverable cards */
  .post{
    background:var(--panel);
    border-radius:var(--radius-sm);
    overflow:hidden;
    box-shadow:var(--shadow);
  }
  .post-header{
    display:flex;
    align-items:center;
    padding:6px 8px;
  }
  .post-header .avatar{
    width:32px;
    height:32px;
    border-radius:16px;
    background-size:cover;
    background-position:center;
    margin-right:8px;
  }
  .post-header .meta .name{
    font-weight:bold;
    font-size:12px;
    color:var(--text);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .post-header .meta .handle{
    font-size:11px;
    color:var(--muted);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .post-media{
    position:relative;
    width:100%;
    padding-bottom:56%;
    background:var(--chip);
  }
  .post-media video{
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    object-fit:cover;
    border:none;
  }
  .post-caption{
    padding:8px;
    font-size:13px;
    color:var(--text);
  }
  .placeholder{
    width:100%;
    height:150px;
    background:var(--chip);
    display:flex;
    align-items:center;
    justify-content:center;
    color:var(--muted);
    font-size:12px;
  }

  /* Ensure wide containers never exceed the viewport. Limiting the max
     width of key components prevents horizontal overflow when content
     grows on smaller screens. */
  #app, .calendar, .cal-grid, .card, .durations-grid {
    max-width: 100%;
  }

  /* Light theme overrides for form controls: inputs, selects and
     textareas in light mode should use a white background and dark
     text for legibility. */
  body.light input,
  body.light select,
  body.light textarea{
    background:#fff;
    color:#262e46;
    border:1px solid var(--border);
  }
.canvas .bar{position:absolute;bottom:0;width:24px;background:#2a4bff;border-radius:6px 6px 0 0;opacity:.9}
.canvas .label{position:absolute;bottom:6px;left:6px;font-size:12px;color:#aeb7d0}
.switch{position:relative;width:46px;height:26px;background:#1a2132;border-radius:999px;border:1px solid var(--border);}
.switch input{display:none}
.switch span{position:absolute;top:2px;left:2px;width:22px;height:22px;border-radius:999px;background:#c1c7de;transition:left .2s}
.switch input:checked + span{left:22px;background:#5be37f}
.inline{display:inline-block}
.footer{margin:20px 0 10px 0;color:#96a0bb;font-size:12px;opacity:.85}
@media (max-width:990px){
 .grid3{grid-template-columns:1fr}
 :root{--cellh:140px}
}
/* Mini post card used within the content calendar. Mirrors the
   deliverable preview styling but scaled down to fit calendar cells. */
.post-card .post-header{display:flex;align-items:center;gap:8px;margin-bottom:4px}
.post-card .avatar{width:24px;height:24px;border-radius:50%;background-size:cover;background-position:center}
.post-card .meta .name{font-weight:600;font-size:12px;line-height:1}
.post-card .meta .handle{font-size:10px;color:var(--muted);line-height:1}
.post-card .post-media{margin-top:4px}
.post-card .post-caption{font-size:12px;margin-top:4px;word-break:break-word}
/* Add card for creating new deliverables */
.add-card{
  border:2px dashed var(--border);
  border-radius:12px;
  background:rgba(255,255,255,0.02);
  color:var(--muted);
  cursor:pointer;
  min-height:180px;
  display:flex;
  align-items:center;
  justify-content:center;
  transition:background 0.2s;
}
.add-card:hover{
  background:rgba(255,255,255,0.05);
}
.add-card .plus{
  font-size:14px;
  color:var(--text);
}
/* Make scheduled post previews more compact within calendar cells */
.post-card{
  border:1px solid var(--border);
  border-radius:8px;
  background:var(--panel);
  padding:4px;
  max-height:140px;
  overflow:hidden;
  font-size:12px;
}
.post-card .post-media video,
.post-card .post-media img,
.post-card .post-media .placeholder{
  width:100%;
  height:auto;
  max-height:60px;
}
.post-card .post-caption{
  font-size:10px;
}

/* Responsive layout for mobile screens. On narrow viewports, stack
   components vertically, allow horizontal scrolling on tab bars and
   make deliverable cards occupy full width. These rules improve
   readability and usability on phones. */
@media (max-width: 600px) {
  .topbar, .tabs {
    flex-wrap: wrap;
    gap: 8px;
  }
  .topbar .hstack:last-child {
    flex-wrap: wrap;
    gap: 8px;
  }
  .grid3 {
    grid-template-columns: 1fr;
  }
  .card.deliverable {
    flex: 0 0 100%;
    min-width: 100%;
  }
  .calendar .cal-grid {
    grid-template-columns: repeat(7, 1fr);
  }
  .tabs {
    overflow-x: auto;
    scrollbar-width: none;
  }
  .tabs::-webkit-scrollbar {
    display: none;
  }
  /* Ensure chips wrap nicely on small screens */
  .chips {
    flex-wrap: wrap;
    gap: 6px;
  }
  /* Compact the client name heading on small screens */
  .card h3 {
    font-size: 14px;
  }
}
</style>
<!-- Firebase JS SDKs for compatibility. These libraries enable Firebase Auth and
     Firestore in non-module environments. Replace the version numbers as
     needed when upgrading. -->

<!-- FIREBASE SAFE INIT (inserted before </head>) -->
<script>
  /* Safe Firebase initialization. This script initializes a single
     Firestore instance exactly once using the provided firebaseConfig.
     It exposes a helper window.getDb() to retrieve the cached Firestore
     instance and applies experimentalAutoDetectLongPolling to work
     reliably on restrictive networks. */
  window.firebaseConfig = window.firebaseConfig || (typeof firebaseConfig !== "undefined" ? firebaseConfig : null);
  (function initFirestoreOnce(){
    // Ensure Firebase SDK is loaded and Firestore is available.  If not,
    // bail early.  The SDK may not yet be loaded in very early stages of
    // document parsing.
    if (!window.firebase || !firebase.firestore) return;
    // If no apps are registered yet, attempt to initialize one only when
    // firebaseConfig is available.  Otherwise skip initialization for now
    // and avoid calling firebase.firestore() without a default app.  The
    // manual initializer later in the page will perform initialization
    // once firebaseConfig is defined.
    if (!firebase.apps.length) {
      if (window.firebaseConfig) {
        try {
          firebase.initializeApp(window.firebaseConfig);
          console.log('[safe-init] Firebase app initialized');
        } catch (e) {
          console.warn('[safe-init] Firebase initialization failed:', e?.message);
        }
      } else {
        // No config provided yet; cannot initialise.  Do not call
        // firebase.firestore() to avoid the no-app error.  Defer
        // initialization until firebaseConfig is defined.  The manual
        // initializer below will run once configuration is available.
        console.warn('[safe-init] No firebaseConfig found at init; skipping');
        return;
      }
    }
    // At this point an app should exist; safely obtain the Firestore instance.
    if (firebase.apps.length) {
      const db = firebase.firestore();
      try {
        db.settings({ experimentalAutoDetectLongPolling: true });
      } catch (e) {
        console.warn('[safe-init] Firestore settings already applied:', e?.message);
      }
      window.__db = db;
    }
  })();
  window.getDb = function(){
    return window.__db || (firebase.apps.length ? firebase.firestore() : null);
  };
</script>
<!-- /FIREBASE SAFE INIT -->

</head>
<body>
  <script>
    (function bootHydrate(){
      var db = (window.getDb && window.getDb()) || (firebase.firestore && firebase.firestore());
      if (!db) { console.warn('[boot] no db'); return; }
      db.doc('dashboards/org-marlow-media').get().then(function(snap){
        var d = snap.exists ? (snap.data()||{}) : {};
        window.state = window.state || {};
        var tasks = Array.isArray(d.tasks) ? d.tasks.slice(0) : [];
        var clients = (d.clients && typeof d.clients === 'object') ? d.clients : {};

        function toStr(x){ return x==null ? '' : String(x); }
        function toNum(x){ var n = Number(x); return Number.isFinite(n) ? n : 0; }
        function iso(x){
          if (!x) return '';
          if (x instanceof Date) return x.toISOString().slice(0,10);
          var m = String(x).match(/^(\d{4}-\d{2}-\d{2})/); return m ? m[1] : toStr(x);
        }

        tasks = tasks.map(function(t){
          var o = {
            id:         t && t.id ? String(t.id) : undefined,
            date:       iso(t && t.date),
            start:      toStr((t && t.start) || '09:00'),
            duration:   toNum((t && t.duration) || 60),
            clientId:   toStr((t && t.clientId) || ''),
            type:       toStr((t && t.type) || 'task'),
            title:      toStr((t && t.title) || 'Task')
          };
          if (o.clientId && (!clients[o.clientId] || !clients[o.clientId].name)){
            clients[o.clientId] = { name: o.title || o.clientId };
          }
          var out = {}; for (var k in o) if (o[k] !== undefined) out[k] = o[k]; return out;
        });

        window.state.tasks = tasks;
        window.state.clients = clients;
        if (!window.state.currentUserId) window.state.currentUserId = 'all';
        window.state.filters = {};
        console.log('[boot] hydrated -> tasks', tasks.length, 'clients', Object.keys(clients).length);

        if (typeof window.render === 'function') { try { window.render(); } catch(e){ console.warn('[boot] render err', e&&e.message); } }
      }).catch(function(e){
        console.warn('[boot] hydrate failed', e && e.message);
        if (typeof window.render === 'function') { try { window.render(); } catch(_){} }
      });
    })();
  </script>

  <script>
    (function hydrateOrgFirstPlus(){
      try {
        var db = (window.getDb && window.getDb()) || (firebase.firestore && firebase.firestore());
        if (!db) { console.warn('[boot+] no db'); return; }
        db.doc('dashboards/org-marlow-media').get().then(function(snap){
          var d = snap.exists ? (snap.data()||{}) : {};
          window.state = window.state || {};
          var tasks = Array.isArray(d.tasks) ? d.tasks.slice(0) : [];
          var clients = (d.clients && typeof d.clients === 'object') ? d.clients : {};

          function toStr(x){ return x==null ? '' : String(x); }
          function toNum(x){ var n = Number(x); return Number.isFinite(n) ? n : 0; }
          function iso(x){
            if (!x) return '';
            if (x instanceof Date) return x.toISOString().slice(0,10);
            var m = String(x).match(/^(\d{4}-\d{2}-\d{2})/); return m ? m[1] : toStr(x);
          }

          tasks = tasks.map(function(t){
            var o = {
              id:         t && t.id ? String(t.id) : undefined,
              date:       iso(t && t.date),
              start:      toStr((t && t.start) || '09:00'),
              duration:   toNum((t && t.duration) || 60),
              clientId:   toStr((t && t.clientId) || ''),
              type:       toStr((t && t.type) || 'task'),
              title:      toStr((t && t.title) || 'Task')
            };
            if (o.clientId && (!clients[o.clientId] || !clients[o.clientId].name)){
              clients[o.clientId] = { name: o.title || o.clientId };
            }
            var out = {}; for (var k in o) if (o[k] !== undefined) out[k] = o[k]; return out;
          });

          window.state.tasks = tasks;
          window.state.clients = clients;
          if (!window.state.currentUserId) window.state.currentUserId = 'all';
          window.state.filters = {};
          console.log('[boot+] org hydrate -> tasks', tasks.length, 'clients', Object.keys(clients).length);
          if (typeof window.render === 'function') { try { window.render(); } catch(e){ console.warn('[boot+] render err', e&&e.message); } }
        }).catch(function(e){
          console.warn('[boot+] hydrate failed', e && e.message);
          if (typeof window.render === 'function') { try { window.render(); } catch(_){} }
        });
      } catch (e) {
        console.warn('[boot+] hydrate exception', e && e.message);
      }
    })();
  </script>

  <script>
    (function hydrateOrgFirst(){
      try {
        var db = (window.getDb && window.getDb()) || (firebase.firestore && firebase.firestore());
        if (!db) { console.warn('[boot] no db'); return; }
        db.doc('dashboards/org-marlow-media').get().then(function(snap){
          var d = snap.exists ? (snap.data()||{}) : {};
          window.state = window.state || {};
          window.state.tasks = Array.isArray(d.tasks) ? d.tasks.slice(0) : [];
          if (!window.state.currentUserId) window.state.currentUserId = 'all';
          window.state.filters = {};
          console.log('[boot] org hydrate -> tasks', (window.state.tasks||[]).length);
          if (typeof window.render === 'function') { try { window.render(); } catch(e){ console.warn('[boot] render err', e&&e.message); } }
        }).catch(function(e){
          console.warn('[boot] org hydrate failed', e && e.message);
          if (typeof window.render === 'function') { try { window.render(); } catch(_){} }
        });
      } catch (e) {
        console.warn('[boot] hydrate exception', e && e.message);
      }
    })();
  </script>

<div id="app">
  <div class="topbar">
    <div class="hstack">
    <!-- Removed beta badge now that site is production ready -->
    <!-- <div class="badge">Beta</div> -->
      <div class="brand">Marlow Media Calendar</div>
      <div class="small" id="saveStatus"></div>
    </div>
    <div class="hstack">
      <label class="small">Viewing as</label>
      <select id="viewAs"></select>
      <button class="btn small secondary" id="backupBtn">Backup</button>
      <label class="btn small ghost inline" for="restoreInput">Restore</label>
      <input id="restoreInput" type="file" accept="application/json" class="hidden" />
    </div>
  </div>

  <div class="tabs" id="tabs"></div>
  <div id="screen"></div>
  <div class="footer">All data is stored locally in your browser (localStorage). Use Backup/Restore to move between computers or to keep a safe copy.</div>
</div>

<!-- modals -->
<div class="modal-backdrop" id="modalBackdrop">
 <div class="modal" id="modal"></div>
</div>

<script>
/*** util ***/
const $ = (sel, el=document)=>el.querySelector(sel);
const $$=(sel, el=document)=>Array.from(el.querySelectorAll(sel));
// Format a date string in the user's local timezone. The original
// implementation used Date.toISOString() which always returns the
// value in UTC. This caused the dashboard to display the wrong day
// (e.g. one day behind) for users in the America/New_York timezone.
// Convert the incoming date to a locale string in the target
// timezone and then parse it back to a Date object so that
// toISOString() will reflect the correct local date. Finally slice
// the ISO string to keep only the YYYY‑MM‑DD portion.
const fmtDate = (d) => {
  // Normalize the supplied date into a plain Date instance. Accept
  // strings or Date objects. If d is falsy or invalid, return an empty
  // string to avoid throwing. Previously we used toLocaleString with a
  // timezone, which could shift the date when converting between
  // locales. Instead, extract the year, month and day directly and
  // construct a new Date at midnight local time. This avoids DST
  // issues and ensures fmtDate(parseDate(x)) === x for valid ISO
  // strings. Finally convert to ISO and take the first 10 chars.
  if(!d) return '';
  const dt = (d instanceof Date) ? d : new Date(d);
  if(!(dt instanceof Date) || isNaN(dt.getTime())) return '';
  const localMidnight = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
  return localMidnight.toISOString().slice(0,10);
};
const parseDate = s => { const [y,m,dd]=s.split('-').map(Number); return new Date(y, m-1, dd); };

// Convert a variety of date inputs into a valid Date object. The existing
// `parseDate` helper only handles strings in YYYY-MM-DD format. However
// client onboarding dates and lead win dates may come from native
// date inputs or stored ISO strings with time components (e.g.
// "2025-08-29T00:00:00.000Z"). In these cases `parseDate` would
// return an invalid date because splitting on hyphens produces a
// trailing time segment that cannot be parsed to a number. This utility
// accepts either a Date instance or any parsable date string and
// gracefully falls back to the built‑in Date constructor when
// `parseDate` fails. If the resulting date is invalid, null is
// returned.
function toDate(val){
  if(!val) return null;
  if(val instanceof Date){
    return isNaN(val.getTime()) ? null : val;
  }
  // First attempt to parse as YYYY‑MM‑DD
  let d = parseDate(val);
  if(d instanceof Date && !isNaN(d.getTime())) return d;
  // Fallback to native Date parsing for ISO strings and other formats
  d = new Date(val);
  return (d instanceof Date && !isNaN(d.getTime())) ? d : null;
}
// Return today's date in YYYY‑MM‑DD. Allow overriding via state.todayOverride
// so that the owner can manually adjust the 'current' date from settings.
const todayStr = () => {
  try {
    // If state has a todayOverride defined, use it. Parse and format to
    // ensure consistency with timezone handling. When the override is
    // cleared (empty string or null), fall back to the current date.
    const ov = (window.state && window.state.todayOverride) ? window.state.todayOverride : null;
    if(ov){
      // Accept the override as an ISO string (YYYY‑MM‑DD). Format
      // through fmtDate/parseDate to ensure the same local timezone
      // handling as other dates in the app.
      return fmtDate(parseDate(ov));
    }
  } catch(e){}
  return fmtDate(new Date());
};
const uid = ()=>Math.random().toString(36).slice(2,10);
const deepClone = o=>JSON.parse(JSON.stringify(o));
const range = (n)=>Array.from({length:n}, (_,i)=>i);
// Add n days to a date or date string. Accepts either a string in
// YYYY‑MM‑DD format or a Date object. Returns a formatted date
// string using fmtDate to ensure proper timezone handling. Previously
// this function only accepted strings, causing parseDate to fail
// when a Date object was passed (e.g. when calling addDays with
// parseDate(...) directly). Support both types to avoid Invalid
// Date errors.
const addDays = (s, n) => {
  let base;
  if(s instanceof Date){
    base = s;
  } else {
    // If s is a string, parse it. Otherwise attempt to construct a
    // Date from it directly (covers unexpected formats).
    base = parseDate(s);
    if(!(base instanceof Date) || isNaN(base.getTime())){
      base = new Date(s);
    }
  }
  const newDate = new Date(base.getTime() + n * 86400000);
  return fmtDate(newDate);
};

function download(name, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type:'application/json'}));
  a.download = name;
  a.click();
}

/*** data ***/
const DEFAULT = {
  // Do not set a default current user. A login prompt will
  // appear on first load to let each employee pick their profile.
  currentUserId: null,
  users: {
    "u-OWNER": { id:"u-OWNER", name:"Owner (You)", role:"owner", skills:["script","film","photo","edit","website","emailphone","sales"], days:{Sun:1,Mon:1,Tue:1,Wed:1,Thu:1,Fri:1,Sat:1}, hoursPerDay:12, start:"09:00", password:"owner1" },
    "u-RYAN":   { id:"u-RYAN", name:"Ryan Hatfield", role:"employee", skills:["script","film","photo","edit"], days:{Sun:0,Mon:1,Tue:1,Wed:1,Thu:1,Fri:0,Sat:0}, hoursPerDay:8, start:"09:00", password:"ryan1" }
  },
  durations: {
    kickoff:1, monthlyCall:.5,
    loginsText:.25, loginsCall:.5,
    influencerFind:2, influencerConfirm:.25, influencerShoot:4,
    scriptingHour:1, editingPer4:3,
    photoPerHour:1,
    posting:1,
    websitePlan:1, websiteCapture:4, websiteBuild:8, websiteQA:2, websitePublish:1, websiteSend:.5,
    emailSetup:1, emailSchedule:.5, emailReport:.5,
    phoneSetup:1
  },
  prices: { none:0, trial:1500, mini:2500, medium:3500, large:4500, website:500 },
  commissionPct: 0.10,
  // Persist the preferred theme. "dark" is default but can be toggled
  // to "light" from the Settings page. Stored in localStorage so the
  // dashboard remembers your preference on reload.
  theme: "dark",
  clients: {},
  leads: [],
  tasks: [], // {id, clientId, name, date, start, duration, type, assigneeId, done=false}
  archives: {} // clientId -> [{name, date, assigneeId}]
};

// Use a versioned storage key. Changing this key will force the app to
// ignore any data saved under older versions. This is helpful when
// significant data model changes occur that could break revenue
// calculations on legacy datasets. See user report about phantom
// revenue appearing across months; using a new key resets the data
// store for this updated version of the dashboard. If you wish to
// migrate old data, use the Backup/Restore functionality.
// Bump the storage key to isolate this version of the dashboard from
// prior builds. Using a new key prevents stale data from older
// versions (e.g. clients with incorrect package labels) from
// polluting the revenue calculations. See user feedback about
// lingering revenue from old data.
// Bump the storage key to force a fresh data snapshot. Older versions
// of the dashboard stored contract lengths and package identifiers in
// inconsistent ways, which can poison the new logic. Changing the
// STORE_KEY ensures localStorage from previous versions does not
// interfere with this build. If you need to preserve old data, use
// the Backup/Restore feature before switching to this version.
// Bump the storage key again to ensure a fresh data snapshot for this
// iteration. Changing the key invalidates old localStorage entries
// associated with prior versions (v5, v6, v7, etc.) and avoids
// lingering tasks or payments that could interfere with the new
// payment scheduling logic. See user complaints about phantom
// revenue persisting across months.
// Update the storage key to v12 to invalidate existing localStorage
// data from earlier test runs. This ensures the dashboard starts
// fresh without pre‑seeded clients when reloaded after this patch.
// Bump the storage key to invalidate prior cached data. This forces
// a fresh state the next time the app loads so that old clients
// created under previous versions do not persist. See user report
// about stale sample clients.
// Bump the store key whenever the data schema changes or when we
// want to force users to start with a fresh set of clients. This
// ensures stale data from older versions of the dashboard does not
// persist across reloads. See user feedback about seeing old
// revenue bars despite schedule fixes.
// Bump the STORE_KEY to force a fresh localStorage state.  Each
// increment here resets the dashboard data so that stale clients,
// tasks and revenue from prior iterations don't carry over.  If you
// encounter unexpected data persisting across reloads, incrementing
// this key will start with a clean slate.
// Bump the store key to invalidate localStorage and ensure fresh state
// Bump the STORE_KEY to invalidate old cached data and start with a
// completely fresh state.  This ensures that lingering tasks from
// previous versions (which may have scheduled payments incorrectly)
// do not appear in the new revenue chart.
// Fix the storage key at a new version to avoid future accidental resets.  Do not
// increment this key again unless the data schema changes in a way that is
// incompatible with previous versions.  If the key is changed, existing
// localStorage entries will be ignored unless migrated (see migration logic
// below).  Previously, the dashboard bumped this key on each release which
// inadvertently cleared user data.  We now freeze it at v23 and migrate
// older versions on first load.
const STORE_KEY = "marlow.dashboard.v23";

/* --------------------------------------------------------------------------
 * Firebase integration
 *
 * To enable cloud persistence across devices and users, this dashboard can
 * optionally save and load state from a remote Firestore database.  Provide
 * your own Firebase project configuration below.  You can obtain these
 * values from the Firebase console after creating a project.  Without
 * configuration the dashboard will fall back to localStorage only.
 */
const firebaseConfig = {
  apiKey: "AIzaSyCaIF2is5_swIcz-QEogWRnE2OJX0xgaZc",
  authDomain: "marlow-media-calendar.firebaseapp.com",
  projectId: "marlow-media-calendar",
  // Correct the storage bucket value.  When using the Firebase config
  // object you must provide the canonical bucket name (ending in
  // .appspot.com).  Using the firebasestorage.app host here will
  // prevent the Firestore client from connecting correctly and
  // produce HTTP 400 errors.
  storageBucket: "marlow-media-calendar.appspot.com",
  messagingSenderId: "664519075124",
  appId: "1:664519075124:web:6380ee0e1ddb07b3c6f161"
};

// Expose firebaseConfig on the global window so that the safe init script
// (loaded earlier in <head>) can access it. Without this assignment,
// firebaseConfig is undefined when the safe init runs, causing
// firebase.initializeApp() not to be called. This resolves the
// "Firebase: No Firebase App '[DEFAULT]' has been created" error in
// incognito or fresh sessions.
if (typeof window !== 'undefined') {
  window.firebaseConfig = firebaseConfig;
}

// Initialize Firebase if config values are provided.  Surround with a try/catch
// to avoid runtime errors when the Firebase SDK has not been loaded or when
// configuration is incomplete. Use window.getDb() from the safe init above.
let db = null;
try {
  // Use the helper from the safe init to obtain the Firestore instance.
  if (typeof window !== 'undefined' && typeof window.getDb === 'function') {
    db = window.getDb();
  }
  // If safe init hasn't run yet but Firebase and the config are available,
  // initialize the app manually. This prevents errors in incognito or
  // other contexts where the safe init executes before firebaseConfig is defined.
  if (!db && typeof firebase !== 'undefined' && firebase && firebase.apps && firebase.apps.length === 0 && typeof firebaseConfig !== 'undefined') {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    try {
      db.settings({ experimentalAutoDetectLongPolling: true });
    } catch (_) {}
    window.__db = db;
  }
} catch (e) {
  console.warn('Firebase initialization skipped:', e);
}

// Persist the current state to Firestore under the currentUserId.  This
// function is a no-op when Firebase is not configured.  Saving remotely
// enables multiple users to share the same dashboard data across devices.
async function saveRemoteState() {
  try {
    if (!db || !state) return;
    // Persist the entire state to the per‑user document if a user ID is set.
    if (state.currentUserId) {
      await db.collection('dashboards').doc(state.currentUserId).set(state);
    }
    // Also persist a trimmed version of state to the shared org document so that
    // tasks, users and clients are available for fresh sessions.  Use merge:true
    // to avoid overwriting other org‑level fields.
    const orgPatch = {
      _ver: Date.now(),
      users:   state.users   || {},
      clients: state.clients || {},
      tasks:   Array.isArray(state.tasks) ? state.tasks : []
    };
    await db.collection('dashboards').doc('org-marlow-media').set(orgPatch, { merge: true });
  } catch (e) {
    console.error('saveRemoteState failed', e);
  }
}

// Load dashboard state from Firestore for the given user ID.  Returns null
// if no remote data exists or if Firebase is not configured.  When data is
// found the caller should merge or replace the in-memory state before
// calling render() and save().
async function loadRemoteState(uid) {
  try {
    if (!db || !uid) return null;
    const docRef = db.collection('dashboards').doc(uid);
    const snap = await docRef.get();
    return snap.exists ? snap.data() : null;
  } catch (e) {
    console.error('loadRemoteState failed', e);
    return null;
  }
}

/* --------------------------------------------------------------------------
 * Package metadata and task type definitions
 *
 * These constants define the behavior and durations of different client
 * packages as well as shorthand codes for tasks.  They must be defined
 * before load() so that normalization and scheduling functions can use
 * them during initial data loading.
 */
const PKG_META = {
  none:{months:0, influencers:0, scriptHrs:0, filmHrs:0, photoHrs:0, videoCount:0, photoCount:0, carouselCount:0, emailCount:0},
  // Trial package: 1 month, 4 videos, 4 photos, 4 carousels. Includes 2h scripting, 4h filming, 1h photography.
  trial:{months:1, influencers:1, scriptHrs:2, filmHrs:4, photoHrs:1, videoCount:4, photoCount:4, carouselCount:4, emailCount:1},
  // Mini/Regular package: 6 months, 8 videos, 6 photos, 5 carousels per month.
  mini:{months:6, influencers:1, scriptHrs:4, filmHrs:8, photoHrs:2, videoCount:8, photoCount:6, carouselCount:5, emailCount:1},
  // Medium package: grows by the same amount as mini; 12 videos, 8 photos, 6 carousels per month.
  medium:{months:6, influencers:2, scriptHrs:6, filmHrs:12, photoHrs:2, videoCount:12, photoCount:8, carouselCount:6, emailCount:1},
  // Large package: 16 videos, 10 photos, 7 carousels per month; 8h scripting, 16h filming.
  large:{months:6, influencers:3, scriptHrs:8, filmHrs:16, photoHrs:2, videoCount:16, photoCount:10, carouselCount:7, emailCount:1},
  // Website-only packages run for one month and include no video/photo content.
  website:{months:1, influencers:0, scriptHrs:0, filmHrs:0, photoHrs:0, videoCount:0, photoCount:0, carouselCount:0, emailCount:0}
};
const TASK_TYPES = {S:"script", F:"film", E:"edit", P:"photo", N:"ops", W:"website", L:"ops"};

function load(){
  try{
    // Attempt to load from the current storage key.  If no data is found
    // under this key, migrate data from the most recent previous version.
    let raw = localStorage.getItem(STORE_KEY);
    if(!raw){
      // List of older storage keys in descending order of preference.  If
      // data exists under any of these keys, copy it into the current
      // STORE_KEY so that existing dashboards are preserved when the key is
      // bumped.  Only the first available dataset is migrated.
      const prevKeys = [
        "marlow.dashboard.v22",
        "marlow.dashboard.v21",
        "marlow.dashboard.v20",
        "marlow.dashboard.v19",
        "marlow.dashboard.v18"
      ];
      for(const k of prevKeys){
        const oldRaw = localStorage.getItem(k);
        if(oldRaw){
          // Copy the old data into the new key.  Do not remove the old
          // entry so that the user can still restore manually via
          // Backup/Restore if desired.
          localStorage.setItem(STORE_KEY, oldRaw);
          raw = oldRaw;
          break;
        }
      }
    }
    if(!raw) return deepClone(DEFAULT);
    const obj = JSON.parse(raw);
    // Safety shims
    obj.archives ||= {};
    obj.leads ||= [];
    obj.wonLeads ||= [];
    obj.tasks ||= [];
    obj.prices ||= deepClone(DEFAULT.prices);
    obj.commissionPct ??= 0.10;
    obj.durations = Object.assign({}, DEFAULT.durations, obj.durations||{});
    // Normalize package identifiers on existing clients. In older
    // versions of the dashboard, the package property could be
    // stored as a human‑readable label such as "Trial (1 mo)" or
    // "Regular (6 mo)", rather than the canonical key (e.g.,
    // "trial", "mini"). This prevented lookups into PKG_META and
    // caused revenue miscalculations. Convert any non‑standard
    // identifiers to their canonical form by matching on
    // substrings. If no match is found, default to "none".
    if(obj.clients && typeof obj.clients === 'object'){
      Object.values(obj.clients).forEach(c => {
        const p = c && typeof c.package === 'string' ? c.package : '';
        if(!PKG_META[p]){
          const lower = p.toLowerCase();
          if(lower.includes('trial')) c.package = 'trial';
          else if(lower.includes('regular') || lower.includes('mini')) c.package = 'mini';
          else if(lower.includes('medium')) c.package = 'medium';
          else if(lower.includes('large')) c.package = 'large';
          else if(lower.includes('website')) c.package = 'website';
          else c.package = 'none';
        }
      });
    }
    return obj;
  }catch(e){
    console.error("load failed", e);
    return deepClone(DEFAULT);
  }
}
let state = load();
// Always reset the revenue view to the current month/year on load.
// Persisting the last viewed month in localStorage confused some users
// because reopening the dashboard weeks or months later would show an
// outdated month (e.g. August 2026). To avoid this, override the
// revYear/revMonth to the current date every time the page loads.
// Navigation will still update these values during the session, but
// they no longer persist across reloads. See user feedback about
// defaulting to the wrong month.
state.revYear = new Date().getFullYear();
state.revMonth = new Date().getMonth();

// Apply the current theme class to the document body. This helper
// toggles the 'light' class depending on the state's theme. When
// state.theme === 'light', the body receives the 'light' class which
// overrides dark theme variables. Otherwise the dark palette is used.
function applyTheme(){
  document.body.classList.toggle('light', state.theme === 'light');
}

function save(bounce=true){
  // Persist state locally
  localStorage.setItem(STORE_KEY, JSON.stringify(state));
  // Persist state remotely (if Firebase is configured).  This call is
  // asynchronous and errors are handled inside saveRemoteState().
  saveRemoteState();
  const s = $("#saveStatus");
  s.textContent = "Saved";
  setTimeout(()=>s.textContent="", 900);

  // Notify persistence patch that the state has changed.  This event
  // triggers additional local and remote persistence (including tasks)
  // via the event listeners defined in the persistence patch script.
  try {
    window.dispatchEvent(new Event('state:changed'));
  } catch (_) {}
}

/*** navigation ***/
// Include a new Content tab for managing posts across clients. The Content
// calendar allows viewing and scheduling social media posts separate from
// project tasks. The order of tabs has been adjusted so Content appears
// between Clients and Employees to mirror the workflow: after adding
// clients you can immediately begin managing their content.
// Tabs are determined dynamically based on the logged‑in user's role. Clients
// see only Overview and Content. Employees may lack access to Sales,
// Employees or Settings depending on their role. Owners see all tabs.
function renderTabs(){
  const el = $("#tabs");
  if(!el) return;
  let tabs = ["Overview","Clients","Content","Employees","Sales","Settings"];
  if(isClient()){
    // Clients can view Overview, Content and change their settings (password)
    tabs = ["Overview","Content","Settings"];
  } else {
    const role = state.users[state.currentUserId]?.role || '';
    // Hide Settings for non‑owners
    if(role !== 'owner') tabs = tabs.filter(t => t !== 'Settings');
    // Hide Sales for non‑sales roles and non‑owners
    if(role !== 'owner' && role !== 'sales') tabs = tabs.filter(t => t !== 'Sales');
    // Hide Employees for non‑owners
    if(role !== 'owner') tabs = tabs.filter(t => t !== 'Employees');
  }
  // Ensure the current tab is valid; if not, default to the first available tab
  if(!tabs.includes(currentTab)) currentTab = tabs[0];
  el.innerHTML = tabs.map(t=>`<div class="tab ${t===currentTab?'active':''}" data-tab="${t}">${t}</div>`).join("");
  el.onclick = (e)=>{
    const tab = e.target.closest(".tab")?.dataset.tab;
    if(tab){ currentTab = tab; render(); }
  };
  // Add a logout button to the end of the tab bar when a user is logged in.
  const logoutBtnId = 'logoutBtn';
  let existing = document.getElementById(logoutBtnId);
  if(!existing){
    const btn = document.createElement('button');
    btn.className = 'btn small secondary';
    btn.id = logoutBtnId;
    btn.textContent = 'Logout';
    btn.style.marginLeft = '12px';
    btn.onclick = () => {
      state.currentUserId = null;
      save(); render();
    };
    el.appendChild(btn);
  }
}

let currentTab = "Overview";
function setViewAsOptions(){
  const sel = $("#viewAs");
  // When a client is logged in, hide both the "Viewing as" label and the
  // selector so they cannot switch between team members. The label and
  // select live as the first two children of their parent hstack.
  const container = sel?.parentNode;
  // Hide the "Viewing as" label and the select when a client is logged in.
  // Use query selectors to target the elements rather than relying on
  // child indices, which can vary if additional buttons are added.
  if(isClient()){
    if(container){
      const lbl = container.querySelector('label.small');
      if(lbl) lbl.style.display = 'none';
    }
    if(sel) sel.style.display = 'none';
    return;
  } else {
    // Show the label and select for non-client users
    if(container){
      const lbl = container.querySelector('label.small');
      if(lbl) lbl.style.display = '';
    }
    if(sel) sel.style.display = '';
  }
  // Populate the view-as select for non-client users. Include a Team (All)
  // option and list each user. Mark the current selection accordingly.
  let optionsHtml = `<option value="all" ${state.currentUserId==='all'?'selected':''}>Team (All)</option>`;
  optionsHtml += Object.values(state.users).map(u=>`<option value="${u.id}" ${u.id===state.currentUserId?'selected':''}>${u.name}</option>`).join("");
  if(sel){ sel.innerHTML = optionsHtml; }
  if(sel){
    sel.onchange = (e)=>{
      const val = e.target.value;
      state.currentUserId = val;
      save(); render();
    };
  }
}

/*** permissions ***/
function isOwner(){ return state.users[state.currentUserId]?.role === "owner"; }
// A user can view revenue if they are an owner or have the sales role. When
// viewing as "Team (All)" (i.e. state.currentUserId === 'all'), treat
// the current user as having full visibility. This prevents the revenue
// chart from being hidden when the owner selects the team view.
function canSeeRevenue(){
  if(state.currentUserId === 'all') return true;
  return isOwner() || state.users[state.currentUserId]?.role === "sales";
}
function visibleAssigneeId(){
  // If viewing as "Team (All)" or the current user is the owner, show all tasks
  // When logged in as a client, do not filter by assignee so the client sees
  // all tasks for their own account. Returning null here causes tasksOnDate
  // and other helpers to ignore the assignee filter.
  if(isClient()) return null;
  // When viewing as "Team (All)" show all tasks. Otherwise restrict to the selected user.
  if(state.currentUserId === 'all') return null;
  return state.currentUserId;
} // null => all

// Determine if the logged‑in user is a client. Clients have IDs prefixed
// with "client-". A client user should only see their own tasks and
// content and will have limited access to tabs and controls. Use
// currentClientId() to extract the underlying client id when needed.
function isClient(){
  return state.currentUserId && typeof state.currentUserId === 'string' && state.currentUserId.startsWith('client-');
}

function currentClientId(){
  return isClient() ? state.currentUserId.slice('client-'.length) : null;
}

// Render a simple login screen allowing the user to select from
// available accounts. Users include employees/owners from state.users
// and clients (prefixed with client-). No passwords are enforced to
// keep the demo lightweight. Once a user is selected, the dashboard
// re-renders under their identity. A logout button will appear in
// the top bar when a user is logged in.

function renderLogin(){
  const screen = document.getElementById('screen');
  if(!screen) return;
  const cont = document.createElement('div');
  cont.style.maxWidth = '480px';
  cont.style.margin = '80px auto';
  cont.className = 'card';
  const userOpts = Object.values(state.users).map(u => `<option value="${u.id}">${u.name} (${u.role})</option>`).join('');
  cont.innerHTML = `
    <h3 style="text-align:center;margin-bottom:16px">Sign in</h3>
    <div class="chips" id="loginToggle" style="justify-content:center;margin-bottom:12px">
      <div class="chip active" data-mode="client">Client</div>
      <div class="chip" data-mode="employee">Employee</div>
    </div>
    <div id="clientForm" style="margin-top:16px">
      <label style="display:block;margin-bottom:6px">Client name</label>
      <input id="loginClientUsername" type="text" placeholder="Business name" style="width:100%;margin-bottom:8px"/>
      <label style="display:block;margin-bottom:6px">Password</label>
      <input id="loginClientPwd" type="password" placeholder="Password" style="width:100%"/>
      <button class="btn" id="loginClientBtn" style="width:100%;margin-top:8px">Login</button>
    </div>
    <div id="employeeForm" style="margin-top:16px;display:none">
      <label style="display:block;margin-bottom:6px">Employee account</label>
      <select id="loginUser" style="width:100%;margin-bottom:8px">${userOpts}</select>
      <label style="display:block;margin-bottom:6px">Password</label>
      <input id="loginUserPwd" type="password" placeholder="Password" style="width:100%" />
      <button class="btn" id="loginEmp" style="width:100%;margin-top:8px">Login</button>
    </div>
  `;
  screen.innerHTML = '';
  screen.appendChild(cont);
  // Toggle between login modes
  document.getElementById('loginToggle').onclick = (e) => {
    const chip = e.target.closest('.chip');
    if(!chip) return;
    const mode = chip.dataset.mode;
    document.querySelectorAll('#loginToggle .chip').forEach(ch => ch.classList.remove('active'));
    chip.classList.add('active');
    document.getElementById('clientForm').style.display = mode === 'client' ? '' : 'none';
    document.getElementById('employeeForm').style.display = mode === 'employee' ? '' : 'none';
  };
  // Employee login handler
  const empBtn = document.getElementById('loginEmp');
  if(empBtn){
    empBtn.onclick = async () => {
      const uid = document.getElementById('loginUser').value;
      const pwd = (document.getElementById('loginUserPwd')?.value || '').trim();
      if (!uid) { alert('Select an employee account.'); return; }
      const user = state.users[uid];
      const storedPwd = user?.password || '';
      if (!pwd) { alert('Please enter a password.'); return; }
      if (storedPwd && pwd === storedPwd) {
        // Set the logged in user id
        state.currentUserId = uid;
        // Attempt to load remote state for this user.  Replace the
        // in-memory state if data exists.  Otherwise continue with
        // the existing state (which may have been loaded from localStorage).
        const remote = await loadRemoteState(uid);
        if (remote) {
          // Merge remote users and clients into the current state without
          // discarding existing tasks or other local data. This prevents
          // blank calendars on refresh while still updating shared info.
          if (remote.users)   state.users   = { ...state.users,   ...remote.users };
          if (remote.clients) state.clients = { ...state.clients, ...remote.clients };
          // Merge tasks from remote: copy if local is empty, otherwise union/dedupe
          if (Array.isArray(remote.tasks)) {
            if (!Array.isArray(state.tasks) || state.tasks.length === 0) {
              state.tasks = remote.tasks.slice(0);
            } else {
              const sig = t => (t && (t.id !== undefined && t.id !== null)) ? String(t.id)
                             : [t && t.date || '', t && t.clientId || '', t && t.type || ''].join('|');
              const existing = new Set(state.tasks.map(sig));
              remote.tasks.forEach(t => {
                const k = sig(t);
                if (!existing.has(k)) {
                  existing.add(k);
                  state.tasks.push(t);
                }
              });
            }
          }
        }
        // Ensure currentUserId is retained after loading remote state
        state.currentUserId = uid;
        // Save to localStorage and remote, then render the dashboard
        save();
        render();
      } else {
        alert('Incorrect password.');
      }
    };
  }
  // Client login handler
  const clientBtn = document.getElementById('loginClientBtn');
  if(clientBtn){
    clientBtn.onclick = async () => {
      const uInput = document.getElementById('loginClientUsername').value.trim().toLowerCase();
      const pwdInput = document.getElementById('loginClientPwd').value.trim();
      if (!uInput || !pwdInput) {
        alert('Please enter both username and password.');
        return;
      }
      const cid = Object.keys(state.clients).find(k => {
        const cU = (state.clients[k].username || '').toLowerCase().trim();
        return cU === uInput;
      });
      if (cid) {
        const client = state.clients[cid];
        if (client.password && client.password === pwdInput) {
          // Compose the user id for clients (prefixed with "client-")
          state.currentUserId = 'client-' + cid;
          // Try to fetch remote state for this client.  Use the prefixed id
          // so that each client has isolated data in Firestore.
          const remote = await loadRemoteState(state.currentUserId);
          if (remote) {
            // Merge remote users and clients into the current state without
            // discarding existing tasks or other local data.
            if (remote.users)   state.users   = { ...state.users,   ...remote.users };
            if (remote.clients) state.clients = { ...state.clients, ...remote.clients };
            // Merge tasks similar to employee login
            if (Array.isArray(remote.tasks)) {
              if (!Array.isArray(state.tasks) || state.tasks.length === 0) {
                state.tasks = remote.tasks.slice(0);
              } else {
                const sig = t => (t && (t.id !== undefined && t.id !== null)) ? String(t.id)
                               : [t && t.date || '', t && t.clientId || '', t && t.type || ''].join('|');
                const existing = new Set(state.tasks.map(sig));
                remote.tasks.forEach(t => {
                  const k = sig(t);
                  if (!existing.has(k)) {
                    existing.add(k);
                    state.tasks.push(t);
                  }
                });
              }
            }
          }
          // Ensure currentUserId is retained after loading remote state
          state.currentUserId = 'client-' + cid;
          save();
          render();
        } else {
          alert('Incorrect password.');
        }
      } else {
        alert('Client not found.');
      }
    };
  }
}
/*** view state helpers ***/
// The Content tab and client calendars need to remember which client and
// which month/year are currently being viewed. Because the dashboard
// re-renders frequently, store these selections in module-level variables
// rather than in local closures. When the Content tab first loads it will
// default to the first client. Users can change the selected client
// via a dropdown. contentViewYear and contentViewMonth track the
// currently displayed month in the content calendar.
let contentClientId = null;
let contentViewYear = new Date().getFullYear();
let contentViewMonth = new Date().getMonth();

// Each client can show either a "work" calendar (for tasks) or a
// "content" calendar (for social media posts). Persist the current
// view for each client in this object keyed by client id. Defaults to
// "work" when undefined.
const clientViewModes = {};

// The content tab allows switching between different deliverable types
// (videos, photos, carousels, website) and between sets (for multi-
// month packages). Track the currently selected type and set at the
// module level so re-renders persist the choice. Defaults are
// populated when renderContent() is first invoked.
let contentType = 'video';
let contentSetIndex = 0;

/*** calendar ***/
function monthMatrix(year, month){ // month 0..11
  const first = new Date(year, month, 1);
  const startDay = (first.getDay()+6)%7; // start Mon? we will keep Sun-based=0 simpler. We'll keep Sunday index 0
  const start = new Date(year, month, 1 - first.getDay()); // Sunday as first cell
  const weeks = 6;
  const days = [];
  for(let i=0;i<42;i++){
    const d = new Date(start); d.setDate(start.getDate()+i);
    days.push(d);
  }
  return days;
}
const MONTHS = ["January","February","March","April","May","June","July","August","September","October","November","December"];

/*** task helpers ***/
function taskColor(type){
  const map = {S:"#69c", F:"#c96", E:"#6c9", P:"#9c6", N:"#b9c", L:"#d8b", W:"#7dd"};
  return map[type?.toUpperCase()] || "#6a7cff";
}

// Return the chosen colour for a client. Falls back to a default if
// none is defined. Client colours are selected when adding a client
// and stored on the client object.
function clientColor(clientId){
  const c = state.clients[clientId];
  return c?.color || '#915eff';
}
function requiredSkill(type){
  const map = {S:"script", F:"film", E:"edit", P:"photo", W:"website", N:"none", L:"ops"};
  if(type==="W"||type==="N"||type==="L") return null;
  return map[type?.toUpperCase()] || null;
}
function tasksOnDate(dateStr, clientId=null, assigneeFilter=null){
  return state.tasks.filter(t=>t.date===dateStr && (!clientId||t.clientId===clientId) && (!assigneeFilter || t.assigneeId===assigneeFilter));
}
function weeklyTasks(startStr, endStr, assigneeFilter=null){
  const start = parseDate(startStr).getTime();
  const end = parseDate(endStr).getTime();
  return state.tasks.filter(t=>{
    const tt = parseDate(t.date).getTime();
    return tt>=start && tt<=end && (!assigneeFilter||t.assigneeId===assigneeFilter);
  }).sort((a,b)=>a.date.localeCompare(b.date));
}

/*** allocation & capacity ***/
function empWorksOn(dateStr, emp){
  const d = parseDate(dateStr).getDay(); // 0 Sun..6 Sat
  const days = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  return !!emp.days[days[d]];
}
function empCapacityUsed(dateStr, empId){
  return state.tasks.filter(t=>t.date===dateStr && t.assigneeId===empId)
    .reduce((s,t)=>s + (Number(t.duration)||0),0);
}
function firstAvailableEmp(dateStr, skill){
  // Choose an employee who works on the given date and has the required
  // skill. Prefer non‑owner staff over the owner when possible so the
  // owner is only scheduled if no other employee with the skill is
  // available. Otherwise fall back to the owner. Always exclude sales
  // staff from production tasks.
  const emps = Object.values(state.users).filter(u => u.role !== "sales");
  // First try to find non‑owner employees who work that day and have the skill
  let candidates = emps.filter(e => e.role !== "owner" && empWorksOn(dateStr, e) && (!skill || e.skills.includes(skill)));
  // If none found, allow owners in the candidate list
  if(candidates.length === 0){
    candidates = emps.filter(e => empWorksOn(dateStr, e) && (!skill || e.skills.includes(skill)));
  }
  if(!candidates.length) return null;
  // Sort by the least hours used on the given date
  candidates.sort((a,b) => empCapacityUsed(dateStr, a.id) - empCapacityUsed(dateStr, b.id));
  return candidates[0];
}
function placeTask(dateStr, task){
  // ensure capacity; if over, push to next day
  let d = dateStr;
  let guard=0;
  while(guard<180){
    guard++;
    const reqSkill = requiredSkill(task.type);
    let emp = task.assigneeId ? state.users[task.assigneeId] : firstAvailableEmp(d, reqSkill);
    if(!emp){ d = addDays(d,1); continue; }
    const used = empCapacityUsed(d, emp.id);
    if(used + Number(task.duration||0) <= (emp.hoursPerDay||8)){
      task.assigneeId = emp.id;
      task.date = d;
      return;
    } else {
      d = addDays(d,1);
    }
  }
}

// Reassign all tasks for a given employee if they no longer meet the
// skill requirements. This helper loops through existing tasks and,
// for each task assigned to the provided employee, verifies whether
// they still have the required skill to perform it. If not, the task
// is cleared of its assignee and passed through placeTask() again to
// find a new suitable worker. After reassigning, the state is
// persisted. This is called after editing an employee's skills.
function reassignTasks(empId){
  state.tasks.forEach(t => {
    // Only consider tasks currently assigned to this employee
    if(t.assigneeId === empId){
      const skill = requiredSkill(t.type);
      const emp = state.users[empId];
      // Determine the best candidate for this task given its date and skill.
      // If another employee is available who better matches the skill or
      // simply isn't the owner, move the task to that candidate. We also
      // reassign if the employee no longer has the required skill.
      if(skill){
        const best = firstAvailableEmp(t.date, skill);
        if(best && best.id !== empId){
          t.assigneeId = best.id;
          return;
        }
        // If the employee lost the skill, clear and re-place
        if(!emp.skills.includes(skill)){
          t.assigneeId = null;
          placeTask(t.date, t);
          return;
        }
      }
    }
  });
  save();
}

/*** scheduling ***
 * Package metadata definitions are moved above load() for early availability.
 */

function makeTask(clientId, name, date, start="09:00", duration=1, type="N", extra={}){
  return Object.assign({id:uid(), clientId, name, date, start, duration, type, assigneeId:null, done:false}, extra);
}

/*** content scheduling ***/
// Create a content posting schedule for a new client. Posts are placed
// on the content calendar (client.content) based on the package size
// and a simple weekday mapping: videos go out on Monday and Friday,
// photos on Tuesday and Saturday, and carousels on Wednesday and
// Sunday. The number of posts per type is proportional to the
// package's film hours (e.g. 4, 8, 12, 16). Scheduling begins 28
// days after onboarding and repeats monthly for the length of the
// package. Posts are evenly distributed across the month.
function scheduleContentPosts(client){
  const meta = PKG_META[client.package || 'none'] || {months:0, filmHrs:0, photoHrs:0};
  const monthsCount = meta.months || 0;
  if(monthsCount <= 0) return;
  // Determine number of posts per type based on package definitions. Video,
  // photo and carousel counts are defined explicitly in PKG_META. Fall back to
  // filmHrs when not provided.
  const videoCount = meta.videoCount ?? Math.max(0, meta.filmHrs);
  const photoCount = meta.photoCount ?? Math.max(0, meta.filmHrs);
  const carouselCount = meta.carouselCount ?? Math.max(0, meta.filmHrs);
  const emailCount = meta.emailCount || 0;
  const startPosting = parseDate(addDays(client.onboard, 28));
  // Choose posting days based on the number of months. Trial packages (1
  // month) should spread content across the entire month by posting
  // each type once per week. Larger packages can post twice per week.
  const single = (meta.months === 1);
  const daysMap = {
    video: single ? [1] : [1,5],     // Monday (and Friday for multi-month)
    photo: single ? [2] : [2,6],     // Tuesday (and Saturday)
    carousel: single ? [3] : [3,0],  // Wednesday (and Sunday)
    email: [4]                       // Thursday for email campaigns regardless of package length
  };
  for(let m=0; m<monthsCount; m++){
    const base = new Date(startPosting);
    base.setDate(base.getDate() + 28*m);
    // helper to schedule posts for given type
    function scheduleFor(count, typeKey){
      const dows = daysMap[typeKey];
      let date = new Date(base);
      let scheduled = 0;
      while(scheduled < count){
        if(dows.includes(date.getDay())){
          const p = { id: uid(), title: typeKey.charAt(0).toUpperCase() + typeKey.slice(1), date: fmtDate(date), type: typeKey };
          if(!client.content) client.content = [];
          client.content.push(p);
          scheduled++;
        }
        // move to next day
        date.setDate(date.getDate()+1);
      }
    }
    scheduleFor(videoCount, 'video');
    scheduleFor(photoCount, 'photo');
    scheduleFor(carouselCount, 'carousel');
    if(emailCount > 0){
      scheduleFor(emailCount, 'email');
    }
  }
  save();
}

// Determine the highest numeric phase index for a client's tasks. The
// scheduleClientMonths function assigns a numeric phase to each task
// in its meta object. We use this helper to find the last
// scheduled phase when auto‑scheduling additional months.
function getMaxPhaseForClient(client){
  if(!client) return -1;
  let max = -1;
  if(Array.isArray(state.tasks)){
    state.tasks.forEach(t => {
      if(t.clientId === client.id && t.meta && typeof t.meta.phase === 'number'){
        if(t.meta.phase > max) max = t.meta.phase;
      }
    });
  }
  return max;
}

// Schedule additional content posts starting at a particular month index.
// This function mirrors scheduleContentPosts but allows specifying the
// starting month so that posts can be appended to an existing schedule
// instead of overwriting it. It also ensures posts are not duplicated
// when run multiple times by checking for existing posts on the same
// date and type.
function scheduleAdditionalContentPosts(client, startMonthIndex=0, months=1){
  if(!client) return;
  const meta = PKG_META[client.package||'none'] || {};
  const videoCount = meta.videoCount ?? Math.max(0, meta.filmHrs);
  const photoCount = meta.photoCount ?? Math.max(0, meta.filmHrs);
  const carouselCount = meta.carouselCount ?? Math.max(0, meta.filmHrs);
  const emailCount = meta.emailCount || 0;
  const single = (meta.months === 1);
  const daysMap = {
    video: single ? [1] : [1,5],
    photo: single ? [2] : [2,6],
    carousel: single ? [3] : [3,0],
    email: [4]
  };
  // Base posting date is four weeks after onboarding
  const basePosting = parseDate(addDays(client.onboard, 28));
  for(let m=0; m<months; m++){
    const base = new Date(basePosting);
    // Advance base by the desired number of 28‑day cycles
    base.setDate(base.getDate() + 28 * (startMonthIndex + m));
    function scheduleFor(count, typeKey){
      const dows = daysMap[typeKey];
      let date = new Date(base);
      let scheduled = 0;
      while(scheduled < count){
        if(dows.includes(date.getDay())){
          const dateStr = fmtDate(date);
          // Only create a new post if one doesn't already exist for
          // this date and type
          if(!client.content) client.content = [];
          const exists = client.content.some(p => p.date === dateStr && p.type === typeKey);
          if(!exists){
            const p = { id: uid(), title: typeKey.charAt(0).toUpperCase()+typeKey.slice(1), date: dateStr, type: typeKey };
            client.content.push(p);
            scheduled++;
          }
        }
        date.setDate(date.getDate() + 1);
      }
    }
    scheduleFor(videoCount, 'video');
    scheduleFor(photoCount, 'photo');
    scheduleFor(carouselCount, 'carousel');
    if(emailCount > 0){
      scheduleFor(emailCount, 'email');
    }
  }
  save();
}

// Ensure a client's draft deliverables exist. Creates arrays of draft
// objects for videos, photos and carousels based on the package's
// filming hours. Each draft holds input fields for ideas, scripts,
// examples, captions and final deliverables. Called when opening
// deliverable view for the first time.
function ensureDrafts(client){
  // If drafts already exist, do nothing. Drafts are created once per client.
  // If drafts have never been created, build all arrays from scratch based on the
  // client's package. Otherwise, ensure new deliverable types (like email or
  // website) are added when a package upgrade introduces them. We do not
  // recreate existing arrays so user data is preserved.
  const meta = PKG_META[client.package||'none'] || {videoCount:0, photoCount:0, carouselCount:0, emailCount:0, months:0};
  const months = Math.max(1, meta.months || 1);
  const makeDraft = () => ({id: uid(), idea:'', script:'', example:'', caption:'', finalVideo:'', finalCaption:'', used:false});
  const makeEmailDraft = () => ({id: uid(), offer:'', emailText:'', link:'', image:'', finalImage:'', finalOffer:'', finalEmailText:'', used:false});
  if(!client.drafts){
    // Create base drafts for video, photo and carousel
    const vTotal = (meta.videoCount || 0) * months;
    const pTotal = (meta.photoCount || 0) * months;
    const cTotal = (meta.carouselCount || 0) * months;
    const eTotal = (meta.emailCount || 0) * months;
    client.drafts = {
      video: Array.from({length:vTotal}, () => makeDraft()),
      photo: Array.from({length:pTotal}, () => makeDraft()),
      carousel: Array.from({length:cTotal}, () => makeDraft())
    };
    if(eTotal > 0) client.drafts.email = Array.from({length:eTotal}, () => makeEmailDraft());
    // Schedule content posts for email if not already scheduled. Avoid
    // duplicating posts by checking for existing unspecific email posts.
    try{
      if(typeof scheduleContentPosts === 'function' && (!client.content || !client.content.some(p => p.type === 'email'))){
        scheduleContentPosts(client);
      }
    }catch(e){}
    if(client.addons?.website || client.package === 'website'){
      client.drafts.website = [{ id: uid(), url:'', description:'', finalLink:'', used:false }];
    }
    return;
  }
  // At this point drafts exist. Ensure email drafts and website drafts are present
  // if the package supports them but the draft arrays are missing. Do not
  // overwrite existing drafts or shrink arrays; only add missing items.
  const currentEmailDrafts = client.drafts.email || [];
  const expectedEmailCount = (meta.emailCount || 0) * months;
  if(expectedEmailCount > 0 && currentEmailDrafts.length === 0){
    client.drafts.email = Array.from({length: expectedEmailCount}, () => makeEmailDraft());
    // Schedule email posts for the client if none exist yet
    try{
      if(typeof scheduleContentPosts === 'function' && (!client.content || !client.content.some(p => p.type === 'email'))){
        scheduleContentPosts(client);
      }
    }catch(e){}
  }
  // Ensure website draft exists if the client has the website addon or package
  if((client.addons?.website || client.package === 'website') && !client.drafts.website){
    client.drafts.website = [{ id: uid(), url:'', description:'', finalLink:'', used:false }];
  }
}

// Assign a draft deliverable to the client's scheduled posts. Finds the
// first unscheduled content post matching the type and attaches the
// draft details. Marks the draft as used. If no slots are available,
// shows an alert.
function assignDraftToCalendar(client, type, draft){
  if(!client) return;
  // Website deliverables are not scheduled on the social calendar. Simply
  // mark them as used when scheduled to indicate completion.
  if(type === 'website'){
    draft.used = true;
    // remove any lingering scheduled flag when a deliverable is posted
    draft.scheduledToFilm = false;
    save();
    return;
  }
  if(!client.content) client.content = [];
  let post = client.content.find(p=>p.type===type && !p.draftId);
  // When no posting slot is available, attempt to schedule additional posts
  // for this type. This prevents the "No available posting slot" error
  // when drafts are created after the initial scheduling or when all slots
  // have been used. Recompute the client's content array then look again.
  if(!post){
    // When no posting slot exists for this type, extend the schedule by
    // adding a new month of posts. Use the highest existing phase as
    // the starting point for new posts. scheduleAdditionalContentPosts
    // schedules posts per package definitions and avoids duplicating
    // existing slots. Fallback to scheduleContentPosts when the
    // additional scheduler is unavailable.
    try{
      const nextStart = (typeof getMaxPhaseForClient === 'function' ? getMaxPhaseForClient(client) + 1 : 0);
      if(typeof scheduleAdditionalContentPosts === 'function'){
        scheduleAdditionalContentPosts(client, nextStart, 1);
      } else if(typeof scheduleContentPosts === 'function'){
        scheduleContentPosts(client);
      }
    }catch(e){}
    post = client.content.find(p=>p.type===type && !p.draftId);
    if(!post){
      alert('No available posting slot for this type');
      return;
    }
  }
  post.draftId = draft.id;
  // Determine the title for the scheduled post based on the deliverable type. For
  // social posts (video/photo/carousel) use the final caption or caption as
  // before. For email campaigns, use the final offer or offer as the post
  // title since captions are not applicable. Fallback to the type name
  // capitalised when no suitable field exists.
  if(type === 'email'){
    post.title = draft.finalOffer || draft.offer || 'Email';
    // Store the email body on the post so clients can preview it later. Use
    // finalEmailText when present, otherwise fall back to the draft body.
    post.body = draft.finalEmailText || draft.emailText || '';
    // Also store the CTA link or general link for reference
    post.link = draft.link || '';
    // Include the image preview if available
    if(draft.finalImage) post.image = draft.finalImage;
  } else {
    post.title = draft.finalCaption || draft.caption || type.charAt(0).toUpperCase()+type.slice(1);
  }
  draft.used = true;
  // unschedule from any production tasks once posted
  draft.scheduledToFilm = false;
  save();
}

// Assign a draft deliverable to the next available filming task. Each
// filming task has a capacity equal to its duration (1h per draft).
// The draft is appended to the task's `cards` array. If no slots are
// available, an alert is shown. This does not schedule content posts;
// it merely prepares the draft for filming.
function assignDraftToFilming(client, type, draft){
  if(!client || !draft) return;
  // Prevent scheduling the same draft multiple times. If it has
  // already been marked as scheduled to film, show a message and skip.
  if(draft.scheduledToFilm){
    alert('This draft is already scheduled for filming.');
    return;
  }
  // Filming applies to video/photo/carousel types. Route drafts based on
  // keywords in the task names rather than exact equality so custom
  // names like "Filming Day 2" or "Photo session" still qualify.
  const tasks = state.tasks.filter(t=>t.clientId===client.id && (
    (type === 'video' && /filming/i.test(t.name)) ||
    ((type === 'photo' || type === 'carousel') && /photo/i.test(t.name))
  ));
  // Sort by date ascending
  tasks.sort((a,b)=> a.date.localeCompare(b.date));
  for(const t of tasks){
    // Determine maximum number of drafts that can fit in this task.
    // For photo capture tasks always allow up to 8 drafts (4 photos and 4
    // carousels per day) regardless of the task duration. Filming tasks
    // allow up to 4 drafts. For non‑photo tasks you can still honour the
    // duration if it is set by the user. Photo tasks ignore duration to
    // ensure all eight deliverables fit.
    let max;
    if (/photo/i.test(t.name)) {
      // Always provide 8 slots for photo/capture days
      max = 8;
    } else {
      max = 4;
      const durMax = Math.floor(t.duration || 0);
      if (durMax > 0) max = Math.min(max, durMax);
    }
    if(!t.meta) t.meta = {};
    if(!t.meta.cards) t.meta.cards = [];
    if(t.meta.cards.length < max){
      t.meta.cards.push({id: draft.id, type});
      // Mark as scheduled to a production task. Do not mark used; used
      // will be set only when posting to the calendar.
      draft.scheduledToFilm = true;
        // Additionally attach this draft to scripting and editing tasks for
        // the same client. This makes drafts available in later phases
        // without requiring manual assignment. Limit duplicates by
        // checking for existing entries.
        const editTasks = state.tasks.filter(x => x.clientId===client.id && /edit/i.test(x.name));
        const scriptTasks = state.tasks.filter(x => x.clientId===client.id && /script/i.test(x.name));
        [...editTasks, ...scriptTasks].forEach(et => {
          if(!et.meta) et.meta = {};
          if(!et.meta.cards) et.meta.cards = [];
          const exists = et.meta.cards.some(c => c.id === draft.id);
          if(!exists){
            et.meta.cards.push({id: draft.id, type});
          }
        });
      save();
      return;
    }
  }
  alert('No available filming slots for this client.');
}

// Remove a revenue deal without deleting the entire client or lead. When
// called with a deal object (as constructed in the revenue chart), it
// either clears the onboarding date on the client or removes the
// corresponding won lead. This effectively subtracts the deal from
// revenue calculations while preserving other data. After removal,
// the dashboard is re-rendered.
function deleteDeal(deal){
  if(!deal) return;
  // Remove client onboard revenue and any associated wonLead entry.
  // When a clientId is provided, clear the onboard date and also remove
  // any wonLead that references this client. Without removing the wonLead,
  // the personal revenue chart would continue to include the deal because
  // the win date is still stored in wonLeads. When a leadId is provided,
  // simply remove that wonLead entry.
  if(deal.clientId){
    const c = state.clients[deal.clientId];
    if(c){
      // Preserve original values for potential undo operations
      c._deletedOnboard = c.onboard;
      c._deletedPrice   = c.price;
      // Clear the onboard date so the deal no longer counts toward revenue
      c.onboard = '';
      // Also zero out the price. drawPersonRevenue multiplies price
      // by commission percentage even if the win date were left over,
      // so setting price to 0 prevents ghost commissions from appearing.
      c.price = 0;
    }
    // Remove won leads that reference this client so winDateMap doesn't
    // include it when calculating commissions.
    if(Array.isArray(state.wonLeads)){
      state.wonLeads = state.wonLeads.filter(w => w.clientId !== deal.clientId);
    }
  } else if(deal.leadId){
    // Deal originated from a won lead that has not yet converted to a client.
    if(Array.isArray(state.wonLeads)){
      state.wonLeads = state.wonLeads.filter(w => w.id !== deal.leadId);
    }
  } else {
    // Fallback: no explicit id on the deal. Attempt to match by name.
    // Some older records might not store clientId/leadId, so remove them
    // based on the name if possible. This ensures the delete button
    // always does something visible even for legacy data.
    // Remove matching client onboarding if found
    const cid = Object.keys(state.clients).find(id => state.clients[id]?.name === deal.name);
    if(cid){
      const c = state.clients[cid];
      c._deletedOnboard = c.onboard;
      c._deletedPrice   = c.price;
      c.onboard = '';
      c.price = 0;
      if(Array.isArray(state.wonLeads)){
        state.wonLeads = state.wonLeads.filter(w => w.clientId !== cid);
      }
    }
    // Remove matching won leads by name
    if(Array.isArray(state.wonLeads)){
      state.wonLeads = state.wonLeads.filter(w => {
        if(w.name === deal.name){
          return false;
        }
        return true;
      });
    }
  }
  save();
  // Re-render to update revenue charts and lists. Draw both the total
  // and personal revenue charts explicitly to ensure they refresh.
  if(typeof drawRevenue === 'function') try{ drawRevenue(); }catch(e){}
  if(typeof drawPersonRevenue === 'function') try{ drawPersonRevenue(); }catch(e){}
  if(typeof render === 'function') try{ render(); }catch(e){}
}

// Construct a deliverable card element. The returned element contains
// front and back sides that can be flipped by clicking the Flip
// button. The front includes fields for idea, script and example URL,
// while the back shows a preview of the finished post, upload
// controls and a final caption. The optional actions object can
// provide onSchedule(draft) and onDelete(draft) callbacks which are
// invoked when the user clicks the +Calendar or trash buttons. This
// helper is reused by the Content tab and by filming/photo capture
// popups to ensure a consistent appearance.
function createDeliverableCard(client, type, draft, actions={}){
  // Build a flexible deliverable card with flip and optional film/send
  // actions. The front side contains idea, script, example URL and
  // caption. The back side shows a preview with media upload and final
  // caption along with a schedule button. Buttons call callbacks in
  // the actions object when provided.
  const card = document.createElement('div');
  card.className = 'card deliverable';
  card.style.position = 'relative';
  // Fix the flex sizing of deliverable cards. When there are fewer
  // cards than will fit in a row, the browser will stretch them to
  // fill available space. Explicitly set flex to 0 0 300px so each card
  // retains its intended width without stretching.
  card.style.flex = '0 0 300px';
  const inner = document.createElement('div');
  inner.className = 'inner';
  const front = document.createElement('div');
  front.className = 'front';
  const back = document.createElement('div');
  back.className = 'back';
  // Trash button
  const trash = document.createElement('button');
  trash.className = 'trash-btn';
  trash.innerHTML = '&#128465;';
  trash.onclick = (e)=>{
    e.stopPropagation();
    if(actions.onDelete){ actions.onDelete(draft); }
  };
  card.appendChild(trash);
  // Build the front and back faces based on the deliverable type. For
  // social posts (video/photo/carousel) we collect an idea, script and
  // example URL on the front, then show a post-style preview on the
  // back with a media upload and final caption. For email campaigns we
  // collect the offer, email body and a link on the front, then show
  // a simplified email preview on the back with an image, headline and
  // final email text. The buttons remain consistent across types but
  // may be hidden later depending on the context (e.g. email drafts
  // aren’t sent to filming).
  const typeLabel = type.charAt(0).toUpperCase() + type.slice(1);
  if(type === 'email'){
    // Email campaign front: offer, email text and link
    front.innerHTML = `
      <div class="small"><b>${typeLabel} Campaign</b></div>
      <label>Offer
        <textarea class="input" data-field="offer">${draft.offer||''}</textarea>
      </label>
      <label>Email Campaign Text
        <textarea class="input" data-field="emailText">${draft.emailText||''}</textarea>
      </label>
      <label>Mailchimp/SpotHopper Link
        <input class="input" data-field="link" value="${draft.link||''}" />
      </label>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <div class="hstack" style="gap:6px">
          <button class="btn small secondary" data-action="flip">Flip</button>
          <button class="btn small" data-action="film">Send to filming</button>
        </div>
        <span class="small">${draft.used ? 'Scheduled' : 'Draft'}</span>
      </div>
    `;
    // Email campaign back: preview and final fields. Use the final
    // headline/body when present; otherwise fall back to the draft.
    const avatar = client.avatar || '';
    const handle = client.handle || client.name.replace(/\s+/g,'').toLowerCase();
    const imgHtml = draft.finalImage ? `<img src="${draft.finalImage}" style="width:100%;height:auto;border-radius:8px"/>` : '<div class="placeholder">No image</div>';
    const headline = draft.finalOffer || draft.offer || '';
    const body = draft.finalEmailText || draft.emailText || '';
    back.innerHTML = `
      <div class="post">
        <div class="post-header">
          <div class="avatar" style="background-image:url('${avatar}');"></div>
          <div class="meta">
            <div class="name">${client.name}</div>
            <div class="handle">@${handle}</div>
          </div>
        </div>
        ${imgHtml}
        <div style="font-weight:700;font-size:15px;margin:10px 8px 0">${headline || 'Set #1 • Email Campaign'}</div>
        <div class="post-caption" style="white-space:pre-wrap">${body}</div>
      </div>
      <label style="margin-top:6px">Upload mockup image
        <input type="file" class="input" data-field="finalImage" accept="image/*" />
      </label>
      <label style="margin-top:6px">Final offer/headline
        <input class="input" data-field="finalOffer" value="${draft.finalOffer||''}" />
      </label>
      <label style="margin-top:6px">Final email text
        <textarea class="input" data-field="finalEmailText">${draft.finalEmailText||''}</textarea>
      </label>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <button class="btn small secondary" data-action="flip">Back</button>
        <button class="btn small" data-action="schedule">+ Calendar</button>
      </div>
    `;
  } else {
    // Social posts front: idea, script and example URL
    front.innerHTML = `
      <div class="small"><b>${typeLabel}</b></div>
      <label>Idea
        <textarea class="input" data-field="idea">${draft.idea||''}</textarea>
      </label>
      <label>Script
        <textarea class="input" data-field="script">${draft.script||''}</textarea>
      </label>
      <label>Example URL
        <input class="input" data-field="example" value="${draft.example||''}" />
      </label>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <div class="hstack" style="gap:6px">
          <button class="btn small secondary" data-action="flip">Flip</button>
          <button class="btn small" data-action="film">Send to filming</button>
        </div>
        <span class="small">${draft.used ? 'Scheduled' : 'Draft'}</span>
      </div>
    `;
    // Social posts back: preview of video/photo/carousel with final caption
    const avatar = client.avatar || '';
    const handle = client.handle || client.name.replace(/\s+/g,'').toLowerCase();
    const mediaHtml = draft.finalVideo ? `<video src="${draft.finalVideo}" controls style="width:100%;height:auto"></video>` : '<div class="placeholder">No media</div>';
    back.innerHTML = `
      <div class="post">
        <div class="post-header">
          <div class="avatar" style="background-image:url('${avatar}');"></div>
          <div class="meta">
            <div class="name">${client.name}</div>
            <div class="handle">@${handle}</div>
          </div>
        </div>
        <div class="post-media">${mediaHtml}</div>
        <div class="post-caption"><b>${client.name}</b> ${draft.finalCaption || draft.caption || ''}</div>
      </div>
      <label style="margin-top:6px">Upload media
        <input type="file" class="input" data-field="finalVideo" accept="video/*,image/*" />
      </label>
      <label style="margin-top:6px">Final caption
        <textarea class="input" data-field="finalCaption">${draft.finalCaption||''}</textarea>
      </label>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <button class="btn small secondary" data-action="flip">Back</button>
        <button class="btn small" data-action="schedule">+ Calendar</button>
      </div>
    `;
  }
  inner.appendChild(front);
  inner.appendChild(back);
  card.appendChild(inner);
  // Update draft fields on input
  card.querySelectorAll('textarea.input, input.input:not([type="file"])').forEach(inp=>{
    inp.oninput = ()=>{
      const f = inp.dataset.field;
      draft[f] = inp.value;
      save();
    };
  });
  // File upload for media or email images. Assign the result to the
  // appropriate draft field specified by the data-field attribute. This
  // allows email campaigns to save their preview image to
  // `finalImage`, and social posts to save video or image to
  // `finalVideo`.
  card.querySelectorAll('input[type="file"][data-field]').forEach(inp=>{
    inp.onchange = ()=>{
      const file = inp.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = (e)=>{
          const f = inp.dataset.field;
          draft[f] = e.target.result;
          save();
        };
        reader.readAsDataURL(file);
      }
    };
  });
  // Flip
  card.querySelectorAll('button[data-action="flip"]').forEach(btn=>{
    btn.onclick = (e)=>{
      e.stopPropagation();
      card.classList.toggle('flipped');
    };
  });
  // Film button
  const filmBtn = card.querySelector('button[data-action="film"]');
  if(filmBtn){
    filmBtn.onclick = (e)=>{
      e.stopPropagation();
      if(actions.onFilm){ actions.onFilm(draft); }
    };
    // Adjust the film button styling to improve contrast. Use the client's
    // colour as the background when available; otherwise fall back to
    // the brand colour. Set the text to a dark hue so it is legible on
    // coloured backgrounds.
    const fallbackBg = getComputedStyle(document.documentElement).getPropertyValue('--brand') || '#3b82f6';
    if(client && client.color){
      filmBtn.style.background = client.color;
    } else {
      filmBtn.style.background = fallbackBg;
    }
    filmBtn.style.color = '#0f1115';
  }
  // Schedule button
  const schedBtn = card.querySelector('button[data-action="schedule"]');
  if(schedBtn){
    schedBtn.onclick = (e)=>{
      e.stopPropagation();
      if(actions.onSchedule){ actions.onSchedule(draft); }
    };
  }

  // When a client is logged in, hide editing controls and disable inputs.
  // Clients can view their deliverables but cannot modify or schedule them.
  if(typeof isClient === 'function' && isClient()){
    // Hide the trash/delete button
    trash.style.display = 'none';
    // Hide the film (send to filming) button on the front side
    if(filmBtn){ filmBtn.style.display = 'none'; }
    // Hide the schedule (+ Calendar) button on the back side
    if(schedBtn){ schedBtn.style.display = 'none'; }
    // Disable all input and textarea fields so content is read‑only
    card.querySelectorAll('textarea.input, input.input, input[type="file"][data-field]').forEach(inp=>{
      inp.setAttribute('disabled', 'disabled');
    });
  }
  return card;
}

// Create repeated copies of a task according to a simple recurrence rule.
// repeat can be 'daily', 'weekly' or 'monthly'. This function
// schedules a handful of future occurrences (up to 6) using the same
// start time and duration. It respects the client's schedule by
// calling placeTask() on each occurrence and pushes the tasks into
// state.tasks. Recurring tasks are given new IDs.
function scheduleRecurringTasks(baseTask, repeat){
  const startDate = baseTask.date;
  const maxOccurrences = 6;
  for(let i=1; i<=maxOccurrences; i++){
    let nextDate;
    if(repeat === 'daily'){
      nextDate = fmtDate(addDays(startDate, i));
    } else if(repeat === 'weekly'){
      nextDate = fmtDate(addDays(startDate, 7*i));
    } else if(repeat === 'monthly'){
      // approximate months as 28 days for simplicity
      nextDate = fmtDate(addDays(startDate, 28*i));
    } else {
      continue;
    }
    const t = {...baseTask};
    t.id = uid();
    t.date = nextDate;
    placeTask(t.date, t);
    state.tasks.push(t);
  }
}

// Schedule all project tasks for a client across the requested number of
// months. This helper ensures every task is created and added to
// `state.tasks` so they appear on the calendar. It no longer skips
// phases when duplicates exist; instead it always appends tasks for
// each month. The assignment to employees is handled via
// `placeTask()`, which finds an available worker based on skills and
// capacity. After scheduling, the state is saved.
function scheduleClientMonths(client, startMonthIndex=0, months=null){
  const meta = PKG_META[client.package||"none"] || {months:0, scriptHrs:0, filmHrs:0, photoHrs:0, influencers:0};
  // Determine how many months of work to schedule. When `months` is
  // null/undefined we use the package baseline (`meta.months`). An explicit
  // value of 0 means no additional months beyond the baseline. See payment
  // scheduling logic for details.
  const monthsCount = (months == null) ? meta.months : months;
  // If there is nothing to schedule and no addons, exit early
  if(monthsCount<=0 && !client.addons?.website && !client.addons?.email && !client.addons?.phone) return;
  const baseStart = client.onboard || todayStr();
  const cId = client.id;
  // Loop from the requested start month index up to the number of months to schedule.
  for(let m=startMonthIndex; m<startMonthIndex + monthsCount; m++){
    // Each phase spans 28 days from the onboarding date. Compute the
    // absolute start date for this phase.
    const phaseStart = addDays(baseStart, 28*m);
    // Kickoff and logins are only scheduled in the first month
    if(m===0){
      // Kickoff call: schedule once on the onboard date. Notes include
      // collecting logins, scheduling calls and sending texts. Assign
      // only to the owner (client onboarding is handled by the owner).
      (()=>{
        const notes = "Kickoff call: review package, sign contracts, collect logins (call & text)";
        const t = makeTask(cId, "Kickoff", phaseStart, client.start||"09:00", state.durations.kickoff, "N", {meta:{phase:m}, notes});
        // Force assign to owner for kickoff
        t.assigneeId = "u-OWNER";
        placeTask(phaseStart, t);
        state.tasks.push(t);
      })();
    }
    // Offsets for tasks relative to phase start. We schedule work in a
    // realistic order: two weeks of scripting, then filming and photo
    // capture, followed by editing. Influencer confirmation and
    // shoots happen around the filming period. Delivery occurs near
    // the end of the month.
    const twoWeeks = 14;
    // Scripting: distribute hours starting 2 days after phase start
    if(meta.scriptHrs>0){
      let remaining = meta.scriptHrs;
      let d = addDays(phaseStart, 2);
      while(remaining>0){
        const chunk = Math.min(4, remaining);
        const t = makeTask(cId, "Scripting", d, "09:00", chunk, "S", {meta:{phase:m}});
        placeTask(d, t);
        state.tasks.push(t);
        remaining -= chunk;
        d = addDays(d,1);
      }
    }
    // Photo capture: scheduled two weeks into the phase
    if(meta.photoHrs>0){
      const d = addDays(phaseStart, twoWeeks);
      const t = makeTask(cId, "Photo capture", d, "09:00", meta.photoHrs, "P", {meta:{phase:m}});
      placeTask(d, t);
      state.tasks.push(t);
    }
    // Filming: start two weeks into the phase; separate by a day between chunks
    if(meta.filmHrs>0){
      let remaining = meta.filmHrs;
      let d = addDays(phaseStart, twoWeeks);
      while(remaining>0){
        const chunk = Math.min(8, remaining);
        const t = makeTask(cId, "Filming", d, "09:00", chunk, "F", {meta:{phase:m}});
        placeTask(d, t);
        state.tasks.push(t);
        remaining -= chunk;
        // separate filming days by one day
        d = addDays(d,2);
      }
    }
    // Editing: start roughly 6 days after filming begins (20 days after phase start). Estimate hours
    if(meta.filmHrs>0){
      let editHrs = Math.round((meta.filmHrs/4) * state.durations.editingPer4);
      editHrs = Math.max(4, editHrs);
      let remaining = editHrs;
      let d = addDays(phaseStart, twoWeeks + 6);
      while(remaining>0){
        const chunk = Math.min(4, remaining);
        const t = makeTask(cId, "Editing", d, "09:00", chunk, "E", {meta:{phase:m}});
        placeTask(d, t);
        state.tasks.push(t);
        remaining -= chunk;
        d = addDays(d,1);
      }
    }
    // Delivery/Posting: one day after the end of the month
    if(meta.months>0){
      const postDay = addDays(phaseStart, 28 + 1);
      const t = makeTask(cId, "Delivery / Posting", postDay, "09:00", state.durations.posting, "N", {meta:{phase:m}});
      placeTask(postDay, t);
      state.tasks.push(t);
    }
    // Influencer tasks: find early, confirm and shoot later
    if(meta.influencers>0){
      // find at day 1
      const tFind = makeTask(cId, "Influencer – Find", addDays(phaseStart,1), "09:00", state.durations.influencerFind, "N", {meta:{phase:m}});
      placeTask(addDays(phaseStart,1), tFind);
      state.tasks.push(tFind);
      // confirm at two weeks
      const tConfirm = makeTask(cId, "Influencer – Confirm", addDays(phaseStart, twoWeeks), "09:00", state.durations.influencerConfirm, "N", {meta:{phase:m}});
      placeTask(addDays(phaseStart, twoWeeks), tConfirm);
      state.tasks.push(tConfirm);
      // schedule shoots starting two days after two weeks
      let shootDate = addDays(phaseStart, twoWeeks + 2);
      for(let i=0; i<meta.influencers; i++){
        const tShoot = makeTask(cId, `Influencer – Shoot ${i+1}`, shootDate, "09:00", state.durations.influencerShoot || 4, "F", {meta:{phase:m}});
        placeTask(shootDate, tShoot);
        state.tasks.push(tShoot);
        shootDate = addDays(shootDate, 1);
      }
    }
  }
  /*
   * Payment scheduling
   *
   * Explicitly create payment reminder tasks for this client. Payment
   * reminders occur on the onboarding date and every 14 days thereafter
   * for each contracted month of work. A package with one or more
   * months generates two half‑payments per month; a zero‑month package
   * generates a single lump‑sum payment on the onboarding date.
   */
  {
    // Determine the deal price. Use the client-specific price if set,
    // otherwise fall back to the default package price. If no price
    // exists, skip payment scheduling entirely.
    let price = Number(client.price);
    if(!price){ price = (state.prices && state.prices[client.package]) || 0; }
    if(price > 0){
      // Determine how many months to schedule payments for. When `months` is
      // null/undefined we use the package baseline; an explicit numeric
      // value (including 0) schedules that many months. We cap the
      // schedule at the baseline package months so that extra months
      // beyond the contract do not generate payments.
      // Determine how many months to schedule payments for. When the
      // caller provides `months` (via auto‑scheduling) we schedule that
      // many additional months starting at `startMonthIndex`. When
      // `months` is null/undefined (baseline schedule) we schedule the
      // package's baseline month count. In both cases, we do NOT limit
      // scheduling by the baseline contract months. This allows
      // additional months to generate payments. Packages with zero
      // baseline months (e.g. website) will fall into the lump‑sum case
      // below.
      const baselineMonths = meta.months || 0;
      // Determine how many months of payments to create.  When
      // months is null/undefined we schedule the package baseline. If
      // months is zero and this is the first phase (startMonthIndex
      // === 0), we still need to schedule the baseline months.
      let monthsToSchedule;
      if(months == null){
        monthsToSchedule = baselineMonths;
      } else if(months === 0 && startMonthIndex === 0){
        monthsToSchedule = baselineMonths;
      } else {
        monthsToSchedule = months;
      }
      // Helper to insert payment tasks only if none exist on that date
      function maybeAddPayment(dateStr, phaseIdx, amount){
        const exists = state.tasks.some(t => t.clientId === cId && t.name === 'Payment due' && t.date === dateStr);
        if(exists) return;
        const paymentTask = makeTask(
          cId,
          'Payment due',
          dateStr,
          '09:00',
          0.5,
          'L',
          { meta: { phase: phaseIdx, amount: amount, salespersonId: client.salespersonId || null } }
        );
        paymentTask.assigneeId = client.salespersonId || null;
        paymentTask.date = dateStr;
        state.tasks.push(paymentTask);
      }
      if(monthsToSchedule > 0){
        /*
         * Schedule bi‑weekly payments. Each package month corresponds
         * to two payments: one on the phase start (onboard + 28*m)
         * and one exactly 14 days later. We compute the overall
         * sequence of payments by multiplying the number of months
         * to schedule by two. The starting payment index is offset
         * when startMonthIndex > 0 so that additional months append
         * seamlessly after existing payments. Each payment uses
         * meta.phase to record its phase index (floor(paymentIndex/2)).
         */
        const half = price / 2;
        const totalPayments = monthsToSchedule * 2;
        const startPaymentIndex = startMonthIndex * 2;
        for(let i = 0; i < totalPayments; i++){
          const paymentIndex = startPaymentIndex + i;
          const paymentDate = addDays(baseStart, 14 * paymentIndex);
          const phaseIdx = Math.floor(paymentIndex / 2);
          maybeAddPayment(paymentDate, phaseIdx, half);
        }
      } else {
        // For packages with zero baseline months (e.g. website‑only),
        // create a single lump payment on the onboarding date. When
        // baselineMonths > 0 but months === 0, we deliberately
        // schedule zero additional payments and leave baseline
        // payments untouched (handled above). This avoids duplicate
        // lump sums when users choose “0 additional months”.
        if(baselineMonths <= 0){
          maybeAddPayment(baseStart, startMonthIndex, price);
        }
      }
    }
  }

  // Website add-on schedule: always schedule once when website is added
    if(client.addons?.website){
    const phaseStart = baseStart;
    // Check if not already scheduled for this client
    if(!state.tasks.some(t=>t.clientId===cId && t.meta?.phase==='web')){
      // Spread website work over roughly two weeks. Offsets are in days
      // relative to the onboarding date.
      const tasks = [
        {name:'Website Kickoff meeting', offset:0, dur:1, type:'N'},
        {name:'Website Contract', offset:0, dur:0.5, type:'N'},
        {name:'Website Plan content date', offset:2, dur:0.25, type:'N'},
        {name:'Website Content Capture', offset:4, dur:3, type:'P'},
        {name:'Website Build', offset:7, dur:8, type:'W'},
        {name:'Website Final Checks', offset:12, dur:1, type:'W'},
        {name:'Website Send to Owner', offset:13, dur:0.5, type:'N'}
      ];
      // Schedule website tasks sequentially on the same dates. We
      // compute start times per task so they don't overlap. Start at
      // 09:00 by default and add durations.
      tasks.forEach(item=>{
        const date = addDays(phaseStart, item.offset);
        // determine a start time based on existing website tasks on that day
        let startTime = '09:00';
        // find tasks for this client and phase on the same date
        const dayTasks = state.tasks.filter(tt=>tt.clientId===cId && tt.date===date && tt.meta?.phase==='web');
        if(dayTasks.length){
          // compute end of last task
          const last = dayTasks.reduce((a,b)=>{
            const t1 = parseFloat(a.start.split(':')[0]) + parseFloat(a.duration);
            const t2 = parseFloat(b.start.split(':')[0]) + parseFloat(b.duration);
            return t1>t2?a:b;
          });
          const lastEnd = parseFloat(last.start.split(':')[0]) + parseFloat(last.duration);
          const hrs = Math.floor(lastEnd);
          const mins = Math.round((lastEnd - hrs) * 60);
          startTime = String(hrs).padStart(2,'0') + ':' + String(mins).padStart(2,'0');
        }
        const t = makeTask(cId, item.name, date, startTime, item.dur, item.type, {meta:{phase:'web'}});
        placeTask(date, t);
        state.tasks.push(t);
      });
    }
  }
  // Email add-on schedule
  if(client.addons?.email){
    const phaseStart = baseStart;
    if(!state.tasks.some(t=>t.clientId===cId && t.meta?.phase==='email')){
      const tasks = [
        {name:'Email Setup', offset:2, dur:state.durations.emailSetup, type:'N'},
        {name:'Email Schedule', offset:6, dur:state.durations.emailSchedule, type:'N'},
        {name:'Email Report', offset:27, dur:state.durations.emailReport, type:'N'}
      ];
      tasks.forEach(item=>{
        const date = addDays(phaseStart, item.offset);
        const t = makeTask(cId, item.name, date, '09:00', item.dur, item.type, {meta:{phase:'email'}});
        placeTask(date, t);
        state.tasks.push(t);
      });
    }
  }
  // Phone add-on schedule
  if(client.addons?.phone){
    const phaseStart = baseStart;
    if(!state.tasks.some(t=>t.clientId===cId && t.meta?.phase==='phone')){
      const date = addDays(phaseStart, 2);
      const t = makeTask(cId, 'Phone Setup', date, '09:00', state.durations.phoneSetup, 'N', {meta:{phase:'phone'}});
      placeTask(date, t);
      state.tasks.push(t);
    }
  }
  save();
}

/*** UI building helpers ***/
function openModal(html, onMount){
  $("#modal").innerHTML = html;
  $("#modalBackdrop").style.display = "flex";
  onMount && onMount();
  // Allow closing the modal by clicking on the backdrop (outside the modal).
  const backdrop = document.getElementById('modalBackdrop');
  if(backdrop){
    // Clear any previous click handler to avoid stacking closures
    backdrop.onclick = (ev) => {
      if(ev.target === backdrop){
        closeModal();
      }
    };
  }
}
function closeModal(){
  $("#modalBackdrop").style.display = "none";
  // Remove backdrop click handler to prevent leaks when reopened.
  const backdrop = document.getElementById('modalBackdrop');
  if(backdrop){ backdrop.onclick = null; }
}

/*** OVERVIEW ***/
function renderOverview(){
  const cont = document.createElement("div");

  // Auto‑approve any scheduled content posts whose date has passed and that
  // have not yet been explicitly approved or rejected. This ensures
  // clients cannot block scheduled posts by never responding. Only
  // perform this check once per render and persist changes.
  try{
    const todayDate = parseDate(todayStr());
    let changed = false;
    Object.values(state.clients).forEach(cl => {
      if(cl.content){
        cl.content.forEach(p => {
          if(!('approved' in p)){
            const d = parseDate(p.date);
            if(d < todayDate){
              p.approved = true;
              changed = true;
            }
          }
        });
      }
    });
    if(changed) save(false);
  }catch(e){}

  // Insert an overdue tasks notice at the top of the overview when any tasks
  // across all clients are past due. Filter by the currently selected
  // assignee (Team, owner or a specific user) to respect the "view as"
  // setting. For team view or owner, show all overdue tasks.
  try{
    const today = parseDate(todayStr());
    const assignee = visibleAssigneeId();
    const cid = currentClientId();
    const overdueAll = state.tasks.filter(t => {
      if(parseDate(t.date) >= today) return false;
      // If viewing a specific assignee, only count tasks assigned to them or unassigned
      if(assignee && t.assigneeId !== assignee) return false;
      // If logged in as a client, only consider tasks belonging to that client
      if(cid && t.clientId !== cid) return false;
      return true;
    });
    if(overdueAll.length > 0){
      const note = document.createElement('div');
      note.className = 'card';
      note.style.background = 'rgba(255, 91, 91, 0.2)';
      note.style.border = '1px solid var(--danger)';
      note.style.color = 'var(--danger)';
      note.style.padding = '8px 12px';
      note.style.marginBottom = '12px';
      note.style.borderRadius = 'var(--radius)';
      const list = overdueAll.slice(0,5).map(t=>`${state.clients[t.clientId]?.name||''} • ${t.name} (${t.date})`).join(', ');
      const more = overdueAll.length > 5 ? ` and ${overdueAll.length-5} more` : '';
      note.innerHTML = `<strong>${overdueAll.length} overdue task${overdueAll.length!==1?'s':''}</strong>: ${list}${more}`;
      cont.appendChild(note);
    }
  } catch(e){}

  // Widgets
  const widgets = document.createElement("div");
  widgets.className = "grid3";
  // Clients this week
  const clientsThisWeek = (()=>{
    const now = new Date();
    const start = fmtDate(new Date(now.getFullYear(), now.getMonth(), now.getDate()));
    const end = fmtDate(new Date(now.getFullYear(), now.getMonth(), now.getDate()+7));
    // For clients, only show their own entry in the list. For staff, show all clients.
    let list = Object.values(state.clients);
    const cid = currentClientId();
    if(cid){
      const c = state.clients[cid];
      list = c ? [c] : [];
    }
    const items = list.map(c=>{
      const startDate = parseDate(c.onboard);
      const today = new Date();
      const daysSince = Math.floor((today - startDate)/86400000);
      const rem = daysSince % 28;
      const left = 28 - rem;
      return {name:c.name, nextIn:left};
    });
    return items.length ? items.map(it=>`<div class="row"><div class="chip" style="background:#18203a">${it.name}</div><div class="small">${it.nextIn}d left</div></div>`).join("")
                        : `<div class="small">No clients</div>`;
  })();
    const weeklyList = (()=>{
    const now = new Date();
    const start = fmtDate(new Date(now.getFullYear(), now.getMonth(), now.getDate()));
    const end = fmtDate(new Date(now.getFullYear(), now.getMonth(), now.getDate()+7));
    // When logged in as a client, restrict weekly tasks to that client. Use the
    // assignee filter to respect the current view setting. If cid is null, show all clients.
    const wTasks = weeklyTasks(start, end, visibleAssigneeId()).filter(t => {
      const cid2 = currentClientId();
      return !cid2 || t.clientId === cid2;
    });
    return wTasks.length ? wTasks.map(t=>{
      return `<div class="task" onclick="handleTaskRowClick(event,'${t.id}')">
        <div class="dot" style="background:${clientColor(t.clientId)}"></div>
        <div class="name">${state.clients[t.clientId]?.name} • ${t.name}</div>
        <div class="meta">${t.date}</div>
        <div class="assignee">${state.users[t.assigneeId]?.name||"Unassigned"}</div>
        <div class="actions">
          <div class="iconbtn ok" title="Done" onclick="archiveTask('${t.id}')">✓</div>
          <div class="iconbtn" title="More" onclick="showTaskMenu(event,'${t.id}')">…</div>
        </div>
      </div>`;
    }).join("") : `<div class="small">No tasks</div>`;
  })();
    const todayList = (()=>{
    const cid2 = currentClientId();
    const list = tasksOnDate(todayStr(), cid2, visibleAssigneeId());
    return list.length ? list.map(t=>{
      return `<div class="task" onclick="handleTaskRowClick(event,'${t.id}')">
        <div class="dot" style="background:${clientColor(t.clientId)}"></div>
        <div class="name">${state.clients[t.clientId]?.name} • ${t.name}</div>
        <div class="meta">~${t.duration}h</div>
        <div class="actions">
          <div class="iconbtn ok" title="Done" onclick="archiveTask('${t.id}')">✓</div>
          <div class="iconbtn" title="More" onclick="showTaskMenu(event,'${t.id}')">…</div>
        </div>
      </div>`;
    }).join("") : `<div class="small">No tasks</div>`;
  })();

  widgets.innerHTML = `
    <div class="card"><h3>Clients this week</h3>${clientsThisWeek}</div>
    <div class="card"><h3>Weekly tasks</h3><div class="list">${weeklyList}</div></div>
    <div class="card"><h3>Today</h3><div class="list">${todayList}</div></div>
  `;
  cont.appendChild(widgets);

  // If a client is logged in, provide a Work/Content toggle for the
  // overview calendar. This allows clients to switch between their
  // production tasks and scheduled social media posts just like on the
  // individual client page. The selection is persisted in the
  // global clientViewModes object keyed by client id.
  const ovClientId = currentClientId();
  let ovMode = 'work';
  if(ovClientId){
    ovMode = clientViewModes[ovClientId] || 'work';
    const toggleRow = document.createElement('div');
    toggleRow.className = 'row';
    toggleRow.style.justifyContent = 'center';
    toggleRow.style.marginBottom = '8px';
    toggleRow.innerHTML = `
      <div class="chips" id="overviewCalMode">
        <div class="chip ${ovMode==='work'?'active':''}" data-mode="work" onclick="switchOverviewMode('work')">Work</div>
        <div class="chip ${ovMode==='content'?'active':''}" data-mode="content" onclick="switchOverviewMode('content')">Content</div>
      </div>
    `;
    cont.appendChild(toggleRow);
  }

  // Calendar (current month only)
  const cal = document.createElement("div");
  cal.className="calendar";
  // Initialise the overview calendar based on the override date. When
  // state.todayOverride is set via Settings, parseDate(todayStr())
  // returns a Date object representing that override; otherwise it
  // falls back to the current system date. Using this value
  // consistently ensures the highlighted day and month navigation
  // align with the user's selected date.
  const now = parseDate(todayStr());
  let viewYear = now.getFullYear();
  let viewMonth = now.getMonth();
  // Build a calendar skeleton with a days‑of‑week header. The header
  // shows Sun–Sat across seven columns before the month grid so users can
  // orient themselves easily.
  cal.innerHTML = `
    <div class="cal-header">
      <div class="hstack">
        <div class="title" id="calTitle">${MONTHS[viewMonth]} ${viewYear}</div>
      </div>
      <div class="hstack">
        <button class="btn small ghost" id="prevM">‹</button>
        <button class="btn small ghost" id="nextM">›</button>
      </div>
    </div>
    <div class="cal-days">${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].map(d=>`<div>${d}</div>`).join('')}</div>
    <div class="cal-grid" id="calGrid"></div>
  `;
  cont.appendChild(cal);

  function draw(){
    const grid = $("#calGrid", cal);
    grid.innerHTML = "";
    const days = monthMatrix(viewYear, viewMonth);
    days.forEach(d=>{
      const dateStr = fmtDate(d);
      const cell = document.createElement("div");
      cell.className = "cal-cell";
      // Highlight today based on the user‑defined date override. Use
      // todayStr() instead of the system date to respect any
      // overrides set in Settings. Without this change the calendar
      // always highlights the actual current date, ignoring the
      // override and causing an off‑by‑one highlight when the
      // timezone or override differs.
      if(todayStr()===dateStr) cell.classList.add("today");
      // show only this month
      if(d.getMonth()!==viewMonth){
        cell.style.visibility="hidden";
      }
      cell.dataset.date = dateStr;
      cell.innerHTML = `<div class="d">${d.getDate()}</div>`;

      // Determine current mode for clients (work vs content). For
      // employees and owners, mode is always work. When in content
      // mode, show scheduled content posts instead of production tasks.
      const cid2 = currentClientId();
      const mode = cid2 ? (clientViewModes[cid2] || 'work') : 'work';
      if(cid2 && mode === 'content'){
        // Build content post cards for this date
        const posts = (state.clients[cid2]?.content) || [];
        const postsForDay = posts.filter(p => p.date === dateStr);
        postsForDay.forEach(p => {
          const div = document.createElement('div');
          div.className = 'task';
          div.draggable = false;
          div.innerHTML = `<div class="dot" style="background:${clientColor(cid2)}"></div>
            <div class="name">${state.clients[cid2]?.name} • ${p.title || p.type.charAt(0).toUpperCase()+p.type.slice(1)}</div>
            <div class="meta">${p.type}</div>`;
          // Clicking a content post opens a preview modal for approval. Use
          // viewContentPost to display the final deliverable and approve/reject.
          div.onclick = (ev) => {
            ev.stopPropagation();
            viewContentPost(cid2, p);
          };
          cell.appendChild(div);
        });
      } else {
        // Show work/production tasks. Pass cid2 to restrict tasks to the
        // client when logged in as a client. Otherwise pass null to
        // include all clients.
        const dayTasks = tasksOnDate(dateStr, cid2 || null, visibleAssigneeId());
        dayTasks.forEach(t=>{
          const div = document.createElement("div");
          div.className="task";
          div.draggable=true;
          div.ondragstart=(ev)=>{ ev.dataTransfer.setData("text/plain", t.id); };
          div.innerHTML = `<div class="dot" style="background:${clientColor(t.clientId)}"></div>
            <div class="name">${state.clients[t.clientId]?.name} • ${t.name}</div>
            <div class="meta">${t.start} • ~${t.duration}h</div>
            <div class="assignee">${state.users[t.assigneeId]?.name||'Unassigned'}</div>
            <div class="actions"><div class="iconbtn ok" title="Done">✓</div><div class="iconbtn" title="More">…</div></div>`;
          // archive on checkmark
          $(".iconbtn.ok",div).onclick = () => archiveTask(t.id);
          // options menu on ellipsis
          const icons = div.querySelectorAll('.iconbtn');
          if(icons[1]){
            icons[1].onclick = (ev) => showTaskMenu(ev, t.id);
          }
        // clicking the main body of a task opens the appropriate popup.  If the
        // user clicks on an action icon (done/more) then do not intercept.
        // Previously influencer tasks only triggered a popup for "confirm" or
        // "shoot"; broaden the check so any task containing "influencer"
        // opens the influencer form (e.g. "Influencer – Find").
        div.onclick = (ev) => {
            if(ev.target.closest('.iconbtn')) return;
            const name = (t.name||'').toLowerCase();
            if(name.includes('influencer')){
              viewInfluencerTask(t.id);
            } else if(name.includes('film')){
              viewFilmingCards(t.id);
            } else if(name.includes('photo')){
              viewPhotoCards(t.id);
            } else if(name.includes('script')){
              viewScriptingCards(t.id);
            } else if(name.includes('edit')){
              viewEditingCards(t.id);
            } else if(name.includes('email')){
              viewEmailCards(t.id);
            }
          };
          cell.appendChild(div);
        });
      }

      cell.ondragover=(e)=>e.preventDefault();
      cell.ondrop=(e)=>{
        const id = e.dataTransfer.getData("text/plain");
        const t = state.tasks.find(x=>x.id===id); if(!t) return;
        t.date = cell.dataset.date;
        placeTask(t.date, t); // re-balance capacity/assignee if needed
        save(); draw();
      };
      grid.appendChild(cell);
    });
  }
  draw();
  // When a client is logged in, allow switching between work and content
  // modes by clicking the chips. Update the global clientViewModes and
  // re‑render the dashboard. Use the same client id used when building
  // the toggle earlier.
  if(ovClientId){
    const chipContainer = $("#overviewCalMode");
    if(chipContainer){
      chipContainer.onclick = (e)=>{
        const m = e.target.closest('.chip')?.dataset.mode;
        if(m && clientViewModes[ovClientId] !== m){
          clientViewModes[ovClientId] = m;
          save();
          render();
        }
      };
    }
  }
  $("#prevM", cal).onclick = ()=>{ viewMonth--; if(viewMonth<0){viewMonth=11;viewYear--;} $("#calTitle", cal).textContent = `${MONTHS[viewMonth]} ${viewYear}`; draw(); };
  $("#nextM", cal).onclick = ()=>{ viewMonth++; if(viewMonth>11){viewMonth=0;viewYear++;} $("#calTitle", cal).textContent = `${MONTHS[viewMonth]} ${viewYear}`; draw(); };

  $("#screen").innerHTML = "";
  $("#screen").appendChild(cont);
}

/*** edit task modal ***/
function editTask(id){
  const t = deepClone(state.tasks.find(x=>x.id===id));
  if(!t) return;
  const client = state.clients[t.clientId];
  openModal(`
    <h3>Edit task</h3>
    <div class="row"><div class="kv"><div class="k">Client</div><div>${client?.name||''}</div></div></div>
    <div class="row"><div class="kv"><div class="k">Name</div><input id="tName" type="text" value="${t.name}"/></div></div>
    <div class="row"><div class="kv"><div class="k">Date</div><input id="tDate" type="date" value="${t.date}"/></div><div class="kv"><div class="k">Start</div><input id="tStart" type="time" value="${t.start||'09:00'}"/></div><div class="kv"><div class="k">Duration (h)</div><input id="tDur" type="number" step="0.25" placeholder="Duration (h)" value="${t.duration||''}"/></div></div>
    <div class="row"><div class="kv"><div class="k">Notes</div><textarea id="tNotes" placeholder="Description or notes...">${t.notes||''}</textarea></div></div>
    <div class="row"><div class="kv"><div class="k">Assignee</div><select id="tWho">${Object.values(state.users).map(u=>`<option value="${u.id}" ${u.id===t.assigneeId?'selected':''}>${u.name}</option>`).join("")}</select></div></div>
    <div class="row right"><button class="btn secondary" id="cancel">Cancel</button><button class="btn" id="saveT">Save</button></div>
  `, ()=>{
    $("#cancel").onclick=closeModal;
    $("#saveT").onclick=()=>{
      const real = state.tasks.find(x=>x.id===id);
      real.name=$("#tName").value;
      real.date=$("#tDate").value;
      real.start=$("#tStart").value;
      real.duration=Number($("#tDur").value);
      real.assigneeId=$("#tWho").value;
      real.notes = $("#tNotes").value;
      save(); closeModal(); render();
    };
  });
}

// Assign a task to a different employee. Opens a simple modal with a
// select listing all non-sales users. On save, updates the task's
// assigneeId and re-renders the dashboard.
function assignTask(taskId){
  const t = state.tasks.find(x=>x.id===taskId);
  if(!t) return;
  const options = Object.values(state.users)
    .filter(u=>u.role!=='sales')
    .map(u=>`<option value="${u.id}" ${u.id===t.assigneeId?'selected':''}>${u.name}</option>`).join('');
  openModal(`
    <h3>Assign task</h3>
    <div class="row wrap"><label style="flex:1;min-width:140px">Assignee
      <select id="assignSelect">${options}</select>
    </label></div>
    <div class="row right" style="margin-top:12px">
      <button class="btn secondary" id="aCancel">Cancel</button>
      <button class="btn" id="aSave">Assign</button>
    </div>
  `, ()=>{
    $("#aCancel").onclick = closeModal;
    $("#aSave").onclick = ()=>{
      const val = $("#assignSelect").value;
      t.assigneeId = val;
      save(); closeModal(); render();
    };
  });
}

// Display all deliverables attached to a filming task. Opens a modal
// listing each draft assigned to this filming task. Allows the user
// to push individual drafts to the content calendar. Draft details
// (idea, script, example) are displayed read‑only for reference. When
// pushing a draft, it is marked used and removed from the task's
// meta.cards array. The view re-renders after closing.
function viewFilmingCards(taskId){
  const t = state.tasks.find(x=>x.id===taskId);
  // Only handle filming tasks here. Photo capture tasks are handled by
  // viewPhotoCards. Use a case‑insensitive check so names like
  // "Filming Day 2" are recognised. If no deliverables are attached,
  // notify the user.
  if(!t || !/filming/i.test(t.name) || !t.meta || !t.meta.cards || !t.meta.cards.length){
    alert('No deliverables attached to this production task. Use "Send to filming" on a draft first.');
    return;
  }
  const client = state.clients[t.clientId];
  // Build card container
  const frag = document.createElement('div');
  frag.style.display = 'flex';
  frag.style.flexWrap = 'wrap';
  frag.style.gap = '20px';
  frag.style.alignItems = 'start';
  t.meta.cards.forEach(info => {
    const drafts = client.drafts && client.drafts[info.type] ? client.drafts[info.type] : [];
    const draft = drafts.find(d => d.id === info.id);
    if(!draft) return;
    // Provide actions to allow scheduling and deletion
    const actions = {
      onDelete: (d) => {
        // Unschedule this draft from the production task but keep it in
        // the client's drafts. Do not delete the draft entirely.
        d.scheduledToFilm = false;
        if(t.meta && Array.isArray(t.meta.cards)){
          t.meta.cards = t.meta.cards.filter(c => c.id !== d.id);
        }
        save();
        // remove card visually
        if(window.cardMap){
          const el = cardMap.get(d.id);
          if(el) el.remove();
        }
      },
      onSchedule: (d) => {
        // Post to calendar and then unschedule from production.
        assignDraftToCalendar(client, info.type, d);
        d.used = true;
        d.scheduledToFilm = false;
        if(t.meta && Array.isArray(t.meta.cards)){
          t.meta.cards = t.meta.cards.filter(c => c.id !== d.id);
        }
        save();
        // remove card visually
        if(window.cardMap){
          const el = cardMap.get(d.id);
          if(el) el.remove();
        }
      },
      // disable filming button in production view
      onFilm: null
    };
    const card = createDeliverableCard(client, info.type, draft, actions);
    // Hide the film button since we are already in production
    const filmBtn = card.querySelector('button[data-action="film"]');
    if(filmBtn){ filmBtn.style.display = 'none'; }
    // Keep a map from draft id to element for removal
    if(!window.cardMap) window.cardMap = new Map();
    window.cardMap.set(draft.id, card);
    frag.appendChild(card);
  });
  openModal(`
    <h3>${t.name} deliverables</h3>
    <div id="fcCards" style="max-height:70vh; overflow-y:auto; overflow-x:visible"></div>
    <div class="row right" style="margin-top:12px"><button class="btn secondary" id="fcClose">Close</button></div>
  `, () => {
    const modal = document.getElementById('modal');
    if(modal){
      modal.style.maxWidth = '90vw';
    }
    const container = document.getElementById('fcCards');
    if(container){
      container.appendChild(frag);
    }
    document.getElementById('fcClose').onclick = closeModal;
  });
}

// Display deliverables for photo capture tasks. Shows two tabs
// (Photos and Carousels) so the user can switch between types. Allows
// unscheduling drafts from the task or scheduling them to the content
// calendar. Drafts remain in the client's library when removed from
// the production task.
function viewPhotoCards(taskId){
  const t = state.tasks.find(x=>x.id===taskId);
  if(!t || !/photo/i.test(t.name) || !t.meta || !t.meta.cards || !t.meta.cards.length){
    alert('No deliverables attached to this production task. Use "Send to filming" on a draft first.');
    return;
  }
  const client = state.clients[t.clientId];
  let currentFilter = 'photo';
  // Build header with toggles
  openModal(`
    <h3>${t.name} deliverables</h3>
    <div class="tabs" id="photoTabs">
      <div class="tab active" data-filter="photo">Photos</div>
      <div class="tab" data-filter="carousel">Carousels</div>
    </div>
    <div id="pcCards" style="max-height:70vh; overflow-y:auto; overflow-x:visible; display:flex; flex-wrap:wrap; gap:20px; align-items:start"></div>
    <div class="row right" style="margin-top:12px"><button class="btn secondary" id="pcClose">Close</button></div>
  `, () => {
    const modal = document.getElementById('modal');
    if(modal){ modal.style.maxWidth = '90vw'; }
    const tabs = document.getElementById('photoTabs');
    const container = document.getElementById('pcCards');
    function renderCards(){
      container.innerHTML = '';
      if(!window.cardMap) window.cardMap = new Map();
      t.meta.cards.forEach(info => {
        if(info.type !== currentFilter) return;
        const drafts = (client.drafts && client.drafts[info.type]) ? client.drafts[info.type] : [];
        const draft = drafts.find(d => d.id === info.id);
        if(!draft) return;
        const actions = {
          onDelete: (d) => {
            d.scheduledToFilm = false;
            t.meta.cards = t.meta.cards.filter(c => c.id !== d.id);
            save();
            renderCards();
          },
          onSchedule: (d) => {
            assignDraftToCalendar(client, info.type, d);
            d.used = true;
            d.scheduledToFilm = false;
            t.meta.cards = t.meta.cards.filter(c => c.id !== d.id);
            save();
            renderCards();
          },
          onFilm: null
        };
        const card = createDeliverableCard(client, info.type, draft, actions);
        // hide film button (not relevant)
        const filmBtn = card.querySelector('button[data-action="film"]');
        if(filmBtn){ filmBtn.style.display = 'none'; }
        container.appendChild(card);
      });
    }
    renderCards();
    // tab click
    tabs.querySelectorAll('.tab').forEach(tab => {
      tab.onclick = () => {
        tabs.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        renderCards();
      };
    });
    document.getElementById('pcClose').onclick = closeModal;
  });
}

// Display deliverables for scripting tasks. Provide filters for videos,
// photos and carousels similar to the editing view. Allows drafts to be
// unscheduled from the task or scheduled to the content calendar.
function viewScriptingCards(taskId){
  // Show all drafts for the client when scripting a task. In the original
  // implementation only drafts that were already scheduled to filming
  // (stored in t.meta.cards) were displayed. This prevented writers
  // from scripting deliverables that had not yet been sent to film. The
  // updated version lists every draft of the selected type, regardless
  // of whether it is scheduled to a production task. Writers can send
  // drafts to filming, schedule them to the calendar, or delete them
  // directly from this view.
  const t = state.tasks.find(x=>x.id===taskId);
  if(!t || !/script/i.test(t.name)){
    alert('Not a scripting task.');
    return;
  }
  const client = state.clients[t.clientId];
  if(!client){ alert('Client not found.'); return; }
  // Ensure drafts exist before showing the modal
  ensureDrafts(client);
  let currentFilter = 'video';
  openModal(`
    <h3>${t.name} deliverables</h3>
    <div class="tabs" id="scrTabs">
      <div class="tab active" data-filter="video">Videos</div>
      <div class="tab" data-filter="photo">Photos</div>
      <div class="tab" data-filter="carousel">Carousels</div>
    </div>
    <div id="scrCards" style="max-height:70vh; overflow-y:auto; overflow-x:visible; display:flex; flex-wrap:wrap; gap:20px; align-items:start"></div>
    <div class="row right" style="margin-top:12px"><button class="btn secondary" id="scrClose">Close</button></div>
  `, () => {
    const modal = document.getElementById('modal');
    if(modal){ modal.style.maxWidth = '90vw'; }
    const tabs = document.getElementById('scrTabs');
    const container = document.getElementById('scrCards');
    function renderCards(){
      container.innerHTML = '';
      // Build a list of drafts for the current filter type. Always show
      // every draft, regardless of whether it has been scheduled to a
      // production task. Writers need access to unscheduled drafts in
      // order to write scripts.
      const drafts = (client.drafts && client.drafts[currentFilter]) ? client.drafts[currentFilter] : [];
      drafts.forEach(d => {
        const actions = {
          // Remove a draft from any associated production task and mark it
          // as unscheduled. Deleting does not remove the draft from the
          // drafts list; it simply clears its association with filming
          // tasks so it can be reassigned later.
          onDelete: (draft) => {
            // Clear scheduledToFilm flag
            draft.scheduledToFilm = false;
            // Remove from all task meta.cards arrays
            if(state.tasks){
              state.tasks.forEach(tsk => {
                if(tsk.meta && tsk.meta.cards){
                  tsk.meta.cards = tsk.meta.cards.filter(ci => ci.id !== draft.id);
                }
              });
            }
            save();
            renderCards();
          },
          // Schedule the draft directly to the content calendar. This
          // immediately posts the deliverable, marking it as used and
          // clearing any scheduledToFilm flag. Remove the draft from
          // production tasks so it does not appear in later phases.
          onSchedule: (draft) => {
            assignDraftToCalendar(client, currentFilter, draft);
            draft.used = true;
            draft.scheduledToFilm = false;
            if(state.tasks){
              state.tasks.forEach(tsk => {
                if(tsk.meta && tsk.meta.cards){
                  tsk.meta.cards = tsk.meta.cards.filter(ci => ci.id !== draft.id);
                }
              });
            }
            save();
            renderCards();
          },
          // Send the draft to the next available filming task. Writers can
          // prepare scripts for unscheduled drafts and then send them to
          // filming directly from this view.
          onFilm: (draft) => {
            assignDraftToFilming(client, currentFilter, draft);
            save();
            renderCards();
          }
        };
        const card = createDeliverableCard(client, currentFilter, d, actions);
        // Film button remains visible for scripting tasks; no need to hide
        container.appendChild(card);
      });
    }
    renderCards();
    tabs.querySelectorAll('.tab').forEach(tab => {
      tab.onclick = () => {
        tabs.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        renderCards();
      };
    });
    document.getElementById('scrClose').onclick = closeModal;
  });
}

// Display deliverables for editing tasks. Like scripting, this shows
// tabs for all content types and allows unscheduling or posting to the
// calendar. The edit view is used after filming when the editor needs
// to review drafts before finalising.
function viewEditingCards(taskId){
  const t = state.tasks.find(x=>x.id===taskId);
  if(!t || !/edit/i.test(t.name) || !t.meta || !t.meta.cards || !t.meta.cards.length){
    alert('No deliverables attached to this production task. Use "Send to filming" on a draft first.');
    return;
  }
  const client = state.clients[t.clientId];
  let currentFilter = 'video';
  openModal(`
    <h3>${t.name} deliverables</h3>
    <div class="tabs" id="editTabs">
      <div class="tab active" data-filter="video">Videos</div>
      <div class="tab" data-filter="photo">Photos</div>
      <div class="tab" data-filter="carousel">Carousels</div>
    </div>
    <div id="editCards" style="max-height:70vh; overflow-y:auto; overflow-x:visible; display:flex; flex-wrap:wrap; gap:20px; align-items:start"></div>
    <div class="row right" style="margin-top:12px"><button class="btn secondary" id="editClose">Close</button></div>
  `, () => {
    const modal = document.getElementById('modal');
    if(modal){ modal.style.maxWidth = '90vw'; }
    const tabs = document.getElementById('editTabs');
    const container = document.getElementById('editCards');
    function renderCards(){
      container.innerHTML = '';
      if(!window.cardMap) window.cardMap = new Map();
      t.meta.cards.forEach(info => {
        if(info.type !== currentFilter) return;
        const drafts = (client.drafts && client.drafts[info.type]) ? client.drafts[info.type] : [];
        const draft = drafts.find(d => d.id === info.id);
        if(!draft) return;
        const actions = {
          onDelete: (d) => {
            d.scheduledToFilm = false;
            t.meta.cards = t.meta.cards.filter(c => c.id !== d.id);
            save();
            renderCards();
          },
          onSchedule: (d) => {
            assignDraftToCalendar(client, info.type, d);
            d.used = true;
            d.scheduledToFilm = false;
            t.meta.cards = t.meta.cards.filter(c => c.id !== d.id);
            save();
            renderCards();
          },
          onFilm: null
        };
        const card = createDeliverableCard(client, info.type, draft, actions);
        // hide film button
        const filmBtn = card.querySelector('button[data-action="film"]');
        if(filmBtn){ filmBtn.style.display = 'none'; }
        container.appendChild(card);
      });
    }
    renderCards();
    tabs.querySelectorAll('.tab').forEach(tab => {
      tab.onclick = () => {
        tabs.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        tab.classList.add('active');
        currentFilter = tab.dataset.filter;
        renderCards();
      };
    });
    document.getElementById('editClose').onclick = closeModal;
  });
}

// Display email campaign deliverables for tasks with "email" in the name.
// When an email-related task is clicked on the calendar, this function
// presents all email drafts for the associated client. It uses the
// generic createDeliverableCard helper to render each draft and hides
// the film button since email campaigns are not sent to filming. The
// modal allows scheduling the campaign to the calendar or deleting the
// draft to remove it from production.
function viewEmailCards(taskId){
  const t = state.tasks.find(x=>x.id===taskId);
  if(!t){ alert('Task not found.'); return; }
  const client = state.clients[t.clientId];
  if(!client){ alert('Client not found.'); return; }
  // Ensure email drafts exist for this client before rendering
  ensureDrafts(client);
  const drafts = (client.drafts && client.drafts.email) ? client.drafts.email : [];
  openModal(`
    <h3>${t.name} • Email Campaigns</h3>
    <div id="emailCards" style="max-height:70vh; overflow-y:auto; display:flex; flex-wrap:wrap; gap:20px; align-items:start"></div>
    <div class="row right" style="margin-top:12px"><button class="btn secondary" id="emailClose">Close</button></div>
  `, () => {
    const container = document.getElementById('emailCards');
    drafts.forEach((dr, i) => {
      const actions = {
        onDelete: (d) => {
          // mark unscheduled and remove from array
          d.scheduledToFilm = false;
          const arr = client.drafts.email;
          const idx = arr.indexOf(d);
          if(idx>=0){ arr.splice(idx,1); save(); }
          // re-render
          render();
        },
        onSchedule: (d) => {
          assignDraftToCalendar(client, 'email', d);
          d.used = true;
          d.scheduledToFilm = false;
          save();
          render();
        },
        onFilm: null
      };
      const card = createDeliverableCard(client, 'email', dr, actions);
      // Hide the film button for email campaigns
      const filmBtn = card.querySelector('button[data-action="film"]');
      if(filmBtn) filmBtn.style.display = 'none';
      // Set a set/ordinal header: e.g. Set 1 • Email Campaign 1
      const small = card.querySelector('.small b');
      if(small){
        // Determine the set based on meta.months; fallback to 1
        const meta = PKG_META[client.package || 'none'] || {};
        const months = Math.max(1, meta.months || 1);
        const perSet = meta.emailCount || drafts.length || 1;
        const setIndex = Math.floor(i / perSet);
        const ordinal = (i % perSet) + 1;
        small.textContent = `Set ${setIndex+1} • Email Campaign ${ordinal}`;
      }
      container.appendChild(card);
    });
    document.getElementById('emailClose').onclick = closeModal;
  });
}

// Display a simple form for influencer tasks (confirm or shoot). Allows entering
// an influencer's name and social handle. The data is saved on the task
// meta so it persists across sessions. Only used for tasks whose name
// contains "influencer" and either "confirm" or "shoot". The popup is
// similar to deliverable modals but with a lightweight form.
function viewInfluencerTask(taskId){
  // Display a simple form for influencer tasks. This dialog is used
  // whenever a task name contains "influencer" regardless of the
  // specific action (find, confirm, shoot, etc.). Previously the
  // function returned early unless the task contained "confirm" or
  // "shoot" which meant find tasks never opened a popup. Removing
  // that restriction allows all influencer tasks to collect and
  // persist influencer details.
  const t = state.tasks.find(x => x.id === taskId);
  if(!t) return;
  // If this task doesn't mention influencer, exit silently. This guard
  // prevents non‑influencer tasks from accidentally opening this form.
  const nameLower = (t.name || '').toLowerCase();
  if(!nameLower.includes('influencer')) return;
  // Ensure meta exists
  if(!t.meta) t.meta = {};
  // Prefill influencer details. If the task itself has saved values,
  // use those; otherwise fall back to any details saved on the client.
  const client = state.clients[t.clientId];
  const infName = t.meta.influencerName || (client && client.influencerName) || '';
  const infHandle = t.meta.influencerHandle || (client && client.influencerHandle) || '';
  openModal(
    `<h3>${t.name}</h3>
     <div class="row wrap" style="margin-top:8px">
       <label style="flex:1;min-width:140px">Influencer name
         <input id="infName" type="text" value="${infName}" placeholder="Name" style="width:100%"/>
       </label>
       <label style="flex:1;min-width:140px">Instagram handle
         <input id="infHandle" type="text" value="${infHandle}" placeholder="@handle" style="width:100%"/>
       </label>
     </div>
     <div class="row right" style="margin-top:12px">
       <button class="btn secondary" id="infCancel">Cancel</button>
       <button class="btn" id="infSave">Save</button>
     </div>
    `,
    () => {
      const cancel = document.getElementById('infCancel');
      const saveBtn = document.getElementById('infSave');
      if(cancel) cancel.onclick = closeModal;
      if(saveBtn) saveBtn.onclick = () => {
        const nameVal = document.getElementById('infName').value.trim();
        const handleVal = document.getElementById('infHandle').value.trim();
        if(!t.meta) t.meta = {};
        t.meta.influencerName = nameVal;
        t.meta.influencerHandle = handleVal;
        // Propagate influencer details to all influencer tasks for this client.
        state.tasks.forEach(task => {
          if(task.clientId === t.clientId && task.name && task.name.toLowerCase().includes('influencer')){
            if(!task.meta) task.meta = {};
            task.meta.influencerName = nameVal;
            task.meta.influencerHandle = handleVal;
          }
        });
        // Store the influencer details on the client to reuse for new tasks
        if(client){
          client.influencerName = nameVal;
          client.influencerHandle = handleVal;
        }
        save();
        // Re-render the dashboard so the updated influencer details
        // appear on all task popups and lists. Without this, the
        // changes would only appear when the page refreshes.
        render();
        closeModal();
      };
    }
  );
}

// Display a scheduled content post and allow clients to approve or reject it. When
// a client clicks on a content post in their calendar, show the final
// deliverable preview along with the caption/text and a call to action. The
// modal includes Approve and X buttons. Approving sets post.approved=true;
// rejecting sets post.approved=false. Posts that reach their scheduled date
// without a response are auto‑approved when rendering the calendar.
function viewContentPost(clientId, post){
  const client = state.clients[clientId];
  if(!client || !post) return;
  // Fetch the draft to display final details when available
  let draft;
  if(post.draftId){
    const drafts = client.drafts && client.drafts[post.type] ? client.drafts[post.type] : [];
    draft = drafts.find(d => d.id === post.draftId);
  }
  // Determine preview HTML based on the deliverable type
  let previewHTML = '';
  if(post.type === 'email'){
    const img = (post.image || (draft && draft.finalImage)) ? `<img src="${post.image || draft.finalImage}" style="width:100%;height:auto;border-radius:8px"/>` : '<div style="width:100%;height:180px;background:#2a3047;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#666;font-size:12px">No image</div>';
    const headline = post.title || (draft && (draft.finalOffer || draft.offer)) || 'Email';
    const body = post.body || (draft && (draft.finalEmailText || draft.emailText)) || '';
    previewHTML = `
      ${img}
      <div style="font-weight:bold;font-size:16px;margin-top:12px">${headline}</div>
      <div style="font-size:14px;margin-top:8px;white-space:pre-wrap">${body}</div>
      <div style="margin-top:16px"><button class="btn small" style="background:var(--brand);color:#0f1115;padding:6px 12px;border-radius:8px">${headline ? 'Redeem Offer' : 'Call to Action'}</button></div>
    `;
  } else if(post.type === 'video' || post.type === 'photo' || post.type === 'carousel'){
    // For other types, show final video/image if available
    const media = draft && draft.finalVideo ? `<video src="${draft.finalVideo}" controls style="width:100%;border-radius:8px"></video>` : '';
    const img = draft && draft.finalImage ? `<img src="${draft.finalImage}" style="width:100%;height:auto;border-radius:8px"/>` : '';
    const caption = draft && (draft.finalCaption || draft.caption) ? `<div style="margin-top:8px;white-space:pre-wrap">${draft.finalCaption || draft.caption}</div>` : '';
    previewHTML = `${media || img || '<div style="width:100%;height:180px;background:#2a3047;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#666;font-size:12px">No preview</div>'}${caption}`;
  } else {
    // Default fallback
    previewHTML = '<div style="width:100%;height:180px;background:#2a3047;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#666;font-size:12px">No preview</div>';
  }
  openModal(
    `<h3>${client.name} • ${post.title || post.type.charAt(0).toUpperCase()+post.type.slice(1)}</h3>
     <div style="max-height:60vh;overflow-y:auto">${previewHTML}</div>
     <div class="row right" style="margin-top:16px">
       <button class="btn small danger" id="postReject" style="background:var(--danger);color:#0f1115;margin-right:8px">Deny</button>
       <button class="btn small ok" id="postApprove" style="background:var(--ok);color:#0f1115">Approve</button>
     </div>
    `,
    () => {
      const rejectBtn = document.getElementById('postReject');
      const approveBtn = document.getElementById('postApprove');
      // When a client denies a post, remove it from the content array and
      // persist the change. This will remove the post from the calendar.
      if(rejectBtn) rejectBtn.onclick = () => {
        const clientContent = state.clients[clientId]?.content || [];
        const idx = clientContent.indexOf(post);
        if(idx >= 0) clientContent.splice(idx, 1);
        // Remove reference to draft assignment so it can be rescheduled if needed
        if(post.draftId && post.type && state.clients[clientId]?.drafts && state.clients[clientId].drafts[post.type]){
          const dr = state.clients[clientId].drafts[post.type].find(d => d.id === post.draftId);
          if(dr){ dr.used = false; }
        }
        save();
        closeModal();
        // Re-render the content page so the calendar stays in context
        if(currentTab === 'Content') renderContent(); else render();
      };
      // When a client approves a post, mark it approved and update UI. Leave
      // the post in place. Optionally, we could add a flag to style the
      // post green in the calendar; simply set approved=true and re-render.
      if(approveBtn) approveBtn.onclick = () => {
        post.approved = true;
        save();
        closeModal();
        if(currentTab === 'Content') renderContent(); else render();
      };
    }
  );
}

// Allow clients to request schedule changes for a specific task. Opens a
// simple modal with a textarea for the client to describe their
// requested change. The request is stored in state.scheduleRequests
// so that the owner or representative can review them later.
function requestScheduleChange(taskId){
  const t = state.tasks.find(x => x.id === taskId);
  if(!t) return;
  const clientId = t.clientId;
  const client = state.clients[clientId];
  openModal(
    `<h3>Request schedule change</h3>
     <div class="small">${client?.name || ''} • ${t.name} on ${t.date}</div>
     <textarea id="reqMsg" placeholder="Describe the change you would like to request..." style="width:100%;min-height:100px;margin-top:12px"></textarea>
     <div class="row right" style="margin-top:12px">
       <button class="btn secondary" id="reqCancel">Cancel</button>
       <button class="btn" id="reqSend">Send request</button>
     </div>
    `,
    () => {
      const cancelBtn = document.getElementById('reqCancel');
      const sendBtn = document.getElementById('reqSend');
      if(cancelBtn) cancelBtn.onclick = closeModal;
      if(sendBtn) sendBtn.onclick = () => {
        const msg = document.getElementById('reqMsg').value.trim();
        if(!msg){ alert('Please enter a request.'); return; }
        state.scheduleRequests ||= [];
        state.scheduleRequests.push({ id: uid(), clientId, taskId, message: msg, date: todayStr() });
        save();
        alert('Schedule change request sent.');
        closeModal();
      };
    }
  );
}

// Show a simple options menu for a task. Presents Edit and Assign
// actions. Delegates to editTask or assignTask accordingly.
// Show a small contextual menu near the clicked position with Edit and
// Assign actions. The menu appears where you click and closes when
// clicking elsewhere. It does not use the modal backdrop, allowing
// multiple quick interactions without blocking the UI.
function showTaskMenu(ev, taskId){
  // Do not show menu to clients; they cannot edit or assign tasks.
  if(isClient()) return;
  // Allow calling without an explicit event (e.g. from inline HTML where
  // `event` may be undefined). Use window.event as fallback and
  // gracefully compute position based on the clicked element.
  const e = ev || window.event;
  if(e) e.stopPropagation();
  // remove existing menu if any
  const old = document.getElementById('taskMenu');
  if(old) old.remove();
  const menu = document.createElement('div');
  menu.id = 'taskMenu';
  menu.style.position = 'absolute';
  // Determine menu position. If the event has client coordinates use
  // them, otherwise position relative to the target element's
  // bounding rectangle.
  let x = e && typeof e.clientX === 'number' ? e.clientX : null;
  let y = e && typeof e.clientY === 'number' ? e.clientY : null;
  if(x === null || y === null){
    const target = (e && e.target) || document.body;
    const rect = target.getBoundingClientRect();
    x = rect.right;
    y = rect.top;
  }
  menu.style.top = (y + 8) + 'px';
  menu.style.left = (x + 8) + 'px';
  menu.style.background = getComputedStyle(document.documentElement).getPropertyValue('--panel');
  menu.style.border = '1px solid ' + getComputedStyle(document.documentElement).getPropertyValue('--border');
  menu.style.borderRadius = '12px';
  menu.style.padding = '6px 8px';
  menu.style.boxShadow = getComputedStyle(document.documentElement).getPropertyValue('--shadow');
  menu.innerHTML = `<div style="display:flex;flex-direction:column;gap:4px">
    <button class="btn small" style="width:100%" id="mEdit">Edit</button>
    <button class="btn small secondary" style="width:100%" id="mAssign">Assign</button>
  </div>`;
  document.body.appendChild(menu);
  document.getElementById('mEdit').onclick = ()=>{ menu.remove(); editTask(taskId); };
  document.getElementById('mAssign').onclick = ()=>{ menu.remove(); assignTask(taskId); };
  // click outside to close
  setTimeout(()=>{
    const handler = (e)=>{
      if(!menu.contains(e.target)){ menu.remove(); document.removeEventListener('click',handler); }
    };
    document.addEventListener('click', handler);
  });
}

// Handle clicking on a task row in the Weekly and Today lists. This
// helper inspects the task name and opens the appropriate deliverables
// modal. It ignores clicks on action icons (done/more). Use in
// onClick handlers for tasks displayed in list form.
function handleTaskRowClick(ev, taskId){
  // Ignore clicks on action icons
  if(ev && ev.target && ev.target.closest('.iconbtn')) return;
  const t = state.tasks.find(x=>x.id===taskId);
  if(!t) return;
  const name = (t.name||'').toLowerCase();
  // Always handle influencer tasks first. Previously only "confirm" or
  // "shoot" influencer tasks triggered the popup which caused tasks
  // like "Influencer – Find" to fall through. Removing the extra
  // qualifiers ensures all influencer‑related tasks open the influencer
  // form.
  if(name.includes('influencer')){
    viewInfluencerTask(taskId);
  } else if(name.includes('film')){
    viewFilmingCards(taskId);
  } else if(name.includes('photo')){
    viewPhotoCards(taskId);
  } else if(name.includes('script')){
    viewScriptingCards(taskId);
  } else if(name.includes('edit')){
    viewEditingCards(taskId);
  } else if(name.includes('email')){
    // For tasks whose names include "email", open the email campaign drafts.
    viewEmailCards(taskId);
  }
}

function archiveTask(id){
  const tIndex = state.tasks.findIndex(x=>x.id===id);
  if(tIndex<0) return;
  const t = state.tasks[tIndex];
  const cId = t.clientId;
  state.archives[cId] ||= [];
  state.archives[cId].push({name:t.name, date:t.date, assigneeId:t.assigneeId, when:todayStr()});
  state.tasks.splice(tIndex,1);
  save(); render();
}

/*** CLIENTS ***/
function renderClients(){
  const cont = document.createElement("div");

  // top row: chips and Add client button spaced apart. Place the Add
  // client button on the far right. If there are no clients, show a
  // placeholder message instead of chips.
  const ids = Object.keys(state.clients);
  const chips = document.createElement("div");
  chips.className="chips";
  if(ids.length===0){ chips.innerHTML=`<div class="small">No clients yet. Add one below.</div>`; }
  else{
    chips.innerHTML = ids.map(id=>{
      const c = state.clients[id];
      const col = c?.color || '#4f7cff';
      return `<div class="chip ${id===activeClientId?'active':''}" data-id="${id}"><span class="client-dot" style="background:${col}"></span>${c.name}</div>`;
    }).join("");
  }
  chips.onclick=(e)=>{
    const id=e.target.closest(".chip")?.dataset.id; if(!id) return;
    activeClientId=id; render();
  };
  const addBtn = document.createElement("button");
  addBtn.className = "btn";
  addBtn.textContent = "Add client";
  addBtn.onclick = () => {
    openModal(`
      <h3>Add client</h3>
      <div class="row wrap">
        <input id="cName" placeholder="Client name" style="flex:1"/>
        <input id="cCity" placeholder="City (optional)" style="flex:1"/>
      </div>
      <div class="row wrap" style="margin-top:8px">
        <div class="small" style="margin-bottom:4px;width:100%">Color</div>
        <div id="colorPalette" class="row wrap" style="gap:8px">
          ${['#22c55e','#3b82f6','#fbbf24','#ef4444','#a855f7','#06b6d4','#f97316','#6366f1'].map((col,i)=>`<div class="color-swatch" data-col="${col}" style="width:24px;height:24px;border-radius:12px;background:${col};border:2px solid transparent;cursor:pointer"></div>`).join('')}
        </div>
      </div>
      <div class="row wrap">
        <!-- Stack the three controls evenly across the modal. Each uses flex:1 so
             they consume equal horizontal space and wrap nicely on smaller screens. -->
        <label style="flex:1;min-width:140px">Onboard
          <input id="cOn" type="date" value="${todayStr()}"/>
        </label>
        <label style="flex:1;min-width:140px">Package
          <select id="cPkg">
            <option value="none">None</option>
            <option value="trial">Trial (1 mo)</option>
            <option value="mini">Regular (6 mo)</option>
            <option value="medium">Medium (6 mo)</option>
            <option value="large">Large (6 mo)</option>
          </select>
        </label>
        <label style="flex:1;min-width:140px">Price ($)
          <input id="cPrice" type="number" placeholder="Optional"/>
        </label>
      </div>
      <div class="row wrap">
        <label><input type="checkbox" id="addWeb"/> Website</label>
        <label><input type="checkbox" id="addEmail"/> Email</label>
        <label><input type="checkbox" id="addPhone"/> Phone</label>
      </div>
      <div class="row right" style="margin-top:12px">
        <button class="btn small secondary" id="cCancel">Cancel</button>
        <button class="btn small secondary" id="cCreate">Create</button>
        <button class="btn small" id="cCreateAuto">Create + Auto‑schedule</button>
      </div>
    `, () => {
      $("#cCancel").onclick = closeModal;
      // Color picker logic: highlight selected swatch and track choice
      let selectedColor = '#3b82f6';
      const palette = document.getElementById('colorPalette');
      if(palette){
        const swatches = palette.querySelectorAll('.color-swatch');
        swatches.forEach(sw=>{
          sw.onclick = ()=>{
            swatches.forEach(s=>s.classList.remove('selected'));
            sw.classList.add('selected');
            selectedColor = sw.dataset.col;
          };
        });
        // preselect first
        swatches[0]?.classList.add('selected');
      }

      const buildClient = (doSchedule) => {
        const name = $("#cName").value.trim();
        if(!name) return;
        const id = uid();
        const pkg = $("#cPkg").value;
        const priceStr = $("#cPrice").value.trim();
        const priceVal = priceStr ? Number(priceStr) : undefined;
        // Determine addons. If the selected package is website only, force
        // the website addon on so that website tasks are scheduled. Otherwise
        // respect the manual checkbox selections.
        const websiteAddon = (pkg === 'website') || $("#addWeb").checked;
        state.clients[id] = {
          id,
          name,
          city:$("#cCity").value.trim(),
          onboard:$("#cOn").value,
          package:pkg,
          addons:{
            website:websiteAddon,
            email:$("#addEmail").checked,
            phone:$("#addPhone").checked
          },
          start:"09:00",
          content:[],
          price:priceVal,
          color:selectedColor
        };
        save();
        activeClientId = id;
        if(doSchedule){
          scheduleClientMonths(state.clients[id]);
          // Also schedule social media posts based on the package
          scheduleContentPosts(state.clients[id]);
        }
        closeModal();
        render();
      };
      $("#cCreate").onclick = () => buildClient(false);
      $("#cCreateAuto").onclick = () => buildClient(true);
    });
  };
  // Combine chips and the Add client button into a single top row with
  // spaced layout. This moves the Add button to the far right, separate
  // from the client chips.
  const topRow = document.createElement('div');
  topRow.className = 'row';
  topRow.style.justifyContent = 'space-between';
  topRow.style.alignItems = 'center';
  topRow.appendChild(chips);
  topRow.appendChild(addBtn);
  cont.appendChild(topRow);

  // Show overdue tasks for this client. If there are tasks dated before today and
  // not yet archived, display a notice at the top of the client page. This
  // helps users quickly see past‑due work items without searching.
  if(activeClientId){
    try{
      const today = parseDate(todayStr());
      // Filter tasks belonging to the active client that are scheduled before today.
      const overdue = state.tasks.filter(t => t.clientId === activeClientId && parseDate(t.date) < today);
      if(overdue.length > 0){
        const note = document.createElement('div');
        note.className = 'card';
        // Use a warning colour from the theme for visibility. Lighten it slightly
        // so the text remains readable against the card background.
        note.style.background = 'rgba(255, 91, 91, 0.2)';
        note.style.border = '1px solid var(--danger)';
        note.style.color = 'var(--danger)';
        note.style.padding = '8px 12px';
        note.style.margin = '12px 0';
        note.style.borderRadius = 'var(--radius)';
        // Summarise the overdue tasks by name and date. Limit listing to avoid
        // excessive length when many tasks are overdue.
        const list = overdue.slice(0,5).map(t=>`${state.clients[t.clientId]?.name||''} • ${t.name} (${t.date})`).join(', ');
        const more = overdue.length > 5 ? ` and ${overdue.length-5} more` : '';
        note.innerHTML = `<strong>${overdue.length} overdue task${overdue.length!==1?'s':''}</strong>: ${list}${more}`;
        cont.appendChild(note);
      }
    } catch(e){}
  }

  // selected client calendar
  if(activeClientId && state.clients[activeClientId]){
    const c = state.clients[activeClientId];
    const box = document.createElement("div");
    box.className="card";
    // Determine which calendar view to show for this client (work vs content)
    const mode = clientViewModes[c.id] || 'work';
    // Build header with view toggle and contextual actions. The Add task button
    // only appears in work mode and Add content only appears in content mode.
    box.innerHTML = `
      <div class="row" style="justify-content:space-between;align-items:center">
        <h3>${c.name} • ${c.package.charAt(0).toUpperCase()+c.package.slice(1)} ${c.addons.website?"• Website":""} ${c.addons.email?"• Email":""} ${c.addons.phone?"• Phone":""}</h3>
      </div>
      <div class="row" style="justify-content:center;margin-top:8px">
        <div class="chips" id="calMode">
          <div class="chip ${mode==='work'?'active':''}" data-mode="work">Work</div>
          <div class="chip ${mode==='content'?'active':''}" data-mode="content">Content</div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:8px">
        <button class="btn small ghost" id="autoGen">Auto schedule</button>
        <button class="btn small secondary" id="editClient">Edit</button>
        <button class="btn small ghost" id="viewArchive">Archive</button>
        <button class="btn small danger" id="delClient">Delete</button>
      </div>
      <div class="calendar" id="clientCal"></div>
    `;
    cont.appendChild(box);
    // Calendar container
    const cal = $("#clientCal", box);
    // Set initial month/year for this client calendar
    // Initialise client calendars based on the override date rather than
    // the system date. Using todayStr() ensures the month view starts
    // on the correct date when the user has set a date override.
    let cur = parseDate(todayStr());
    let vy = cur.getFullYear(), vm = cur.getMonth();
    function drawWorkCal(){
      // Draw the task/work calendar
      // Include a days‑of‑week header above the grid for clarity
      cal.innerHTML = `
        <div class="cal-header">
          <div class="title" id="cliTitle">${MONTHS[vm]} ${vy}</div>
          <div class="hstack"><button class="btn small ghost" id="p">‹</button><button class="btn small ghost" id="n">›</button></div>
        </div>
        <div class="cal-days">${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].map(d=>`<div>${d}</div>`).join('')}</div>
        <div class="cal-grid" id="cliGrid"></div>
      `;
      const grid = $("#cliGrid", cal); grid.innerHTML="";
      $("#cliTitle", cal).textContent = `${MONTHS[vm]} ${vy}`;
      const days = monthMatrix(vy, vm);
      const onboard = parseDate(c.onboard || todayStr());
      days.forEach(d=>{
        const ds = fmtDate(d);
        const cell = document.createElement("div");
        cell.className="cal-cell";
        if(todayStr()===ds) cell.classList.add("today");
        if(d.getMonth()!==vm) cell.style.visibility="hidden";
        cell.dataset.date=ds;
        cell.innerHTML = `<div class="d">${d.getDate()}</div>`;

        // Highlight alternating 14‑day periods starting from the onboard
        // date. 0–13 days are highlighted, 14–27 are clear, 28–41
        // highlighted again, etc. Only highlight future dates.
        const diff = (d - onboard) / 86400000;
        if(diff >= 0){
          const seg = Math.floor(diff / 14);
          if(seg % 2 === 0) cell.classList.add('highlight');
        }
        // add link
        const addDiv = document.createElement('div');
        addDiv.className = 'add-btn';
        addDiv.textContent = 'Add';
        addDiv.onclick = () => {
          // Build a more spacious task creation form reminiscent of the original design
          const userOpts = Object.values(state.users).map(u => `<option value="${u.id}">${u.name}</option>`).join("");
          const modalHtml =
            '<h3>Add task for ' + c.name + '</h3>' +
            '<div class="row wrap">' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">Type</label>' +
                '<select id="evType" style="width:100%">' +
                  '<option value="N">Other</option>' +
                  '<option value="S">Scripting</option>' +
                  '<option value="F">Filming</option>' +
                  '<option value="E">Editing</option>' +
                  '<option value="P">Photo</option>' +
                  '<option value="W">Website</option>' +
                '</select>' +
              '</div>' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">Date</label>' +
                '<input id="evDate" type="date" value="' + ds + '" style="width:100%"/>' +
              '</div>' +
            '</div>' +
            '<div class="row wrap" style="margin-top:10px">' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">End date</label>' +
                '<input id="evEnd" type="date" value="' + ds + '" style="width:100%"/>' +
              '</div>' +
              '<div style="flex:1;min-width:180px;display:flex;align-items:center;gap:8px;margin-top:24px">' +
                '<input id="evEvery" type="checkbox"/>' +
                '<span class="small">Create on every day from start → end</span>' +
              '</div>' +
            '</div>' +
            '<div class="row wrap" style="margin-top:10px">' +
              '<div style="flex:1">' +
                '<label class="small">Title</label>' +
                '<input id="evName" placeholder="What is this?" style="width:100%"/>' +
              '</div>' +
            '</div>' +
            '<div class="row wrap" style="margin-top:10px">' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">Phase</label>' +
                '<div class="hstack" style="gap:12px;margin-top:4px">' +
                  '<label><input type="radio" name="evPhase" value="N" checked/> None</label>' +
                  '<label><input type="radio" name="evPhase" value="S"/> Scripting</label>' +
                  '<label><input type="radio" name="evPhase" value="F"/> Filming</label>' +
                '</div>' +
              '</div>' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">Time</label>' +
                '<div class="row wrap" style="gap:8px;margin-top:4px">' +
                  '<input id="evStart" type="time" value="09:00" style="flex:1"/>' +
                  // Leave the duration value blank so the placeholder 'Duration (h)' is visible.
                  '<input id="evDur" type="number" step="0.25" value="" placeholder="Duration (h)" style="flex:1"/>' +
                  '<label><input id="evAllDay" type="checkbox" checked/> All day</label>' +
                '</div>' +
              '</div>' +
            '</div>' +
            '<div class="row wrap" style="margin-top:10px">' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">Assignee</label>' +
                '<select id="evWho" style="width:100%">' + userOpts + '</select>' +
              '</div>' +
              '<div style="flex:1;min-width:180px">' +
                '<label class="small">Repeat</label>' +
                '<select id="evRepeat" style="width:100%">' +
                  '<option value="">None</option>' +
                  '<option value="daily">Daily</option>' +
                  '<option value="weekly">Weekly</option>' +
                  '<option value="monthly">Monthly</option>' +
                '</select>' +
              '</div>' +
            '</div>' +
            '<div class="row right" style="margin-top:16px">' +
              '<button class="btn secondary" id="c">Cancel</button>' +
              '<button class="btn" id="ok">Save</button>' +
            '</div>';
          openModal(modalHtml, () => {
            $("#c").onclick = closeModal;
            $("#ok").onclick = () => {
              const name = $("#evName").value.trim() || 'Task';
              const startDate = $("#evDate").value;
              const endDate = $("#evEnd").value;
              const startTime = $("#evStart").value || '09:00';
              const duration = Number($("#evDur").value) || 1;
              const type = document.querySelector('input[name="evPhase"]:checked')?.value || 'N';
              const who = $("#evWho").value;
              const repeat = $("#evRepeat").value;
              const every = $("#evEvery").checked;
              const allDay = $("#evAllDay").checked;
              // Helper to create a task on a given date
              const createOnDate = (dt) => {
                // If all day is checked, omit start time and set duration to 0
                const sTime = allDay ? '' : startTime;
                const dur = allDay ? 0 : duration;
                const task = makeTask(c.id, name, dt, sTime, dur, type, {});
                task.assigneeId = who;
                placeTask(task.date, task);
                state.tasks.push(task);
                if(repeat){
                  scheduleRecurringTasks(task, repeat);
                }
              };
              // If creating on every day within range, iterate dates
              if(every && endDate && endDate >= startDate){
                let cur = parseDate(startDate);
                const endD = parseDate(endDate);
                while(cur <= endD){
                  createOnDate(fmtDate(cur));
                  cur = new Date(cur.getTime() + 86400000);
                }
              } else {
                createOnDate(startDate);
              }
              save(); closeModal(); render();
            };
          });
        };
        // Only append the add button when not logged in as a client. Clients
        // should not create tasks on their calendar.
        if(!isClient()){
          cell.appendChild(addDiv);
        }
        // Show all tasks for this client regardless of assignee. Filtering
        // by the current viewing user would hide tasks assigned to other
        // employees, making it appear as if nothing was scheduled. To
        // provide full visibility, omit the assignee filter here.
        const list = tasksOnDate(ds, c.id, null);
        list.forEach(t=>{
          const div = document.createElement("div"); div.className="task"; div.draggable=true;
          div.ondragstart=(ev)=>ev.dataTransfer.setData("text/plain", t.id);
          // Use the client's chosen color for all tasks for a consistent
          // per‑client tint instead of varying colors by task type. This
          // improves visual grouping and reduces confusion when viewing
          // multiple tasks belonging to the same client.
          // Build the task HTML. Use a different action area depending on
          // whether a client is logged in. Clients cannot mark tasks
          // complete or edit them; instead they get a schedule change
          // request icon.
          let actionsHtml;
          if(isClient()){
            actionsHtml = `<div class="iconbtn request" title="Request change">✉️</div>`;
          } else {
            actionsHtml = `<div class="iconbtn ok" title="Done">✓</div><div class="iconbtn" title="More">…</div>`;
          }
          div.innerHTML = `<div class="dot" style="background:${clientColor(t.clientId)}"></div>
            <div class="name">${t.name}</div>
            <div class="meta">${t.start} • ~${t.duration}h</div>
            <div class="assignee">${state.users[t.assigneeId]?.name||"Unassigned"}</div>
            <div class="actions">${actionsHtml}</div>`;
          const actionBtns = div.querySelectorAll('.iconbtn');
          if(isClient()){
            // Clients can request schedule changes
            if(actionBtns[0]){
              actionBtns[0].onclick = (ev) => {
                ev.stopPropagation();
                requestScheduleChange(t.id);
              };
            }
          } else {
            // Mark complete when clicking the checkmark. Remove the task and
            // re-render without opening the edit dialog.
            const okBtn = div.querySelector('.iconbtn.ok');
            if(okBtn){ okBtn.onclick = () => archiveTask(t.id); }
            // Show a small options menu with Edit and Assign when clicking
            // the three dots. Pass the native event so positioning works.
            if(actionBtns[1]){
              actionBtns[1].onclick = (ev) => showTaskMenu(ev, t.id);
            }
          }
          // When clicking anywhere else on the task (e.g. the name or
          // meta), open the corresponding viewer for that production
          // phase. Ignore clicks on action buttons so the menu and
          // completion handlers still function. Use a case‑insensitive
          // substring check so custom names like "Filming Day 2" or
          // "Photo session" still trigger the correct modal.
          div.onclick = (ev) => {
            if(ev.target.closest('.iconbtn')) return;
            const nameLower = (t.name || '').toLowerCase();
            // influencer confirm/shoot tasks pop up for influencer details
            if(nameLower.includes('influencer') && (nameLower.includes('confirm') || nameLower.includes('shoot'))){
              viewInfluencerTask(t.id);
            } else if(nameLower.includes('film')){
              viewFilmingCards(t.id);
            } else if(nameLower.includes('photo')){
              viewPhotoCards(t.id);
            } else if(nameLower.includes('script')){
              viewScriptingCards(t.id);
            } else if(nameLower.includes('edit')){
              viewEditingCards(t.id);
            } else if(nameLower.includes('email')){
              // For tasks that include "email" in their name, open the email campaign drafts
              viewEmailCards(t.id);
            }
          };
          cell.appendChild(div);
        });
        cell.ondragover=(e)=>e.preventDefault();
        cell.ondrop=(e)=>{
          const id = e.dataTransfer.getData("text/plain");
          const t = state.tasks.find(x=>x.id===id); if(!t) return;
          t.date = ds; placeTask(t.date, t); save(); drawWorkCal();
        };
        grid.appendChild(cell);
      });
      // navigation
      $("#p", cal).onclick=()=>{ vm--; if(vm<0){vm=11;vy--;} drawWorkCal(); };
      $("#n", cal).onclick=()=>{ vm++; if(vm>11){vm=0;vy++;} drawWorkCal(); };
    }
    function drawContentCalForClient(){
      // Draw the content calendar for this client
      // Include a days‑of‑week header for the content calendar
      cal.innerHTML = `
        <div class="cal-header">
          <div class="title" id="cliTitle">${MONTHS[vm]} ${vy}</div>
          <div class="hstack"><button class="btn small ghost" id="p">‹</button><button class="btn small ghost" id="n">›</button></div>
        </div>
        <div class="cal-days">${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].map(d=>`<div>${d}</div>`).join('')}</div>
        <div class="cal-grid" id="cliGrid"></div>
      `;
      const grid = $("#cliGrid", cal); grid.innerHTML="";
      $("#cliTitle", cal).textContent = `${MONTHS[vm]} ${vy}`;
      const days = monthMatrix(vy, vm);
      const onboard = parseDate(c.onboard || todayStr());
      days.forEach(d=>{
        const ds = fmtDate(d);
        const cell = document.createElement("div");
        cell.className = "cal-cell";
        if(todayStr()===ds) cell.classList.add("today");
        if(d.getMonth()!==vm) cell.style.visibility = "hidden";
        cell.dataset.date = ds;
        cell.innerHTML = `<div class="d">${d.getDate()}</div>`;

        // Highlight alternating 14‑day periods starting from onboard date
        const diff = (d - onboard) / 86400000;
        if(diff >= 0){
          const seg = Math.floor(diff / 14);
          if(seg % 2 === 0) cell.classList.add('highlight');
        }
        // add link for content
        const addDiv = document.createElement('div');
        addDiv.className = 'add-btn';
        addDiv.textContent = 'Add';
        addDiv.onclick = () => {
          openModal(`
            <h3>Add content for ${c.name}</h3>
            <div class="row wrap">
              <label style="flex:1;min-width:120px">Title
                <input id="clTitle" placeholder="Post title"/>
              </label>
              <label style="flex:1;min-width:120px">Date
                <input id="clDate" type="date" value="${ds}"/>
              </label>
              <label style="flex:1;min-width:120px">Type
                <input id="clType" placeholder="e.g. Instagram, TikTok"/>
              </label>
            </div>
            <div class="row right" style="margin-top:12px">
              <button class="btn secondary" id="clCancel">Cancel</button>
              <button class="btn" id="clSave">Save</button>
            </div>
          `, () => {
            $("#clCancel").onclick = closeModal;
            $("#clSave").onclick = () => {
              const item = { id: uid(), title: $("#clTitle").value.trim() || 'Untitled', date: $("#clDate").value, type: $("#clType").value.trim() };
              if(!c.content) c.content = [];
              c.content.push(item);
              save(); closeModal(); render();
            };
          });
        };
        // Only append the add button when not logged in as a client. Clients
        // cannot add content posts directly from the calendar.
        if(!isClient()){
          cell.appendChild(addDiv);
        }
        if(Array.isArray(c.content)){
          const posts = c.content.filter(p=>p.date===ds);
        posts.forEach(p=>{
            const div = document.createElement("div");
            // If this post originates from a draft, show a rich preview
            if(p.draftId){
              // find the draft in any deliverable type
              let draft = null; let dType = '';
              ['video','photo','carousel','website'].some(tp=>{
                const arr = c.drafts && c.drafts[tp];
                if(arr){ const found = arr.find(d=>d.id===p.draftId); if(found){ draft = found; dType = tp; return true; } }
                return false;
              });
              if(draft){
                div.className = 'post-card';
                div.style.padding = '6px';
                // Build a mini Instagram-like card within the calendar cell
                const avatar = c.avatar || '';
                const handle = c.handle || c.name.replace(/\s+/g,'').toLowerCase();
                const mediaHtml = draft.finalVideo ? `<video src="${draft.finalVideo}" controls style="width:100%;height:auto"></video>` : '<div class="placeholder">No media</div>';
                div.innerHTML = `
                  <div class="post-header">
                    <div class="avatar" style="background-image:url('${avatar}')"></div>
                    <div class="meta">
                      <div class="name">${c.name}</div>
                      <div class="handle">@${handle}</div>
                    </div>
                  </div>
                  <div class="post-media">${mediaHtml}</div>
                  <div class="post-caption"><b>${c.name}</b> ${draft.finalCaption||draft.caption||''}</div>
                `;
                // Allow editing posts only for non-client users. Clients can view the
                // post preview but cannot open the edit modal. Remove the click
                // handler when logged in as a client.
                if(!isClient()){
                  div.onclick = ()=> editContent(p.id, c.id);
                }
                cell.appendChild(div);
                return;
              }
            }
            // fallback simple task display
            div.className = "task";
            div.innerHTML = `<div class="dot" style="background:#915eff"></div><div class="name">${p.title||'Untitled'}</div>`;
            if(!isClient()){
              div.onclick = ()=>{ editContent(p.id, c.id); };
            }
            cell.appendChild(div);
          });
        }
        grid.appendChild(cell);
      });
      // navigation for content calendar
      $("#p", cal).onclick=()=>{ vm--; if(vm<0){vm=11;vy--;} drawContentCalForClient(); };
      $("#n", cal).onclick=()=>{ vm++; if(vm>11){vm=0;vy++;} drawContentCalForClient(); };
    }
    // Render the appropriate calendar based on mode
    if(mode === 'content'){
      drawContentCalForClient();
    } else {
      drawWorkCal();
    }
    // Toggle calendar view when clicking chips
    $("#calMode", box).onclick = (e)=>{
      const m = e.target.closest('.chip')?.dataset.mode;
      if(m && m !== mode){
        clientViewModes[c.id] = m;
        render();
      }
    };
    // Auto schedule tasks and content for this client
    // Auto schedule tasks and content for this client. Instead of
    // re‑scheduling all phases from the beginning, compute the next
    // available phase based on the highest numeric phase already
    // scheduled for this client. Then append a single month of tasks
    // and corresponding content posts starting after the last set.
    $("#autoGen", box).onclick = () => {
      // Prompt the user for how many months to auto‑schedule. Showing a
      // modal here allows flexible extension of the contract. If the
      // user cancels, nothing happens. If the user enters a value
      // less than 1, default to one month.
      openModal(`
        <h3>Auto schedule</h3>
        <p>How many additional months would you like to schedule for <strong>${c.name}</strong>?</p>
        <div style="margin-bottom:12px"><input id="autoMonths" type="number" min="0" value="0" style="width:80px"/></div>
        <div class="row right" style="gap:8px">
          <button class="btn secondary" id="autoCancel">Cancel</button>
          <button class="btn" id="autoConfirm">Schedule</button>
        </div>
      `, () => {
        const mInput = document.getElementById('autoMonths');
        const cancelBtn = document.getElementById('autoCancel');
        const confirmBtn = document.getElementById('autoConfirm');
        cancelBtn.onclick = closeModal;
        confirmBtn.onclick = () => {
          let months = parseInt(mInput.value, 10);
          // Accept zero or more additional months. When months is NaN or negative,
          // treat it as zero to schedule only the baseline package months.
          if(isNaN(months) || months < 0) months = 0;
          const nextPhase = getMaxPhaseForClient(c) + 1;
          // Append the requested number of new months to both the work
          // schedule and the content calendar. Use startMonthIndex of
          // nextPhase so that existing phases are not overwritten.
          scheduleClientMonths(c, nextPhase, months);
          scheduleAdditionalContentPosts(c, nextPhase, months);
          save();
          render();
          closeModal();
        };
      });
    };
    // Edit client button: open a modal prefilled with current client info and allow changes
    $("#editClient", box).onclick=()=>{
      openModal(`
        <h3>Edit client</h3>
        <div class="row wrap">
          <input id="edName" placeholder="Client name" style="flex:1" value="${c.name}"/>
          <input id="edCity" placeholder="City (optional)" style="flex:1" value="${c.city||''}"/>
        </div>
        <div class="row wrap" style="margin-top:8px">
          <div class="small" style="margin-bottom:4px;width:100%">Color</div>
          <div id="edPalette" class="row wrap" style="gap:8px">
            ${['#22c55e','#3b82f6','#fbbf24','#ef4444','#a855f7','#06b6d4','#f97316','#6366f1'].map(col=>`<div class="color-swatch" data-col="${col}" style="width:24px;height:24px;border-radius:12px;background:${col};border:2px solid transparent;cursor:pointer"></div>`).join('')}
          </div>
        </div>
        <div class="row wrap">
          <label style="flex:1;min-width:140px">Onboard
            <input id="edOn" type="date" value="${c.onboard}"/>
          </label>
          <label style="flex:1;min-width:140px">Package
            <select id="edPkg">
              <option value="none" ${c.package==='none'?'selected':''}>None</option>
              <option value="trial" ${c.package==='trial'?'selected':''}>Trial (1 mo)</option>
              <option value="mini" ${c.package==='mini'?'selected':''}>Regular (6 mo)</option>
              <option value="medium" ${c.package==='medium'?'selected':''}>Medium (6 mo)</option>
              <option value="large" ${c.package==='large'?'selected':''}>Large (6 mo)</option>
              <option value="website" ${c.package==='website'?'selected':''}>Website only (1 mo)</option>
            </select>
          </label>
          <label style="flex:1;min-width:140px">Price ($)
            <input id="edPrice" type="number" value="${c.price||''}" placeholder="Optional"/>
          </label>
        </div>
        <div class="row wrap">
          <label><input type="checkbox" id="edWeb" ${c.addons?.website?'checked':''}/> Website</label>
          <label><input type="checkbox" id="edEmail" ${c.addons?.email?'checked':''}/> Email</label>
          <label><input type="checkbox" id="edPhone" ${c.addons?.phone?'checked':''}/> Phone</label>
        </div>
        <div class="row wrap" style="margin-top:8px">
          <label style="flex:1;min-width:140px">Handle
            <input id="edHandle" value="${c.handle||''}" placeholder="Instagram handle (without @)"/>
          </label>
          <label style="flex:1;min-width:140px">Avatar
            <input id="edAvatar" type="file" />
          </label>
        </div>
        <div class="row right" style="margin-top:12px">
          <button class="btn secondary" id="edCancel">Cancel</button>
          <button class="btn" id="edSave">Save</button>
        </div>
      `, ()=>{
        $("#edCancel").onclick = closeModal;
        // color picker for edit
        let selColor = c.color || '#3b82f6';
        const pal = document.getElementById('edPalette');
        if(pal){
          const sws = pal.querySelectorAll('.color-swatch');
          sws.forEach(sw=>{
            if(sw.dataset.col === selColor) sw.classList.add('selected');
            sw.onclick = ()=>{
              sws.forEach(x=>x.classList.remove('selected'));
              sw.classList.add('selected');
              selColor = sw.dataset.col;
            };
          });
        }
        $("#edSave").onclick = ()=>{
          c.name = $("#edName").value.trim() || c.name;
          c.city = $("#edCity").value.trim();
          c.onboard = $("#edOn").value;
          c.package = $("#edPkg").value;
          const priceVal = $("#edPrice").value.trim();
          c.price = priceVal ? Number(priceVal) : undefined;
          c.addons = {
            website: $("#edWeb").checked,
            email: $("#edEmail").checked,
            phone: $("#edPhone").checked
          };
          c.handle = $("#edHandle").value.trim();
          c.color = selColor;
          // handle avatar upload
          const file = $("#edAvatar").files[0];
          if(file){
            const reader = new FileReader();
            reader.onload = (ev)=>{
              c.avatar = ev.target.result;
              save();
              closeModal();
              render();
            };
            reader.readAsDataURL(file);
          } else {
            save(); closeModal(); render();
          }
        };
      });
    };
    // Archive view for this client
    $("#viewArchive", box).onclick=()=>{
      const list = state.archives[c.id]||[];
      openModal(`
        <h3>${c.name} • Archive</h3>
        <ul>${list.map((a,i)=>`<li>${a.date} • ${a.name} (${state.users[a.assigneeId]?.name||'—'}) <button class="btn small ghost" data-i="${i}" id="res${i}">Restore</button></li>`).join("")||"<div class='small'>Empty</div>"}</ul>
        <div class="row right"><button class="btn secondary" id="closeA">Close</button></div>
      `, ()=>{
        $("#closeA").onclick=closeModal;
        list.forEach((a,i)=>{
          const btn = $("#res"+i);
          if(btn) btn.onclick=()=>{
            const t = makeTask(c.id, a.name, todayStr(), "09:00", 1, "N", {});
            t.assigneeId = a.assigneeId;
            state.tasks.push(t);
            state.archives[c.id].splice(i,1);
            save(); closeModal(); render();
          };
        });
      });
    };
    // Delete client
    $("#delClient", box).onclick=()=>{
      openModal(`<h3>Delete ${c.name}?</h3><div class="small">This removes all tasks, content and archive for this client.</div><div class="row right"><button class="btn secondary" id="cancel">Cancel</button><button class="btn danger" id="doDel">Delete</button></div>`,()=>{
        $("#cancel").onclick=closeModal;
        $("#doDel").onclick=()=>{
          // remove tasks, content & archives
          state.tasks = state.tasks.filter(t=>t.clientId!==c.id);
          delete state.archives[c.id];
          delete state.clients[c.id];
          delete clientViewModes[c.id];
          activeClientId = Object.keys(state.clients)[0]||null;
          save(); closeModal(); render();
        };
      });
    };
  }

  $("#screen").innerHTML="";
  $("#screen").appendChild(cont);
}

/*** CONTENT ***/
// Display deliverable management cards instead of a calendar. Users can
// select a client via chips. For the selected client, the page shows
// deliverable cards separated into Videos, Photos and Carousels. Each
// card lets you enter an idea, script, example and caption on the
// front; flip to the back to enter the finished video link and final
// caption. A plus button schedules the finished draft to the content
// calendar. A "Generate video ideas" button prompts the user for
// brand details and fills draft ideas automatically.
function renderContent(){
  const cont = document.createElement('div');
  cont.className = 'card';
  // Ensure the deliverable area is tall enough so that cards don't
  // overflow onto the footer. A minimum height relative to the
  // viewport gives drafts room to breathe and prevents overlap with
  // the persistent local‑storage notice at the bottom of the page.
  cont.style.minHeight = '70vh';
  // Determine which clients to show. When logged in as a client, only
  // include that client. Otherwise include all clients.
  let ids = Object.keys(state.clients);
  if(isClient()){
    const cid = currentClientId();
    ids = cid ? [cid] : [];
    // default to the client when logged in
    contentClientId = cid;
  }
  if(ids.length===0){
    cont.innerHTML = `<h3>Content</h3><div class="small">No clients available. Add a client first to manage content.</div>`;
    $("#screen").innerHTML = '';
    $("#screen").appendChild(cont);
    return;
  }
  // ensure selected client
  if(!contentClientId || !state.clients[contentClientId]) contentClientId = ids[0];
  // chips
  const chipsDiv = document.createElement('div');
  chipsDiv.className = 'chips';
  chipsDiv.innerHTML = ids.map(cid=>{
    const c = state.clients[cid];
    return `<div class="chip ${cid===contentClientId?'active':''}" data-id="${cid}">${c.name}</div>`;
  }).join('');
  // Only allow switching clients for non-client users. Clients should
  // not change the selected client.
  if(!isClient()){
    chipsDiv.onclick = (e)=>{
      const id = e.target.closest('.chip')?.dataset.id;
      if(id){ contentClientId = id; renderContent(); }
    };
  }
  cont.appendChild(chipsDiv);
  // selected client details
  const c = state.clients[contentClientId];
  if(c){
    ensureDrafts(c);
    // header with generate button
    const header = document.createElement('div');
    header.className = 'row';
    header.style.justifyContent = 'space-between';
    // Hide the generate ideas button when the logged-in user is a client. Clients
    // can only view existing drafts, not generate new ones.
    header.innerHTML = `<h3>${c.name} • Deliverables</h3>${!isClient() ? '<button class="btn small" id="genIdeas">Generate video ideas</button>' : ''}`;
    cont.appendChild(header);
    // generate ideas handler
    setTimeout(()=>{
      const genBtn = document.getElementById('genIdeas');
      if(genBtn){
        // Apply client colour for the button. Use the client's colour if available,
        // otherwise fall back to the default client colour helper. Ensure the text
        // stays white for contrast.
        genBtn.style.background = (c.color || clientColor(c.id));
        genBtn.style.color = '#fff';
        genBtn.onclick = () => {
          // Prompt for brand details. Use these inputs to generate varied video ideas.
          openModal(`
            <h3>Generate video ideas for ${c.name}</h3>
            <div class="row wrap">
              <label style="flex:1;min-width:120px">Describe the brand
                <textarea id="brandDesc" placeholder="e.g. premium sneakers brand"></textarea>
              </label>
              <label style="flex:1;min-width:120px">Target audience
                <input id="brandAudience" placeholder="e.g. young professionals" />
              </label>
            </div>
            <div class="row right" style="margin-top:12px">
              <button class="btn secondary" id="giCancel">Cancel</button>
              <button class="btn" id="giOk">Generate</button>
            </div>
          `, () => {
            $("#giCancel").onclick = closeModal;
            $("#giOk").onclick = () => {
              const desc = $("#brandDesc").value.trim();
              const aud = $("#brandAudience").value.trim();
              if(!c.drafts.video || c.drafts.video.length === 0){
                closeModal();
                return;
              }
              const templates = [
                `Introduce ${desc || 'the brand'} and its mission to ${aud || 'your audience'}.`,
                `Take your viewers behind the scenes of how ${desc || 'the brand'} creates its products or services for ${aud || 'your audience'}.`,
                `Feature testimonials from satisfied customers of ${desc || 'the brand'} to build trust with ${aud || 'your audience'}.`,
                `Demonstrate how ${desc || 'the brand'} solves a common problem for ${aud || 'your audience'} in a quick tutorial.`,
                `Highlight the unique features and benefits of ${desc || 'the brand'} in a fun challenge or experiment.`,
                `Show a day in the life at ${desc || 'the brand'}, giving ${aud || 'your audience'} a personal connection.`
              ];
              c.drafts.video.forEach((d, i) => {
                const idx = i % templates.length;
                d.idea = `Idea ${i + 1}: ${templates[idx]}`;
              });
              save();
              closeModal();
              renderContent();
            };
          });
        };
      }
    });
    // Build deliverable type selector based on available drafts. Include
    // website if present. Persist the current type across re-renders.
    const availableTypes = [];
    // Determine available deliverable types based on the client's package
    // metadata rather than the presence of drafts alone. This allows a type
    // tab to remain visible even when all drafts have been removed. If the
    // package defines at least one unit for a type, or the client already
    // has drafts of that type, include it in the available list. Website
    // deliverables are included if the client purchased a website add‑on or
    // package.
    {
      const meta = PKG_META[c.package || 'none'] || {};
      if((meta.videoCount > 0) || (c.drafts.video && c.drafts.video.length > 0)){
        availableTypes.push('video');
      }
      if((meta.photoCount > 0) || (c.drafts.photo && c.drafts.photo.length > 0)){
        availableTypes.push('photo');
      }
      if((meta.carouselCount > 0) || (c.drafts.carousel && c.drafts.carousel.length > 0)){
        availableTypes.push('carousel');
      }
      if(c.drafts.website || c.addons?.website || c.package === 'website'){
        availableTypes.push('website');
      }
      // Include email campaigns if the package has an emailCount or the client has email drafts
      if((meta.emailCount > 0) || (c.drafts.email && c.drafts.email.length > 0)){
        availableTypes.push('email');
      }
    }
    if(!availableTypes.includes(contentType)){
      contentType = availableTypes[0] || '';
    }
    // Type chips
    const typeChips = document.createElement('div');
    typeChips.className = 'chips';
    typeChips.style.marginTop = '12px';
    typeChips.innerHTML = availableTypes.map(t=>{
      let label;
      if(t==='video') label = 'Videos';
      else if(t==='photo') label = 'Photos';
      else if(t==='carousel') label = 'Carousels';
      else if(t==='website') label = 'Website';
      else if(t==='email') label = 'Email Campaigns';
      else label = t;
      return `<div class="chip ${t===contentType?'active':''}" data-type="${t}">${label}</div>`;
    }).join('');
    typeChips.onclick = (e)=>{
      const t = e.target.closest('.chip')?.dataset.type;
      if(t){
        contentType = t;
        contentSetIndex = 0;
        renderContent();
      }
    };
    cont.appendChild(typeChips);
    // Determine sets count for the selected type. Each set corresponds
    // to a month of the package (meta.months). The number of drafts per
    // set equals the package's film hours. Website has only one set.
    const draftsForType = c.drafts[contentType] || [];
    const pkgMeta = PKG_META[c.package||'none'] || {};
    let setsCount = 1;
    let perSet = 1;
    if(contentType !== 'website'){
      // Fix the number of sets based solely on the package length (months).
      // Do not expand the number of sets when more drafts are added. Trial
      // packages produce a single set; regular/mini/etc. packages create
      // one set per month defined in PKG_META. This prevents Add buttons
      // from creating new sets unexpectedly.
      setsCount = Math.max(1, pkgMeta.months || 1);
      // Determine how many deliverables belong in each set based on the
      // package definitions. Do not fall back to drafts length here so
      // the capacity per set remains constant.
      if(contentType === 'video') perSet = pkgMeta.videoCount || 1;
      else if(contentType === 'photo') perSet = pkgMeta.photoCount || 1;
      else if(contentType === 'carousel') perSet = pkgMeta.carouselCount || 1;
      else if(contentType === 'email') perSet = pkgMeta.emailCount || 1;
    }
    // Reset the current set index when it exceeds the available sets
    if(contentSetIndex >= setsCount) contentSetIndex = 0;
    // Build set chips navigation when more than one set (one per month)
    if(setsCount > 1){
      const setChips = document.createElement('div');
      setChips.className = 'chips';
      setChips.style.marginTop = '8px';
      setChips.innerHTML = Array.from({length: setsCount}, (_,i)=>`<div class="chip ${i===contentSetIndex?'active':''}" data-set="${i}">Set ${i+1}</div>`).join('');
      setChips.onclick = (e)=>{
        const idx = e.target.closest('.chip')?.dataset.set;
        if(idx!=null){
          contentSetIndex = Number(idx);
          renderContent();
        }
      };
      cont.appendChild(setChips);
    }
    // Build deliverables for current type and set
    const section = document.createElement('div');
    section.style.marginTop = '16px';
    const headerEl = document.createElement('h4');
    // Choose an appropriate heading based on the deliverable type. Include
    // an explicit label for email campaigns; fall back to the content
    // type itself (capitalized) for any unknown future types.
    let headerName;
    if(contentType === 'video') headerName = 'Videos';
    else if(contentType === 'photo') headerName = 'Photos';
    else if(contentType === 'carousel') headerName = 'Carousels';
    else if(contentType === 'website') headerName = 'Website';
    else if(contentType === 'email') headerName = 'Email Campaigns';
    else headerName = contentType.charAt(0).toUpperCase() + contentType.slice(1);
    headerEl.textContent = headerName;
    section.appendChild(headerEl);
    const grid = document.createElement('div');
    // Use flexbox for deliverables. Cards will wrap automatically and
    // maintain a minimum width without forcing equal heights. The gap
    // separates cards both horizontally and vertically.
    grid.style.display = 'flex';
    grid.style.flexWrap = 'wrap';
    grid.style.gap = '20px';
    // cards have more content.
    grid.style.alignItems = 'start';
    // Determine which drafts belong to this set. Drafts created via the
    // Add button carry a `set` property. Use it to assign drafts to
    // explicit sets. For drafts without this property, fall back to
    // grouping by index based on the package capacity. Do not limit
    // the number of drafts displayed per set: any draft assigned to
    // this set will be shown, even if it exceeds the nominal per‑set
    // capacity.
    let slice = draftsForType;
    if(contentType !== 'website'){
      slice = draftsForType.filter((draft, idx) => {
        const assigned = (draft.set != null ? draft.set : Math.floor(idx / perSet));
        return assigned === contentSetIndex;
      });
    }
    slice.forEach((draft, i) => {
      if(contentType === 'website'){
        // Use simplified layout for website deliverables
        const card = document.createElement('div');
        card.className = 'card deliverable';
        card.style.position = 'relative';
        card.style.flex = '1 1 300px';
        const trash = document.createElement('button');
        trash.className = 'trash-btn';
        trash.innerHTML = '&#128465;';
        trash.onclick = (e) => {
          e.stopPropagation();
          if(confirm('Delete this draft?')){
            const arr = c.drafts[contentType];
            const idx = arr.indexOf(draft);
            if(idx>=0){ arr.splice(idx,1); save(); renderContent(); }
          }
        };
        card.appendChild(trash);
        const inner = document.createElement('div');
        inner.className = 'inner';
        const front = document.createElement('div'); front.className = 'front';
        const back  = document.createElement('div'); back.className  = 'back';
        front.innerHTML = `
          <div class="small"><b>Website</b></div>
          <label>URL
            <input class="input" data-field="url" value="${draft.url||''}" />
          </label>
          <label>Description
            <textarea class="input" data-field="description">${draft.description||''}</textarea>
          </label>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <button class="btn small secondary" data-action="flip">Flip</button>
            <span class="small">${draft.used?'Completed':'Draft'}</span>
          </div>
        `;
        back.innerHTML = `
          <label>Final link
            <input class="input" data-field="finalLink" value="${draft.finalLink||''}" />
          </label>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <button class="btn small secondary" data-action="flip">Back</button>
            <button class="btn small" data-action="schedule">Mark done</button>
          </div>
        `;
        inner.appendChild(front);
        inner.appendChild(back);
        card.appendChild(inner);
        // Bind events
        card.querySelectorAll('textarea.input, input.input:not([type="file"])').forEach(inp=>{
          inp.oninput = () => {
            const f = inp.dataset.field;
            draft[f] = inp.value;
            save();
          };
        });
        card.querySelectorAll('button[data-action="flip"]').forEach(btn=>{
          btn.onclick = (ev)=>{
            ev.stopPropagation();
            card.classList.toggle('flipped');
          };
        });
        const schedBtn = card.querySelector('button[data-action="schedule"]');
        if(schedBtn){
          schedBtn.onclick = (ev)=>{
            ev.stopPropagation();
            assignDraftToCalendar(c, contentType, draft);
            draft.used = true;
            save(); renderContent();
          };
        }
        grid.appendChild(card);
      } else if(contentType === 'email') {
        // Build a custom card for email campaign deliverables. The front
        // collects the offer, email body and link. The back shows a
        // preview of the email design with an image, headline and body.
        const card = document.createElement('div');
        card.className = 'card deliverable';
        card.style.position = 'relative';
        card.style.flex = '0 0 300px';
        // Trash button for deleting the draft
        const trash = document.createElement('button');
        trash.className = 'trash-btn';
        trash.innerHTML = '&#128465;';
        trash.onclick = (e) => {
          e.stopPropagation();
          const arr = c.drafts[contentType];
          const idx = arr.indexOf(draft);
          if(idx>=0){ arr.splice(idx,1); save(); renderContent(); }
        };
        card.appendChild(trash);
        const inner = document.createElement('div');
        inner.className = 'inner';
        const front = document.createElement('div'); front.className = 'front';
        const back  = document.createElement('div'); back.className  = 'back';
        // Front side fields
        front.innerHTML = `
          <div class="small"><b>Email Campaign</b></div>
          <label>Offer
            <textarea class="input" data-field="offer">${draft.offer||''}</textarea>
          </label>
          <label>Email Campaign Text
            <textarea class="input" data-field="emailText">${draft.emailText||''}</textarea>
          </label>
          <label>Mailchimp/SpotHopper Link
            <input class="input" data-field="link" value="${draft.link||''}" />
          </label>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <div class="hstack" style="gap:6px">
              <button class="btn small secondary" data-action="flip">Flip</button>
              <button class="btn small" data-action="schedule">+ Calendar</button>
            </div>
            <span class="small">${draft.used ? 'Scheduled' : 'Draft'}</span>
          </div>
        `;
        // Back side preview
        // Use final values when available; otherwise fall back to the draft values.
        const offerText = draft.finalOffer || draft.offer || '';
        const bodyText = draft.finalEmailText || draft.emailText || '';
        const imgHtml = draft.finalImage ? `<img src="${draft.finalImage}" style="width:100%;height:auto;border-radius:8px"/>` : '<div class="placeholder" style="width:100%;height:180px;background:#2a3047;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#666;font-size:12px">No image</div>';
        back.innerHTML = `
          <div style="display:flex;flex-direction:column;gap:12px">
            ${imgHtml}
            <div style="font-weight:bold;font-size:16px">${offerText}</div>
            <div style="font-size:14px;line-height:1.4;white-space:pre-wrap">${bodyText}</div>
            <div style="margin-top:12px"><button class="btn small" style="background:var(--brand);color:#0f1115;padding:6px 12px;border-radius:8px">${offerText ? 'Redeem Offer' : 'Call to Action'}</button></div>
            <div class="small" style="margin-top:12px">${c.name}<br/>${c.city||''}</div>
          </div>
          <label style="margin-top:6px">Upload image
            <input type="file" class="input" data-field="finalImage" accept="image/*" />
          </label>
          <label style="margin-top:6px">Final offer/headline
            <input class="input" data-field="finalOffer" value="${draft.finalOffer||''}" />
          </label>
          <label style="margin-top:6px">Final email text
            <textarea class="input" data-field="finalEmailText">${draft.finalEmailText||''}</textarea>
          </label>
          <div class="row" style="justify-content:space-between;margin-top:8px">
            <button class="btn small secondary" data-action="flip">Back</button>
            <button class="btn small" data-action="schedule">+ Calendar</button>
          </div>
        `;
        inner.appendChild(front);
        inner.appendChild(back);
        card.appendChild(inner);
        // Bind input events for email draft fields
        card.querySelectorAll('textarea.input, input.input:not([type="file"])').forEach(inp=>{
          inp.oninput = () => {
            const f = inp.dataset.field;
            draft[f] = inp.value;
            save();
          };
        });
        // File upload for final image
        card.querySelectorAll('input[type="file"][data-field]').forEach(inp=>{
          inp.onchange = () => {
            const file = inp.files[0];
            if(file){
              const reader = new FileReader();
              reader.onload = (e) => {
                const f = inp.dataset.field;
                draft[f] = e.target.result;
                save();
                // re-render preview so the new image appears
                renderContent();
              };
              reader.readAsDataURL(file);
            }
          };
        });
        // Flip buttons
        card.querySelectorAll('button[data-action="flip"]').forEach(btn=>{
          btn.onclick = (ev) => {
            ev.stopPropagation();
            card.classList.toggle('flipped');
          };
        });
        // Schedule buttons
        card.querySelectorAll('button[data-action="schedule"]').forEach(btn=>{
          btn.onclick = (ev) => {
            ev.stopPropagation();
            assignDraftToCalendar(c, contentType, draft);
            draft.used = true;
            save();
            renderContent();
          };
        });
        // When a client is logged in, hide editing controls and disable inputs.
        if(typeof isClient === 'function' && isClient()){
          trash.style.display = 'none';
          card.querySelectorAll('button[data-action="schedule"]').forEach(b => b.style.display = 'none');
          card.querySelectorAll('textarea.input, input.input, input[type="file"][data-field]').forEach(inp=>{
            inp.setAttribute('disabled', 'disabled');
          });
        }
        // Set the set/ordinal header on the front of the card. Use the
        // package metadata to determine how many email campaigns per set.
        const headerEl = card.querySelector('.small b');
        if(headerEl){
          const meta = PKG_META[c.package || 'none'] || {};
          // Determine how many email campaigns per set from the package; fallback to 1
          const perSet = meta.emailCount || 1;
          const setIndex = Math.floor(i / perSet);
          const ordinal = (i % perSet) + 1;
          headerEl.textContent = `Set ${setIndex+1} • Email Campaign ${ordinal}`;
        }
        grid.appendChild(card);
      } else {
        // Build a standard deliverable card using the helper. Provide
        // actions for deletion, sending to filming and scheduling to calendar.
        const actions = {
          onDelete: (d) => {
            const arr = c.drafts[contentType];
            const idx = arr.indexOf(d);
            if(idx>=0){ arr.splice(idx,1); save(); renderContent(); }
          },
          onFilm: (d) => {
            assignDraftToFilming(c, contentType, d);
            d.scheduledToFilm = true;
            save(); renderContent();
          },
          onSchedule: (d) => {
            assignDraftToCalendar(c, contentType, d);
            d.used = true;
            save(); renderContent();
          }
        };
        const card = createDeliverableCard(c, contentType, draft, actions);
        // Set set/ordinal header
        const headerName = contentType==='video'? 'Video' : contentType==='photo'? 'Photo' : contentType==='carousel'? 'Carousel' : '';
        const ordinal = i + 1;
        const small = card.querySelector('.small b');
        if(small){ small.textContent = `Set ${contentSetIndex+1} • ${headerName} ${ordinal}`; }
        grid.appendChild(card);
      }
    });
    // After rendering drafts for the current set, append an add card to
    // allow creating additional deliverables. Only show this for
    // non‑website types, since websites consist of a single card.
    if(contentType !== 'website' && !isClient()){
      const addLabel = contentType==='video'?'Video':contentType==='photo'?'Photo':contentType==='carousel'?'Carousel':'Item';
      const addCard = document.createElement('div');
      addCard.className = 'card deliverable add-card';
      // Prevent the add card from stretching in the flex layout; match other cards' width.
      addCard.style.flex = '0 0 300px';
      addCard.innerHTML = `<div class="inner"><div class="front" style="display:flex;align-items:center;justify-content:center;height:100%"><div class="plus">+ Add ${addLabel}</div></div></div>`;
      addCard.onclick = (ev) => {
        ev.stopPropagation();
        // Create a blank draft based on type. Video/photo/carousel share
        // the same schema; email drafts use a different shape.
        if(!c.drafts[contentType]) c.drafts[contentType] = [];
        let newDraft;
        if(contentType === 'email'){
          newDraft = { id: uid(), offer:'', emailText:'', link:'', image:'', finalImage:'', finalOffer:'', finalEmailText:'', used:false };
        } else {
          newDraft = { id: uid(), idea:'', script:'', example:'', caption:'', finalVideo:'', finalCaption:'', used:false };
        }
        // Mark the new draft with its set index so it can be grouped
        // later. Without this, newly added drafts would be assigned to a
        // new set based solely on their order.
        newDraft.set = contentSetIndex;
        // Insert the new draft into the selected set instead of always
        // appending to the end. Determine the per‑set capacity based
        // on the package metadata and current content type. This
        // prevents Add buttons from spilling deliverables into a new
        // set when the current set still has capacity.
        const list = c.drafts[contentType];
        let insertPos = list.length;
        if(contentType !== 'website'){
          const meta = PKG_META[c.package || 'none'] || {};
          let capacity = 1;
          if(contentType === 'video') capacity = meta.videoCount || 1;
          else if(contentType === 'photo') capacity = meta.photoCount || 1;
          else if(contentType === 'carousel') capacity = meta.carouselCount || 1;
          else if(contentType === 'email') capacity = meta.emailCount || 1;
          // Count how many drafts already exist in the currently active set
          const countInSet = list.filter((_, idx) => Math.floor(idx / capacity) === contentSetIndex).length;
          insertPos = contentSetIndex * capacity + countInSet;
          if(insertPos > list.length) insertPos = list.length;
        }
        list.splice(insertPos, 0, newDraft);
        // Attempt to schedule the new draft immediately on the calendar.
        try {
          assignDraftToCalendar(c, contentType, newDraft);
        } catch(e) {}
        save(); renderContent();
      };
      grid.appendChild(addCard);
    }
    section.appendChild(grid);
    cont.appendChild(section);
  }
  $("#screen").innerHTML = '';
  // Ensure the content card does not overlap the footer by adding
  // additional bottom margin. Without this, tall deliverables can
  // spill into the footer area.
  cont.style.marginBottom = '60px';
  $("#screen").appendChild(cont);
}

// Edit or delete an existing content item. This helper is defined outside
// renderContent() so it can be referenced within the client calendar as
// well. The modal allows editing title/date/type and deleting the item.
function editContent(contentId, clientId){
  const client = state.clients[clientId];
  if(!client) return;
  const idx = client.content.findIndex(p=>p.id===contentId);
  if(idx<0) return;
  const item = client.content[idx];
  openModal(`
    <h3>Edit content</h3>
    <div class="row wrap">
      <label style="flex:1;min-width:120px">Title
        <input id="edTitle" value="${item.title}"/>
      </label>
      <label style="flex:1;min-width:120px">Date
        <input id="edDate" type="date" value="${item.date}"/>
      </label>
      <label style="flex:1;min-width:120px">Type
        <select id="edType">
          <option value="video" ${item.type==='video'?'selected':''}>Video</option>
          <option value="photo" ${item.type==='photo'?'selected':''}>Photo</option>
          <option value="carousel" ${item.type==='carousel'?'selected':''}>Carousel</option>
        </select>
      </label>
    </div>
    <div class="row right" style="margin-top:12px">
      <button class="btn secondary" id="edCancel">Cancel</button>
      <button class="btn danger" id="edDel">Delete</button>
      <button class="btn" id="edSave">Save</button>
    </div>
  `, ()=>{
    $("#edCancel").onclick = closeModal;
    $("#edSave").onclick = ()=>{
      item.title = $("#edTitle").value.trim() || 'Untitled';
      item.date  = $("#edDate").value;
      item.type  = $("#edType").value.trim();
      save(); closeModal(); render();
    };
    $("#edDel").onclick = ()=>{
      client.content.splice(idx,1);
      save(); closeModal(); render();
    };
  });
}
let activeClientId = Object.keys(state.clients)[0]||null;

/*** EMPLOYEES ***/
function renderEmployees(){
  const cont = document.createElement("div");
  const box = document.createElement("div"); box.className="card";
  box.innerHTML = `<h3>Team</h3>`;
  cont.appendChild(box);

  const list = document.createElement("div");
  list.className="list";
  Object.values(state.users).forEach(u=>{
    const card = document.createElement("div");
    card.className="card";
    const daysOrder=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    card.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <div class="row"><div class="badge" style="background:#1a1f33">${u.role.toUpperCase()}</div>&nbsp;<b>${u.name}</b></div>
        <div class="row"><button class="btn small secondary" data-id="${u.id}">Edit</button> ${u.id==='u-OWNER'?'':`<button class="btn small danger" data-del="${u.id}">Remove</button>`}</div>
      </div>
      <div class="small">Days: ${daysOrder.filter(d=>u.days[d]).join(', ')} • Hours/day: ${u.hoursPerDay} • Start: ${u.start}</div>
      <div class="small">Skills: ${u.skills.join(', ')||'—'}</div>
    `;
    list.appendChild(card);
  });

  // add employee
  const add = document.createElement("div");
  add.className="card";
  add.innerHTML = `
    <h3>Add employee</h3>
    <div class="row wrap">
      <input id="eName" placeholder="Full name" />
      <label>Role
        <select id="eRole">
          <option value="employee">Employee</option>
          <option value="sales">Sales</option>
        </select>
      </label>
      <label>Hours/day <input id="eHours" type="number" value="8" min="1" max="16"/></label>
      <label>Start <input id="eStart" type="time" value="09:00"/></label>
      <div class="row small">Days</div>
      ${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"].map(d=>`<label><input type="checkbox" id="d${d}" ${d!=="Sun"&&d!=="Sat"?"checked":""}/> ${d}</label>`).join("")}
      <div class="row wrap">Skills: ${["script","film","photo","edit","website","emailphone","sales"].map(s=>`<label><input type="checkbox" id="sk_${s}" ${s!=="sales"?"checked":""}/> ${s}</label>`).join("")}</div>
      <button class="btn" id="addEmp">Add</button>
    </div>
  `;

  cont.appendChild(list);
  cont.appendChild(add);

  // Auto-check/uncheck skill boxes based on selected role. Sales
  // employees should only have the sales skill enabled, while
  // regular employees start with all skills checked. Hook the role
  // dropdown change event to update skill checkboxes accordingly.
  setTimeout(() => {
    const roleSel = document.getElementById('eRole');
    if(roleSel){
      roleSel.onchange = () => {
        const isSales = roleSel.value === 'sales';
        ["script","film","photo","edit","website","emailphone"].forEach(s=>{
          const cb = document.getElementById('sk_'+s);
          if(cb) cb.checked = !isSales;
        });
        const salesCb = document.getElementById('sk_sales');
        if(salesCb) salesCb.checked = true;
      };
      // trigger initial state
      roleSel.onchange();
    }
  });

  list.onclick=(e)=>{
    if(e.target.matches("[data-id]")){
      const id = e.target.dataset.id; const u=state.users[id];
      openModal(`
        <h3>Edit Employee</h3>
        <div class="row wrap">
          <label>Name <input id="uName" value="${u.name}"/></label>
          <label>Role <select id="uRole"><option value="employee" ${u.role==='employee'?'selected':''}>Employee</option><option value="sales" ${u.role==='sales'?'selected':''}>Sales</option><option value="owner" ${u.role==='owner'?'selected':''}>Owner</option></select></label>
          <label>Hours/day <input id="uHours" type="number" value="${u.hoursPerDay}"/></label>
          <label>Start <input id="uStart" type="time" value="${u.start}"/></label>
          <div class="row small">Days</div>
          ${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"].map(d=>`<label><input type="checkbox" id="u${d}" ${u.days[d]?'checked':''}/> ${d}</label>`).join("")}
          <div class="row wrap">Skills: ${["script","film","photo","edit","website","emailphone","sales"].map(s=>`<label><input type="checkbox" id="usk_${s}" ${u.skills.includes(s)?'checked':''}/> ${s}</label>`).join("")}</div>
        </div>
        <div class="row right"><button class="btn secondary" id="cx">Cancel</button><button class="btn" id="sv">Save</button></div>
      `, ()=>{
        $("#cx").onclick=closeModal;
        // Auto adjust skills based on role in edit modal
        const roleSelect = $("#uRole");
        const updateSkills = () => {
          const isSales = roleSelect.value === 'sales';
          ["script","film","photo","edit","website","emailphone"].forEach(s=>{
            const cb = document.getElementById('usk_'+s);
            if(cb) cb.checked = !isSales;
          });
          const salesCb = document.getElementById('usk_sales');
          if(salesCb) salesCb.checked = true;
        };
        if(roleSelect){ roleSelect.onchange = updateSkills; /* run once */ updateSkills(); }
        $("#sv").onclick=()=>{
          u.name=$("#uName").value;
          u.role=$("#uRole").value;
          u.hoursPerDay=Number($("#uHours").value);
          u.start=$("#uStart").value;
          ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"].forEach(d=>u.days[d] = $("#u"+d).checked?1:0);
          const newSkills = ["script","film","photo","edit","website","emailphone","sales"].filter(s=>$("#usk_"+s).checked);
          u.skills = newSkills;
          // After updating skills, reassign tasks to ensure employees only
          // hold tasks they are qualified for
          reassignTasks(u.id);
          save(); closeModal(); render();
        };
      });
    }
    if(e.target.matches("[data-del]")){
      const id=e.target.dataset.del;
      openModal(`<h3>Remove ${state.users[id].name}?</h3><div class="row right"><button class="btn secondary" id="c">Cancel</button><button class="btn danger" id="d">Remove</button></div>`,()=>{
        $("#c").onclick=closeModal;
        $("#d").onclick=()=>{ delete state.users[id]; save(); closeModal(); render(); };
      });
    }
  };

  $("#addEmp", add).onclick=()=>{
    const id = uid();
    state.users[id] = {
      id, name:$("#eName").value||"New Member", role:$("#eRole").value,
      skills:["script","film","photo","edit","website","emailphone","sales"].filter(s=>$("#sk_"+s).checked),
      days: Object.fromEntries(["Sun","Mon","Tue","Wed","Thu","Fri","Sat"].map(d=>[d, $("#d"+d).checked?1:0])),
      hoursPerDay:Number($("#eHours").value)||8,
      start:$("#eStart").value||"09:00"
    };
    save(); render();
  };

  $("#screen").innerHTML="";
  $("#screen").appendChild(cont);
}

/*** SALES ***/
function renderSales(){
  const cont = document.createElement("div");
  const top = document.createElement("div"); top.className="grid3";

  // left: add lead. Include a salesperson dropdown so leads can be
  // assigned to any salesperson or employee. By default the current
  // user is selected. Build options from all users who are not
  // clients. This ensures owners, salespeople and employees can be
  // chosen when creating a lead. The options string is assembled
  // prior to injecting into the HTML template to avoid breaking
  // template literals.
  const add = document.createElement("div"); add.className="card";
  const leadSalesOptions = Object.values(state.users)
    .filter(u => u.role && u.role !== 'client')
    .map(u => `<option value="${u.id}" ${u.id === state.currentUserId ? 'selected' : ''}>${u.name}</option>`)
    .join("");
  add.innerHTML = `
    <h3>New lead</h3>
    <div class="row wrap">
      <input id="sName" placeholder="Company name" />
      <input id="sCity" placeholder="City" />
      <div class="row"><div class="small">Talked to owner?</div>&nbsp;<label class="switch"><input id="sTalk" type="checkbox"/><span></span></label></div>
      <div class="row wrap">Interested in:
        ${["website","email","phone"].map(s=>`<label><input type="checkbox" id="int_${s}"/> ${s.charAt(0).toUpperCase()+s.slice(1)}</label>`).join("")}
      </div>
      <div class="row"><div class="small">Interested?</div>&nbsp;<label class="switch"><input id="sInterest" type="checkbox"/><span></span></label></div>
      <label>Package
        <select id="sPkg">
          <option value="">—</option>
          <option value="trial">Trial ($${state.prices.trial})</option>
          <option value="mini">Regular ($${state.prices.mini})</option>
          <option value="medium">Medium ($${state.prices.medium})</option>
          <option value="large">Large ($${state.prices.large})</option>
          <option value="none">Website only ($${state.prices.website})</option>
        </select>
      </label>
      <label>Salesperson
        <select id="sSales">${leadSalesOptions}</select>
      </label>
      <div class="row"><button class="btn small secondary" id="fup">+7d Follow-up</button><button class="btn" id="addLead">Add</button></div>
    </div>
  `;

  // middle: leads list
  const list = document.createElement("div"); list.className="card";
  // Allow horizontal scrolling of the leads table when there are many action
  // buttons. Without overflow set the last column may be clipped on
  // smaller screens.
  list.style.overflowX = 'auto';
  list.innerHTML = `<h3>Leads</h3>
    <table class="table" id="leadsTbl" style="width:100%; min-width:600px;">
      <thead><tr><th>Company</th><th>City</th><th>Interested?</th><th>Package</th><th>Next follow-up</th><th></th></tr></thead>
      <tbody></tbody>
    </table>`;

  // right: revenue graphs (total and per-salesperson)
  const rev = document.createElement("div"); rev.className="card";
  // build salesperson select options. Include any user that is not a client so
  // employees, editors, salespeople and the owner can be selected. Clients
  // (which are stored separately in state.clients) are excluded here.
  const salesPeople = Object.values(state.users).filter(u => u.role && u.role !== 'client');
  // Move the current user to the front of the options for convenience, but
  // always mark the selected option explicitly so the dropdown reflects the
  // person currently signed in. Without an explicit selected attribute the
  // browser may default to the first option, causing the chart to stick on
  // whoever appears first in the list.
  const curIdx = salesPeople.findIndex(u=>u.id===state.currentUserId);
  if(curIdx>0){ const cur = salesPeople.splice(curIdx,1)[0]; salesPeople.unshift(cur); }
  let salesOptions = salesPeople.map(u=>`<option value="${u.id}" ${u.id===state.currentUserId? 'selected' : ''}>${u.name}</option>`).join("");
  // Create month navigation for revenue charts. The revenue section now
  // displays data for a single month at a time with arrows to move
  // forward or backward. The selected month and year are displayed
  // between the arrows.
  rev.innerHTML = `
    <h3>Revenue</h3>
    <div class="${canSeeRevenue()?'':'small'}">${canSeeRevenue()? 'Monthly revenue (won deals + clients)' : 'Restricted by role'}</div>
    ${canSeeRevenue() ? '' : ''}
    <div class="row wrap" style="justify-content:space-between;align-items:center;margin-bottom:6px">
      <button class="btn small ghost" id="revPrev" style="min-width:40px;padding:8px 12px;font-size:18px;position:relative;z-index:10;pointer-events:auto;">‹</button>
      <!-- Month picker allows navigating months reliably when arrow buttons fail -->
      <input type="month" id="revPicker" value="${(state.revYear != null ? state.revYear : new Date().getFullYear())}-${String(((state.revMonth != null ? state.revMonth : new Date().getMonth())+1)).padStart(2,'0')}" style="flex:1;text-align:center;background:transparent;border:none;color:inherit;font-weight:bold;max-width:130px"/>
      <button class="btn small ghost" id="revNext" style="min-width:40px;padding:8px 12px;font-size:18px;position:relative;z-index:10;pointer-events:auto;">›</button>
    </div>
    <div class="canvas" id="revCanvas"></div>
    <div class="small" id="revTotal"></div>
    <h3 style="margin-top:20px">My sales</h3>
    <div class="row wrap" style="align-items:center;margin-bottom:6px">
      <label class="small">Salesperson </label>
      <select id="salesPersonSelect">${salesOptions}</select>
    </div>
    <div class="canvas" id="revPersonCanvas"></div>
    <div class="small" id="revPersonTotal"></div>
    <!-- Commission input removed. Commission percentage is now defined in settings and cannot be edited here. -->
  `;

  top.appendChild(add); top.appendChild(list); top.appendChild(rev);
  cont.appendChild(top);
  // Ensure revenue mode chips are wired after the revenue section is inserted
  try { wireRevMode(); } catch(e) { /* ignore if function not defined */ }

  // populate leads table
  function drawLeads(){
    const tb = $("#leadsTbl tbody", list); tb.innerHTML="";
    const assignee = visibleAssigneeId();
    // show leads for the selected salesperson only. When viewing as
    // "Team (All)" (assignee=null) show every lead.
    let rowIndex = 0;
    state.leads.forEach((L,idx)=>{
      if(assignee && L.salespersonId !== assignee) return;
      const tr = document.createElement("tr");
      tr.innerHTML = `<td data-name="${idx}" style="cursor:pointer">${L.name}</td><td data-city="${idx}" style="cursor:pointer">${L.city||''}</td>
        <td class="small" data-int="${idx}" style="cursor:pointer">${L.interestedBool?'Yes':'No'}</td>
        <td data-pkg="${idx}" style="cursor:pointer">${L.package || '—'}</td>
        <td data-follow="${idx}" style="cursor:pointer">${L.nextFollow||'—'}</td>
        <td style="white-space:nowrap; padding:4px 0; min-width:160px">
          <div style="display:flex; align-items:center; gap:4px; justify-content:flex-start; flex-wrap:nowrap; overflow:hidden;">
            <button class="btn small secondary" data-fu="${idx}">+7d</button>
            <button class="btn small ok" style="background:var(--ok)" data-won="${idx}">Won</button>
            <button class="btn small danger" data-del="${idx}">🗑</button>
          </div>
        </td>`;
      tb.appendChild(tr);
      rowIndex++;
    });
  }
  drawLeads();

  list.onclick=(e)=>{
    // Edit company name or city inline when clicking on them
    if(e.target.matches('td[data-name]')){
      const idx = Number(e.target.dataset.name);
      const L = state.leads[idx];
      openModal(`
        <h3>Edit company name</h3>
        <input id="newName" value="${L.name}" style="width:100%"/>
        <div class="row right" style="margin-top:12px"><button class="btn secondary" id="nCancel">Cancel</button><button class="btn" id="nSave">Save</button></div>
      `, ()=>{
        $("#nCancel").onclick = closeModal;
        $("#nSave").onclick = ()=>{
          L.name = $("#newName").value || L.name;
          save(); closeModal(); drawLeads();
        };
      });
      return;
    }
    if(e.target.matches('td[data-city]')){
      const idx = Number(e.target.dataset.city);
      const L = state.leads[idx];
      openModal(`
        <h3>Edit city</h3>
        <input id="newCity" value="${L.city||''}" style="width:100%"/>
        <div class="row right" style="margin-top:12px"><button class="btn secondary" id="cCancel">Cancel</button><button class="btn" id="cSave">Save</button></div>
      `, ()=>{
        $("#cCancel").onclick = closeModal;
        $("#cSave").onclick = ()=>{
          L.city = $("#newCity").value;
          save(); closeModal(); drawLeads();
        };
      });
      return;
    }
    // Toggle interested yes/no when clicking the interested cell
    if(e.target.matches("td[data-int]")){
      const idx = Number(e.target.dataset.int);
      const L = state.leads[idx];
      L.interestedBool = !L.interestedBool;
      save(); drawLeads();
      return;
    }
    // open date picker to adjust follow-up when clicking the next follow-up cell
    if(e.target.matches("td[data-follow]")){
      const idx = Number(e.target.dataset.follow);
      const L = state.leads[idx];
      openModal(`
        <h3>Set next follow-up for ${L.name}</h3>
        <div class="row wrap">
          <label style="flex:1;min-width:140px">Next follow-up
            <input id="fuDate" type="date" value="${L.nextFollow||todayStr()}"/>
          </label>
        </div>
        <div class="row right" style="margin-top:12px"><button class="btn secondary" id="fuCancel">Cancel</button><button class="btn" id="fuSave">Save</button></div>
      `, () => {
        $("#fuCancel").onclick = closeModal;
        $("#fuSave").onclick = () => {
          const newDate = $("#fuDate").value;
          L.nextFollow = newDate;
          save(); closeModal(); drawLeads();
          // also schedule a follow-up task for salesperson on selected date
          if(newDate){
            const followTask = makeTask(null, `Follow-up: ${L.name}`, newDate, state.users[state.currentUserId]?.start||'09:00', 0.5, 'N', {});
            followTask.assigneeId = L.salespersonId || state.currentUserId;
            state.tasks.push(followTask);
            save();
          }
        };
      });
      return;
    }

    // edit package when clicking the package cell. Allow changing the
    // interested package for a lead prior to conversion. Presents a
    // select with available packages and updates the lead on save.
    if(e.target.matches('td[data-pkg]')){
      const idx = Number(e.target.dataset.pkg);
      const L = state.leads[idx];
      openModal(`
        <h3>Edit package for ${L.name}</h3>
        <div class="row wrap">
          <label style="flex:1;min-width:140px">Package
            <select id="editPkg">
              <option value="">—</option>
              <option value="trial" ${L.package==='trial'?'selected':''}>Trial ($${state.prices.trial})</option>
              <option value="mini" ${L.package==='mini'?'selected':''}>Regular ($${state.prices.mini})</option>
              <option value="medium" ${L.package==='medium'?'selected':''}>Medium ($${state.prices.medium})</option>
              <option value="large" ${L.package==='large'?'selected':''}>Large ($${state.prices.large})</option>
              <option value="none" ${L.package==='none'?'selected':''}>Website only ($${state.prices.website})</option>
            </select>
          </label>
        </div>
        <div class="row right" style="margin-top:12px"><button class="btn secondary" id="pkgCancel">Cancel</button><button class="btn" id="pkgSave">Save</button></div>
      `, ()=>{
        $("#pkgCancel").onclick = closeModal;
        $("#pkgSave").onclick = ()=>{
          L.package = $("#editPkg").value;
          save(); closeModal(); drawLeads();
        };
      });
      return;
    }
    if(e.target.matches("[data-fu]")){
      const i = Number(e.target.dataset.fu); const L=state.leads[i];
      L.nextFollow = addDays(todayStr(), 7);
      // schedule follow-up task for same salesperson
      const fuDate = L.nextFollow;
      const followTask = makeTask(null, `Follow-up: ${L.name}`, fuDate, state.users[state.currentUserId]?.start||'09:00', 0.5, 'N', {});
      followTask.assigneeId = L.salespersonId || state.currentUserId;
      state.tasks.push(followTask);
      save(); drawLeads();
    }
    if(e.target.matches("[data-del]")){
      const i = Number(e.target.dataset.del);
      const L = state.leads[i];
      // If this lead was converted to a client, also remove the client and any
      // corresponding wonLead record. This ensures the revenue graph
      // updates correctly when the lead is deleted.
      if(L && L.clientId){
        const cid = L.clientId;
        if(state.clients[cid]) delete state.clients[cid];
        // remove won lead referencing this client
        if(Array.isArray(state.wonLeads)){
          state.wonLeads = state.wonLeads.filter(w => w.clientId !== cid);
        }
        // remove tasks associated with the client
        state.tasks = state.tasks.filter(t => t.clientId !== cid);
      }
      state.leads.splice(i,1);
      save(); drawLeads(); drawRevenue(); drawPersonRevenue();
      return;
    }
    if(e.target.matches("[data-won]")){
      const i = Number(e.target.dataset.won); const L=state.leads[i];
      // Convert to client
      openModal(`
        <h3>Mark won • ${L.name}</h3>
        <div class="row wrap">
          <label>Package
            <select id="wPkg">
              <option value="trial" ${L.package==='trial'?'selected':''}>Trial ($${state.prices.trial})</option>
              <option value="mini" ${L.package==='mini'?'selected':''}>Regular ($${state.prices.mini})</option>
              <option value="medium" ${L.package==='medium'?'selected':''}>Medium ($${state.prices.medium})</option>
              <option value="large" ${L.package==='large'?'selected':''}>Large ($${state.prices.large})</option>
              <option value="none" ${L.package==='none'?'selected':''}>Website only ($${state.prices.website})</option>
            </select>
          </label>
          <label>Onboard <input id="wOn" type="date" value="${todayStr()}"/></label>
          <div class="row">Add-ons: <label><input type="checkbox" id="wWeb"/> Website</label><label><input type="checkbox" id="wEmail"/> Email</label><label><input type="checkbox" id="wPhone"/> Phone</label></div>
          <label>Deal price ($) <input id="wPrice" type="number" value="${state.prices[L.package || 'trial']}"/></label>
        </div>
        <div class="row right"><button class="btn secondary" id="cx">Cancel</button><button class="btn" id="ok">Convert</button></div>
      `, ()=>{
        $("#cx").onclick=closeModal;
        // When the package selection changes, update the price field to reflect the
        // default price of the selected package. This ensures the deal
        // price matches the chosen package unless manually edited.
        const pkgSelect = document.getElementById('wPkg');
        const priceInput = document.getElementById('wPrice');
        if(pkgSelect && priceInput){
          pkgSelect.onchange = () => {
            const sel = pkgSelect.value;
            priceInput.value = state.prices[sel] || 0;
          };
        }
        $("#ok").onclick=()=>{
          const id = uid();
          const pkg = $("#wPkg").value;
          // Capture the price and salesperson on the client record so
          // revenue calculations can use the actual deal value rather
          // than defaulting to a package price. Assign salespersonId
          // to keep track of who closed the deal.
          const dealPrice = Number($("#wPrice").value) || state.prices[pkg] || 0;
          // Initialize client login credentials. Do not set a default password or
          // username here; these will be assigned by the owner in Settings. A
          // blank username or password means the client cannot log in until
          // credentials are set.
          state.clients[id] = {
            id,
            name: L.name,
            city: L.city,
            onboard: $("#wOn").value,
            package: pkg,
            addons: { website: $("#wWeb").checked, email: $("#wEmail").checked, phone: $("#wPhone").checked },
            start: "09:00",
            content: [],
            price: dealPrice,
            // Always credit the salesperson who closes the deal (the current user)
            salespersonId: state.currentUserId,
            // Username and password will be set by the owner later. Leave
            // blank initially to prevent unauthorized logins.
            username: '',
            password: ''
          };
          // revenue entry
          L.price = Number($("#wPrice").value)||state.prices[pkg]||0;
          L.wonOn = todayStr();
          L.clientId = id;
          // Update lead's salesperson to the current user so follow‑up tasks are assigned correctly
          L.salespersonId = state.currentUserId;
          // create work schedule and content posts
          scheduleClientMonths(state.clients[id]);
          if(typeof scheduleContentPosts === 'function') scheduleContentPosts(state.clients[id]);
          // preserve the won lead in a separate list for revenue tracking
          state.wonLeads ||= [];
          state.wonLeads.push({
            id: uid(),
            name: L.name,
            city: L.city,
            price: Number($("#wPrice").value)||state.prices[pkg]||0,
            wonOn: todayStr(),
            // Always credit the salesperson who closes the deal
            salespersonId: state.currentUserId,
            clientId: id
          });
          // remove lead from active leads list
          state.leads.splice(i,1);
          save(); closeModal(); render();
        };
      });
    }
  };

  // add lead events
  $("#addLead", add).onclick=()=>{
    // Determine the salesperson to assign based on the dropdown. If the
    // dropdown does not exist or has no value (fallback), assign to the
    // current user. This allows any employee or owner to submit a lead
    // on behalf of another salesperson.
    const spSel = document.getElementById('sSales');
    const selectedSalesperson = spSel && spSel.value ? spSel.value : state.currentUserId;
    const L = {
      id:uid(),
      name:$("#sName").value||"Lead",
      city:$("#sCity").value||"",
      talked:$("#sTalk").checked,
      // capture selected services only (packages are chosen separately)
      services:["website","email","phone"].filter(s=>$("#int_"+s).checked),
      package:$("#sPkg").value||"",
      nextFollow:null,
      created:todayStr(),
      interestedBool: $("#sInterest").checked,
      // assign the selected salesperson for this lead. This property
      // determines who will follow up and collect commission if the
      // lead converts.
      salespersonId: selectedSalesperson
    };
    state.leads.unshift(L); save(); render();
  };
  $("#fup", add).onclick=()=>{
    alert("Add the lead first, then use +7d on the row.");
  };
  // Remove ability to change commission percentage from the sales page. Commission
  // is configured in settings and cannot be edited here.

  // Keep track of the currently selected month and year for revenue charts.
  // Persist these values on state so month navigation remains consistent across re-renders.
  if(typeof state.revYear !== 'number' || typeof state.revMonth !== 'number'){
    state.revYear = new Date().getFullYear();
    state.revMonth = new Date().getMonth();
  }
  let revYear = state.revYear;
  let revMonth = state.revMonth;
  // revenue chart for the business. Displays revenue on a per‑day basis
  // for the selected month. Includes revenue from client onboarding
  // (deal price) and won leads that have not yet converted into clients.
function old_drawRevenue(){
    // Determine the month/year to render.  Use explicit checks to allow 0 (January).
    const revYear = (state.revYear !== undefined && state.revYear !== null) ? state.revYear : new Date().getFullYear();
    const revMonth = (state.revMonth !== undefined && state.revMonth !== null) ? state.revMonth : new Date().getMonth();
    const cvs = $("#revCanvas", cont);
    if(!cvs) return;
    // Reset the canvas for a fresh render
    cvs.innerHTML = '';
    // Update title
    const titleEl = document.getElementById('revTitle');
    if(titleEl){ titleEl.textContent = `${MONTHS[revMonth]} ${revYear}`; }
    // Permission check
    if(!canSeeRevenue()){ return; }
    // Compute days in this month
    const daysInMonth = new Date(revYear, revMonth + 1, 0).getDate();
    // Prepare an array to accumulate revenue per day
    const dayTotals = Array(daysInMonth).fill(0);
    // Build date boundaries for the current month
    const monthStart = new Date(revYear, revMonth, 1);
    const monthEnd   = new Date(revYear, revMonth, daysInMonth);
    // Scan payment tasks
    if(Array.isArray(state.tasks)){
      state.tasks.forEach(t => {
        if(!t || t.name !== 'Payment due' || !t.date) return;
        const d = toDate(t.date);
        if(!(d instanceof Date) || isNaN(d.getTime())) return;
        // Only include tasks that fall within this calendar month
        if(d < monthStart || d > monthEnd) return;
        // Determine if this payment falls within the client’s contract window
        let include = true;
        let amt = Number(t.meta && t.meta.amount) || 0;
        if(t.clientId && state.clients && state.clients[t.clientId]){
          const c = state.clients[t.clientId];
          // Baseline months from the package; used to cap revenue
          const pkg = PKG_META && PKG_META[c.package || 'none'];
          const baseline = (pkg && pkg.months) ? pkg.months : 0;
          if(baseline > 0 && c.onboard){
            const onboardDate = toDate(c.onboard);
            if(onboardDate instanceof Date && !isNaN(onboardDate.getTime())){
              const maxPayments = baseline * 2;
              const lastPaymentDate = addDays(onboardDate, 14 * (maxPayments - 1));
              if(d > lastPaymentDate){ include = false; }
            }
          }
        }
        if(include){
          const idx = d.getDate() - 1;
          if(idx >= 0 && idx < dayTotals.length){ dayTotals[idx] += amt; }
        }
      });
    }
    // Include revenue from won leads (one‑time payments on their win date) for this month
    if(Array.isArray(state.wonLeads)){
      state.wonLeads.forEach(L => {
        if(!L.wonOn) return;
        if(L.clientId && state.clients && state.clients[L.clientId]) return;
        const d = toDate(L.wonOn);
        if(!(d instanceof Date) || isNaN(d.getTime())) return;
        if(d.getFullYear() !== revYear || d.getMonth() !== revMonth) return;
        const idx = d.getDate() - 1;
        if(idx >= 0 && idx < dayTotals.length){ dayTotals[idx] += Number(L.price) || 0; }
      });
    }
    // Determine maximum daily revenue for scaling
    const maxVal = dayTotals.length > 0 ? Math.max(...dayTotals) : 0;
    // Construct bar chart container
    const barContainer = document.createElement('div');
    barContainer.style.display = 'flex';
    barContainer.style.alignItems = 'flex-end';
    barContainer.style.height = '100px';
    barContainer.style.borderBottom = '1px solid var(--border, #333)';
    barContainer.style.marginBottom = '4px';
    barContainer.style.gap = '1px';
    // Create a bar for each day
    for(let i=0; i<daysInMonth; i++){
      const val = dayTotals[i];
      const bar = document.createElement('div');
      bar.style.flex = '1 1 0';
      bar.style.height = (maxVal > 0 ? (val / maxVal * 100).toFixed(2) : 0) + '%';
      bar.style.background = val > 0 ? '#3a77ff' : 'transparent';
      if(val > 0){
        bar.style.cursor = 'pointer';
        bar.onclick = () => { openPaymentDetails(revYear, revMonth, i + 1); };
      }
      barContainer.appendChild(bar);
    }
    // Create x‑axis label row (1..daysInMonth)
    const xLabels = document.createElement('div');
    xLabels.style.display = 'flex';
    xLabels.style.fontSize = '10px';
    xLabels.style.color = 'var(--fg, #888)';
    xLabels.style.marginTop = '2px';
    for(let i=0; i<daysInMonth; i++){
      const lbl = document.createElement('div');
      lbl.style.flex = '1 1 0';
      lbl.style.textAlign = 'center';
      lbl.textContent = (i + 1).toString();
      xLabels.appendChild(lbl);
    }
    // Append bars and labels to canvas
    cvs.appendChild(barContainer);
    cvs.appendChild(xLabels);
    // Update total revenue label
    let totalEl = document.getElementById('revTotal');
    if(!totalEl){ totalEl = document.createElement('div'); totalEl.id = 'revTotal'; cvs.appendChild(totalEl); }
    totalEl.style.position = 'relative';
    totalEl.style.marginTop = '4px';
    totalEl.style.fontSize = '12px';
    totalEl.style.color = 'var(--fg, #fff)';
    totalEl.style.textAlign = 'right';
    const monthTotal = dayTotals.reduce((acc,v) => acc + v, 0);
    totalEl.textContent = `$${monthTotal.toLocaleString()}`;
    return;
    // revenue from clients: schedule biweekly payments based on package months.
    // Instead of crediting the full deal price on the onboard day, we
    // distribute revenue into half‑payments every 14 days for each phase.
    // The number of phases is determined by the package metadata and any
    // additional phases created via auto‑scheduling (tasks with meta.phase).
    Object.values(state.clients).forEach(c => {
      // skip leads still in leads list
      if(state.leads.some(L => L.clientId === c.id)) return;
      if(!c.onboard) return;
      // Determine the deal price. If the client record has no price set (or zero),
      // fall back to the package price defined in state.prices. This ensures
      // revenue calculations still work when the owner does not explicitly
      // enter a price on the client record. A zero or undefined price will
      // default to the package price, if available.
      let price = Number(c.price);
      if(!price){ price = (state.prices && state.prices[c.package]) || 0; }
      if(price <= 0) return;
      // Determine how many months of service this client has been scheduled for.
      // Use the package months as a baseline and then extend based on actual
      // content posts. Previously we used the maximum phase across tasks which
      // could include unrelated tasks and lead to revenue being credited
      // indefinitely into the past or future. Instead, compute additional
      // months based on the dates of the client’s scheduled content posts.
      let pkgMonths = 0;
      if(PKG_META && PKG_META[c.package||"none"]){
        pkgMonths = PKG_META[c.package||"none"].months || 0;
      }
      // Compute extra months by examining the client.content array. Each
      // post is scheduled relative to the startPosting date (onboard + 28 days).
      // The difference between a post date and the base posting date divided
      // by 28 days yields the month index. The largest month index + 1 is
      // the number of extra months beyond the package baseline. Only count
      // posts of known content types (video, photo, carousel, email). Use
      // toDate instead of parseDate to handle ISO strings and Date instances
      // robustly. See user feedback about revenue persisting across years.
      // Extra months beyond the baseline package are determined by
      // examining how far the client's content extends. We track the
      // maximum month index of any scheduled post (relative to the
      // first posting month) and then subtract the baseline number
      // of package months. For example, if a six‑month package has
      // posts scheduled into the seventh month (index=6), the
      // extraMonths becomes 1 (7 total months of content minus 6
      // package months). If all posts fall within the baseline
      // months, extraMonths remains 0.
      let maxPostIdx = -1;
      if(Array.isArray(c.content) && c.onboard){
        const basePostingDate = toDate(addDays(c.onboard, 28));
        const baseMs = basePostingDate instanceof Date ? basePostingDate.getTime() : NaN;
        if(!isNaN(baseMs)){
          c.content.forEach(p => {
            if(!p || !p.date) return;
            const type = p.type;
            // Only consider primary content types; ignore website posts
            if(type === 'video' || type === 'photo' || type === 'carousel' || type === 'email'){
              const d = toDate(p.date);
              if(!(d instanceof Date) || isNaN(d.getTime())) return;
              const diff = d.getTime() - baseMs;
              // Only consider posts scheduled on or after the base posting date
              if(diff >= 0){
                const idx = Math.floor(diff / (28 * 86400000));
                if(idx >= 0){
                  if(idx > maxPostIdx) maxPostIdx = idx;
                }
              }
            }
          });
        }
      }
      let extraMonths = 0;
      if(maxPostIdx >= 0){
        const postsMonths = maxPostIdx + 1;
        extraMonths = Math.max(0, postsMonths - pkgMonths);
      }
      // Determine the total number of billing months. Start with the
      // package-defined months and *add* any additional months implied
      // by scheduled content posts. A package with six months and two
      // extra scheduled months should generate revenue for eight
      // months (6+2), not just six. When both values sum to zero,
      // the revenue reduces to a single payment on the onboard date.
      let totalMonths = pkgMonths + extraMonths;
      if(!totalMonths || totalMonths < 0){ totalMonths = 0; }
      // If no months configured, credit full price on onboard date as before
      if(totalMonths <= 0){
        // If there are no months defined, treat the entire price as a single
        // payment on the onboard date. Use toDate for robust parsing of
        // ISO strings and return early if the date is invalid.
        const d = toDate(c.onboard);
        if(d instanceof Date && !isNaN(d.getTime())){
          if(d.getFullYear() === revYear && d.getMonth() === revMonth){
            const dayIndex = d.getDate() - 1;
            totals[dayIndex] += price;
          }
        }
        return;
      }
      // If this client has defined package months, clamp revenue to the
      // contract window before iterating through phases. Compute the
      // start and end of the requested revenue month and compare it
      // against the contract range. If the entire month falls outside
      // the contract, skip this client entirely. This prevents
      // lingering payments from showing up years after onboarding.
      if(totalMonths > 0){
        const baseDate = toDate(c.onboard);
        if(baseDate instanceof Date && !isNaN(baseDate.getTime())){
          const revMonthStart = new Date(revYear, revMonth, 1);
          const revMonthEnd = new Date(revYear, revMonth + 1, 0);
          const contractEndDate = toDate(addDays(baseDate, (totalMonths - 1) * 28 + 14));
          if(contractEndDate instanceof Date && !isNaN(contractEndDate.getTime())){
            if(revMonthStart.getTime() > contractEndDate.getTime() || revMonthEnd.getTime() < baseDate.getTime()){
              // Entire month is outside the contract window
              return;
            }
          }
        }
      }
      // Distribute revenue into two half‑payments for each scheduled
      // month (phase). Each phase spans 28 days from the onboard date
      // and yields a payment on the phase start and 14 days later.
      // Clamp all payments to fall between the client’s onboard date
      // and the last half‑payment date. Without this clamp,
      // auto‑scheduling more sets could leak payments into months
      // before onboarding or long after the contracted term. The
      // commission logic below mirrors this same approach.
      const paymentAmount = price / 2;
      // Robustly parse the onboard date. If the stored value includes
      // a time component or is otherwise invalid for parseDate, use
      // toDate to handle ISO strings and Date instances. Skip this
      // client entirely if the onboard date cannot be parsed.
      const base = toDate(c.onboard);
      if(!(base instanceof Date) || isNaN(base.getTime())){
        return;
      }
      // Compute a time range for valid payments. The first payment
      // occurs on the onboard date. The final half‑payment occurs
      // 14 days after the start of the last phase. If totalMonths is
      // 0 this code path is skipped above, so it's safe to assume
      // totalMonths > 0 here.
      const startTime = base.getTime();
      // Use a string for addDays to avoid mutating the Date object. Passing a
      // Date directly to addDays will update it in place, which leads to
      // incorrect phase calculations across iterations. See issue about
      // revenue leaking into later months.
      const endPhaseStartStr = addDays(fmtDate(base), (totalMonths - 1) * 28);
      // Use toDate on strings returned from addDays to avoid parseDate
      // failures on unexpected formats. parseDate handles YYYY‑MM‑DD
      // but may return NaN for other strings, so fallback here as
      // well.
      const endPhaseStart = toDate(endPhaseStartStr);
      const endHalfDateStr = addDays(endPhaseStartStr, 14);
      const endHalfDate = toDate(endHalfDateStr);
      const endTime = endHalfDate ? endHalfDate.getTime() : NaN;
      for(let m=0; m < totalMonths; m++){
        // Pass a string to addDays to prevent mutation of the base date
        const phaseStartStr = addDays(fmtDate(base), m * 28);
        const phaseStart = toDate(phaseStartStr);
        // Skip this payment if the phase start could not be parsed.
        if(phaseStart && !isNaN(phaseStart.getTime())){
          const phaseTime = phaseStart.getTime();
          if(phaseTime >= startTime && phaseTime <= endTime){
            if(phaseStart.getFullYear() === revYear && phaseStart.getMonth() === revMonth){
              totals[phaseStart.getDate() - 1] += paymentAmount;
            }
          }
        }
        const halfDateStr = addDays(phaseStartStr, 14);
        const halfDate = toDate(halfDateStr);
        if(halfDate && !isNaN(halfDate.getTime())){
          const halfTime = halfDate.getTime();
          if(halfTime >= startTime && halfTime <= endTime){
            if(halfDate.getFullYear() === revYear && halfDate.getMonth() === revMonth){
              totals[halfDate.getDate() - 1] += paymentAmount;
            }
          }
        }
      }
    });
    // revenue from won leads not yet converted to clients: add their price on the win date
    if(Array.isArray(state.wonLeads)){
      state.wonLeads.forEach(L => {
        if(!L.wonOn) return;
        const d = toDate(L.wonOn);
        // skip if lead has been converted to a client (clientId exists)
        if(L.clientId && state.clients[L.clientId]) return;
        if(d && !isNaN(d.getTime())){
          if(d.getFullYear() === revYear && d.getMonth() === revMonth){
            const dayIndex = d.getDate() - 1;
            totals[dayIndex] += Number(L.price) || 0;
          }
        }
      });
    }
    const max = Math.max(...totals, 1);
    const H = cvs.clientHeight || 160;
    const W = cvs.clientWidth || 200;
    // Determine bar width based on the number of days. Use the available width minus
    // some margins to squeeze all bars into view. Leave space for axis labels.
    const gap = 2;
    // Spread bars evenly across the width minus margins. Previously we
    // multiplied the bar count by 1.5 to leave lots of empty space,
    // causing numbers to be cramped to the left. Reduce the spacing so
    // bars fill the available width.
    const barW = Math.max(4, Math.floor((W - 30 - (daysInMonth - 1) * gap) / daysInMonth));
    totals.forEach((v,i) => {
      const h = Math.round((v / max) * (H - 36));
      const x = 14 + i * (barW + gap);
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.left = x + 'px';
      bar.style.height = h + 'px';
      bar.style.width = barW + 'px';
      bar.title = `${i+1}: $${v.toLocaleString()}`;
      // Clicking a bar should open a popup listing all deals for that day
      bar.onclick = (ev) => {
        ev.stopPropagation();
        // Determine the date of this bar using the latest selected month/year.
        // Use explicit null/undefined checks to preserve January (0) as a valid month.
        const revYearNow = (state.revYear != null) ? state.revYear : new Date().getFullYear();
        const revMonthNow = (state.revMonth != null) ? state.revMonth : new Date().getMonth();
        const dateStr = fmtDate(new Date(revYearNow, revMonthNow, i+1));
        // Collect client payments due on this day. When revenue is split into
        // biweekly payments, there may be multiple payment entries for a
        // single client. Each payment is represented individually in the
        // deals array. Deletion of any entry will remove the entire client
        // deal (similar to the old behaviour).
        const deals = [];
        Object.values(state.clients).forEach(c => {
          if(state.leads.some(L => L.clientId === c.id)) return;
          if(!c.onboard) return;
          // Compute the deal price with fallback to the package price when
          // the client price is undefined or zero.
          let price = Number(c.price);
          if(!price){ price = (state.prices && state.prices[c.package]) || 0; }
          if(price <= 0) return;
          // Determine how many months this client has been scheduled. Use
          // package months as a baseline and augment based on actual content
          // posts rather than raw task phases. Scanning tasks can capture
          // unrelated phases and overstate the contract duration. Instead,
          // compute extra months by examining client.content. See the logic
          // in the main revenue loop for details.
          let pkgMonths = 0;
          if(PKG_META && PKG_META[c.package||"none"]){
            pkgMonths = PKG_META[c.package||"none"].months || 0;
          }
          // Determine extra months for this client by examining their
          // scheduled content. Track the maximum month index (relative
          // to the first posting month) and subtract the baseline
          // package months. Posts that fall within the baseline
          // months do not extend the contract. For instance, if a
          // client with a six‑month package has posts into month 7
          // (index 6), extraMonths becomes 1 (7 total months minus
          // 6 baseline months). When no posts exist or all posts
          // fall inside the baseline, extraMonths remains zero.
          let maxPostIdx = -1;
          if(Array.isArray(c.content) && c.onboard){
            const basePostingDate = toDate(addDays(c.onboard, 28));
            const baseMs = basePostingDate instanceof Date ? basePostingDate.getTime() : NaN;
            if(!isNaN(baseMs)){
              c.content.forEach(p => {
                if(!p || !p.date) return;
                const type = p.type;
                if(type === 'video' || type === 'photo' || type === 'carousel' || type === 'email'){
                  const d = toDate(p.date);
                  if(!(d instanceof Date) || isNaN(d.getTime())) return;
                  const diff = d.getTime() - baseMs;
                  if(diff >= 0){
                    const idx = Math.floor(diff / (28 * 86400000));
                    if(idx >= 0){
                      if(idx > maxPostIdx) maxPostIdx = idx;
                    }
                  }
                }
              });
            }
          }
          let extraMonths = 0;
          if(maxPostIdx >= 0){
            const postsMonths = maxPostIdx + 1;
            extraMonths = Math.max(0, postsMonths - pkgMonths);
          }
          // Combine the contracted package months with any additional
          // months implied by auto‑scheduled content posts. Each client
          // begins with a baseline of `pkgMonths` months from their
          // package. If additional content posts have been created via
          // auto‑scheduling (identified by content dated beyond the
          // initial contract), count those as extra months. The total
          // number of revenue months equals the sum of these two
          // values. When both are zero, the deal is treated as a
          // single lump‑sum on the onboard date. This approach allows
          // clients on a one‑month trial to extend their billing window
          // by explicitly auto‑scheduling additional months.
          // Determine the total number of months for which this client
          // should generate revenue. Start with the package-defined
          // months and add any extra months implied by scheduled
          // content. For example, a six‑month package plus two
          // auto‑scheduled months yields eight months of revenue (6+2).
          // When both package months and extra months sum to zero,
          // the deal reduces to a lump‑sum on the onboard date.
          let totalMonths = pkgMonths + extraMonths;
          if(!totalMonths || totalMonths < 0){ totalMonths = 0; }
          // Skip this client entirely if the selected month falls completely
          // outside of their billing window. For clients with defined
          // monthly payments (totalMonths > 0), compute the contract
          // window from the onboard date to the last half‑payment date.
          // If the selected calendar month lies wholly before or after
          // this window, no payments should appear. For lump‑sum clients
          // (totalMonths == 0), this check is skipped because there is
          // only a single payment on the onboard date.
          if(totalMonths > 0){
            const baseDate = toDate(c.onboard);
            if(baseDate instanceof Date && !isNaN(baseDate.getTime())){
              const revMonthStart = new Date(revYearNow, revMonthNow, 1);
              const revMonthEnd = new Date(revYearNow, revMonthNow + 1, 0);
              // The contract end date is the start of the last phase plus
              // 14 days (the second half‑payment). For example, a
              // two‑month trial has payments on day 0 and day 14 of the
              // first month and again on day 0 and day 14 of the second
              // month. Thus `(totalMonths - 1) * 28 + 14` yields the
              // offset to the final half‑payment.
              // Avoid mutating baseDate by passing a string into addDays. A
              // Date passed directly to addDays is modified in place, which
              // corrupts subsequent calculations of phase starts. Use fmtDate
              // to clone the date for arithmetic.
              const contractEndDate = toDate(addDays(fmtDate(baseDate), (totalMonths - 1) * 28 + 14));
              if(contractEndDate instanceof Date && !isNaN(contractEndDate.getTime())){
                if(revMonthStart.getTime() > contractEndDate.getTime() || revMonthEnd.getTime() < baseDate.getTime()){
                  return;
                }
              }
            }
          }

          if(totalMonths <= 0){
            // If there are no months, the entire price counts as a
            // single deal on the onboard date. Use toDate for robust
            // parsing and ignore invalid dates. Only push a deal if
            // the date matches the current bar day.
            const d = toDate(c.onboard);
            if(d instanceof Date && !isNaN(d.getTime())){
              if(d.getFullYear() === revYearNow && d.getMonth() === revMonthNow && d.getDate() === i+1){
                deals.push({ name: c.name, price: price, clientId: c.id });
              }
            }
          } else {
            // Split the price into two payments per month. Use the same clamping
            // logic as in the revenue summation to ensure payments do not
            // appear outside the contract period. Compute the valid time
            // window once and then iterate through phases, stopping at
            // totalMonths. When a payment date aligns with the current day
            // (revYearNow/revMonthNow/i), push an entry for that half‑payment.
          const paymentAmount = price / 2;
            // Robustly parse the onboard date. Use toDate to handle
            // ISO strings and other formats beyond YYYY‑MM‑DD. Skip
            // this client entirely if the onboard cannot be parsed.
            const base = toDate(c.onboard);
            if(!(base instanceof Date) || isNaN(base.getTime())){
              return;
            }
            const startTime = base.getTime();
            // Use a string for addDays to prevent base date mutation
            const endPhaseStartStr = addDays(fmtDate(base), (totalMonths - 1) * 28);
            const endPhaseStart = toDate(endPhaseStartStr);
            const endHalfDateStr = addDays(endPhaseStartStr, 14);
            const endHalfDate = toDate(endHalfDateStr);
            const endTime = endHalfDate ? endHalfDate.getTime() : NaN;
            for(let m=0; m<totalMonths; m++){
              // Use a string to avoid mutating the base date
              const phaseStartStr = addDays(fmtDate(base), m * 28);
              const phaseStart = toDate(phaseStartStr);
              if(phaseStart && !isNaN(phaseStart.getTime())){
                const phaseTime = phaseStart.getTime();
                if(phaseTime >= startTime && phaseTime <= endTime){
                  if(phaseStart.getFullYear() === revYearNow && phaseStart.getMonth() === revMonthNow && phaseStart.getDate() === i+1){
                    deals.push({ name: c.name, price: paymentAmount, clientId: c.id });
                  }
                }
              }
              const halfDateStr = addDays(phaseStartStr, 14);
              const halfDate = toDate(halfDateStr);
              if(halfDate && !isNaN(halfDate.getTime())){
                const halfTime = halfDate.getTime();
                if(halfTime >= startTime && halfTime <= endTime){
                  if(halfDate.getFullYear() === revYearNow && halfDate.getMonth() === revMonthNow && halfDate.getDate() === i+1){
                    deals.push({ name: c.name, price: paymentAmount, clientId: c.id });
                  }
                }
              }
            }
          }
        });
        // Include won leads not yet converted to clients as full payments on the win date
        if(Array.isArray(state.wonLeads)){
          state.wonLeads.forEach(L => {
            if(L.clientId && state.clients[L.clientId]) return;
            if(!L.wonOn) return;
            const d2 = toDate(L.wonOn);
            if(d2 && !isNaN(d2.getTime())){
              if(d2.getFullYear() === revYearNow && d2.getMonth() === revMonthNow && d2.getDate() === i+1){
                deals.push({ name: L.name, price: Number(L.price) || 0, leadId: L.id || null });
              }
            }
          });
        }
        if(deals.length === 0){ return; }
        // Build a modal listing deals with delete buttons
        const rows = deals.map((d, idx) => {
          return `<div class="row wrap" style="align-items:center;justify-content:space-between;margin-bottom:6px"><span>${d.name} – $${d.price.toLocaleString()}</span><button class="btn small danger" data-deldeal="${idx}">Delete</button></div>`;
        }).join('');
        openModal(`
          <h3>Deals on ${MONTHS[revMonthNow]} ${i+1}, ${revYearNow}</h3>
          <div>${rows}</div>
          <div class="row right" style="margin-top:12px"><button class="btn secondary" id="closeDeals">Close</button></div>
        `, () => {
          $("#closeDeals").onclick = closeModal;
          // Attach delete handlers. Query all buttons with data‑deldeal
          // inside the modal so we bind each to its corresponding
          // deal. This avoids binding only the first element returned
          // by querySelector.
          const btns = document.querySelectorAll('#modal [data-deldeal]');
          btns.forEach((btn, idx) => {
            btn.onclick = () => {
              const d = deals[idx];
              // Use the helper to remove this deal from revenue without deleting the client
              deleteDeal(d);
              closeModal();
            };
          });
        });
      };
      cvs.appendChild(bar);
      // numeric label on top of bar
      const lbl = document.createElement('div');
      lbl.style.position = 'absolute';
      lbl.style.left = x + 'px';
      lbl.style.bottom = (h + 6) + 'px';
      lbl.style.width = barW + 'px';
      lbl.style.textAlign = 'center';
      lbl.style.fontSize = '9px';
      lbl.style.color = '#9aa3b6';
      lbl.textContent = v ? `$${v.toLocaleString()}` : '';
      cvs.appendChild(lbl);
      // day label at bottom
      const dayLbl = document.createElement('div');
      dayLbl.style.position = 'absolute';
      dayLbl.style.left = x + 'px';
      dayLbl.style.bottom = '0px';
      dayLbl.style.width = barW + 'px';
      dayLbl.style.textAlign = 'center';
      // Increase font size for day numbers to better utilize the available
      // horizontal space. Adjust if text overlaps by changing gap or barW.
      dayLbl.style.fontSize = '9px';
      dayLbl.style.color = '#6f7893';
      dayLbl.textContent = String(i + 1);
      cvs.appendChild(dayLbl);
    });
    // total revenue for the month
    const totalMonth = totals.reduce((a,b)=>a+b,0);
    const rt = $("#revTotal", cont);
    if(rt){ rt.textContent = canSeeRevenue() ? `Total: $${totalMonth.toLocaleString()}` : ''; }
  }

  // salesperson specific revenue chart. Displays commission earnings per
  // day for the selected salesperson for the current month selection
  // (revYear/revMonth). Commission is calculated as the deal price
  // multiplied by the commission percentage defined in settings. Only
  // includes deals closed in the selected month.
  function drawPersonRevenue(){
    // Determine month/year, preserving January (0)
    const revYear = (state.revYear !== undefined && state.revYear !== null) ? state.revYear : new Date().getFullYear();
    const revMonth = (state.revMonth !== undefined && state.revMonth !== null) ? state.revMonth : new Date().getMonth();
    const cvs = $("#revPersonCanvas", cont);
    if(!cvs) return;
    cvs.innerHTML = '';
    const select = $("#salesPersonSelect", rev);
    if(!select) return;
    const uidSel = select.value;
    // Determine number of days
    const daysInMonth = new Date(revYear, revMonth + 1, 0).getDate();
    // Prepare commissions per day
    const commTotals = Array(daysInMonth).fill(0);
    const monthStart = new Date(revYear, revMonth, 1);
    const monthEnd   = new Date(revYear, revMonth, daysInMonth);
    // Sum commissions from payment tasks
    if(Array.isArray(state.tasks)){
      state.tasks.forEach(t => {
        if(!t || t.name !== 'Payment due' || !t.date) return;
        if(!t.meta || !t.meta.salespersonId) return;
        if(t.meta.salespersonId != uidSel) return;
        const d = toDate(t.date);
        if(!(d instanceof Date) || isNaN(d.getTime())) return;
        // Only include tasks in this month
        if(d < monthStart || d > monthEnd) return;
        let include = true;
        let amt = Number(t.meta && t.meta.amount) || 0;
        if(t.clientId && state.clients && state.clients[t.clientId]){
          const c = state.clients[t.clientId];
          const pkg = PKG_META && PKG_META[c.package || 'none'];
          const baseline = (pkg && pkg.months) ? pkg.months : 0;
          if(baseline > 0 && c.onboard){
            const onboardDate = toDate(c.onboard);
            if(onboardDate instanceof Date && !isNaN(onboardDate.getTime())){
              const maxPayments = baseline * 2;
              const lastDate = addDays(onboardDate, 14 * (maxPayments - 1));
              if(d > lastDate) include = false;
            }
          }
        }
        if(include){
          const idx = d.getDate() - 1;
          if(idx >= 0 && idx < commTotals.length){ commTotals[idx] += amt * (state.commissionPct || 0); }
        }
      });
    }
    // Commissions from won leads (one‑time) for selected salesperson
    if(Array.isArray(state.wonLeads)){
      state.wonLeads.forEach(L => {
        if(!L.wonOn) return;
        if(L.clientId && state.clients && state.clients[L.clientId]) return;
        if(L.salespersonId && L.salespersonId != uidSel) return;
        const d = toDate(L.wonOn);
        if(!(d instanceof Date) || isNaN(d.getTime())) return;
        if(d.getFullYear() !== revYear || d.getMonth() !== revMonth) return;
        const idx = d.getDate() - 1;
        if(idx >= 0 && idx < commTotals.length){
          commTotals[idx] += Number(L.price) * (state.commissionPct || 0) || 0;
        }
      });
    }
    // Render commission bars
    const maxComm = commTotals.length > 0 ? Math.max(...commTotals) : 0;
    const barContainer = document.createElement('div');
    barContainer.style.display = 'flex';
    barContainer.style.alignItems = 'flex-end';
    barContainer.style.height = '100px';
    barContainer.style.borderBottom = '1px solid var(--border, #333)';
    barContainer.style.marginBottom = '4px';
    barContainer.style.gap = '1px';
    for(let i=0; i<daysInMonth; i++){
      const val = commTotals[i];
      const bar = document.createElement('div');
      bar.style.flex = '1 1 0';
      bar.style.height = (maxComm > 0 ? (val / maxComm * 100).toFixed(2) : 0) + '%';
      bar.style.background = val > 0 ? '#3a77ff' : 'transparent';
      barContainer.appendChild(bar);
    }
    // x‑axis labels row
    const xLabels = document.createElement('div');
    xLabels.style.display = 'flex';
    xLabels.style.fontSize = '10px';
    xLabels.style.color = 'var(--fg, #888)';
    xLabels.style.marginTop = '2px';
    for(let i=0; i<daysInMonth; i++){
      const lbl = document.createElement('div');
      lbl.style.flex = '1 1 0';
      lbl.style.textAlign = 'center';
      lbl.textContent = (i + 1).toString();
      xLabels.appendChild(lbl);
    }
    cvs.appendChild(barContainer);
    cvs.appendChild(xLabels);
    // Update commission total label
    let totalEl = document.getElementById('revPersonTotal');
    if(!totalEl){ totalEl = document.createElement('div'); totalEl.id = 'revPersonTotal'; cvs.appendChild(totalEl); }
    totalEl.style.position = 'relative';
    totalEl.style.marginTop = '4px';
    totalEl.style.fontSize = '12px';
    totalEl.style.color = 'var(--fg, #fff)';
    totalEl.style.textAlign = 'right';
    const totalVal = commTotals.reduce((acc,v) => acc + v, 0);
    totalEl.textContent = `$${totalVal.toLocaleString()}`;
    return;

/**
 * Display a modal listing all payment tasks on the given date.
 * Users can review which client payments contribute to a revenue bar
 * and optionally delete them directly from this view. When a
 * payment is deleted the revenue charts update immediately.
 *
 * @param {number} year The full year (e.g. 2025)
 * @param {number} monthIdx Zero‑based month index (0=Jan)
 * @param {number} day The day of month (1-based)
 */
function openPaymentDetails(year, monthIdx, day){
  // Remove any existing overlay
  let existing = document.getElementById('paymentDetailsOverlay');
  if(existing){ existing.remove(); }
  const overlay = document.createElement('div');
  overlay.id = 'paymentDetailsOverlay';
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.right = '0';
  overlay.style.bottom = '0';
  overlay.style.zIndex = '10000';
  overlay.style.background = 'rgba(0,0,0,0.6)';
  // container for content
  const box = document.createElement('div');
  box.style.maxWidth = '420px';
  box.style.margin = '80px auto';
  box.style.background = 'var(--bg, #222)';
  box.style.borderRadius = '8px';
  box.style.padding = '16px';
  box.style.color = 'var(--fg, #fff)';
  overlay.appendChild(box);
  const dateStr = `${year}-${String(monthIdx+1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
  const title = document.createElement('div');
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '8px';
  title.textContent = `Payments on ${MONTHS[monthIdx]} ${day}, ${year}`;
  box.appendChild(title);
  // Gather payment tasks for this day
  const tasks = (Array.isArray(state.tasks) ? state.tasks.filter(t => t && t.name === 'Payment due' && t.date === dateStr) : []);
  if(tasks.length === 0){
    const empty = document.createElement('div');
    empty.textContent = 'No payments scheduled for this day.';
    box.appendChild(empty);
  } else {
    tasks.forEach(t => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.marginBottom = '4px';
      const desc = document.createElement('span');
      const clientName = (state.clients && t.clientId && state.clients[t.clientId] && state.clients[t.clientId].name) || 'Client';
      const amt = Number(t.meta && t.meta.amount) || 0;
      desc.textContent = `${clientName}: $${amt.toLocaleString()}`;
      row.appendChild(desc);
      const delBtn = document.createElement('button');
      delBtn.className = 'btn small danger';
      delBtn.textContent = 'Delete';
      delBtn.onclick = () => {
        // Remove the task and update state
        const idx = state.tasks.findIndex(x => x && x.id === t.id);
        if(idx >= 0){ state.tasks.splice(idx,1); }
        if(typeof save === 'function') save();
        overlay.remove();
        if(typeof drawRevenue === 'function') drawRevenue();
        if(typeof drawPersonRevenue === 'function') drawPersonRevenue();
      };
      row.appendChild(delBtn);
      box.appendChild(row);
    });
  }
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn small ghost';
  closeBtn.textContent = 'Close';
  closeBtn.style.marginTop = '12px';
  closeBtn.onclick = () => overlay.remove();
  box.appendChild(closeBtn);
  document.body.appendChild(overlay);
}
    // Collect commissions from clients whose salesperson matches the selected
    // salesperson. Commissions are based on each biweekly payment rather
    // than the full deal price on the win date. If no package months are
    // defined for the client, the full price is credited on the win date
    // as before.
    Object.values(state.clients).forEach(c => {
      // Skip deleted clients (onboard date saved in _deletedOnboard)
      if(c._deletedOnboard){ return; }
      // Use the client price if provided, otherwise fall back to
      // the default package price. Without this fallback, clients
      // created without an explicit price would contribute zero to
      // commissions and revenue.
      let price = Number(c.price);
      if(!price){ price = (state.prices && state.prices[c.package]) || 0; }
      if(price <= 0) return;
      if(c.salespersonId !== uidSel) return;
      // Determine number of months of service this client is scheduled for.
      // Use the package months as a baseline and then extend based on
      // actual content posts. Tasks (state.tasks) can contain arbitrary
      // phases for internal scheduling and should not be used to derive
      // contract length, as they may cause revenue to extend far beyond
      // the contracted term. Instead compute extra months by examining
      // the client.content array in the same way as the business
      // revenue calculation.
      let pkgMonths = 0;
      if(PKG_META && PKG_META[c.package||"none"]){
        pkgMonths = PKG_META[c.package||"none"].months || 0;
      }
      // Determine how many months beyond the baseline package this
      // client has been scheduled. Scan all content posts to find the
      // furthest month index relative to the base posting date. Then
      // subtract the baseline package months from the total number of
      // posting months. For example, if a 6‑month package has posts
      // scheduled into month 8 (index 7), that implies two extra months
      // (8 total months minus 6 baseline months). If all posts fall
      // within the baseline months, extraMonths remains 0.
      let maxPostIdx = -1;
      if(Array.isArray(c.content) && c.onboard){
        // Base posting date is 28 days after onboard
        const basePostingDate = toDate(addDays(c.onboard, 28));
        const baseMs = basePostingDate instanceof Date ? basePostingDate.getTime() : NaN;
        if(!isNaN(baseMs)){
          c.content.forEach(p => {
            if(!p || !p.date) return;
            const type = p.type;
            // Only consider primary content types for scheduling
            if(type === 'video' || type === 'photo' || type === 'carousel' || type === 'email'){
              const d = toDate(p.date);
              if(!(d instanceof Date) || isNaN(d.getTime())) return;
              const diff = d.getTime() - baseMs;
              if(diff >= 0){
                const idx = Math.floor(diff / (28 * 86400000));
                if(idx >= 0){
                  if(idx > maxPostIdx) maxPostIdx = idx;
                }
              }
            }
          });
        }
      }
      let extraMonths = 0;
      if(maxPostIdx >= 0){
        const postsMonths = maxPostIdx + 1;
        extraMonths = Math.max(0, postsMonths - pkgMonths);
      }
      // Compute the total number of months for which commission is
      // payable. Start with the number of months defined by the
      // client’s package and add any additional months implied by
      // auto‑scheduled content. When both values sum to zero, the
      // entire commission is paid as a lump sum on the win/onboard
      // date. This mirrors the logic in drawRevenue and ensures
      // commission payments are extended only when the user
      // explicitly schedules extra months via the content calendar.
      // Use the larger of the package months and the months implied by
      // scheduled content to determine the commission window. This
      // prevents double‑counting the baseline contract while still
      // extending commissions when additional months are explicitly
      // scheduled. A zero value indicates that the entire commission
      // should post on the win/onboard date as a lump sum. Start with
      // the package-defined months and add extra months implied by
      // scheduled content. For example, a six‑month package with two
      // additional months of posts yields eight months of commission.
      let totalMonths = pkgMonths + extraMonths;
      if(!totalMonths || totalMonths < 0){ totalMonths = 0; }
      // Skip commissions for months entirely outside the billing
      // window. For lump‑sum deals (totalMonths == 0) there is only a
      // single payment on the win/onboard date, so this check is
      // unnecessary. For multi‑month deals, compute the contract
      // window from the onboard date through the last half‑payment
      // date. If the selected month lies completely before or after
      // this window, there is no commission to credit.
      if(totalMonths > 0){
        const baseDate = toDate(c.onboard);
        if(baseDate instanceof Date && !isNaN(baseDate.getTime())){
          const revMonthStart = new Date(revYear, revMonth, 1);
          const revMonthEnd = new Date(revYear, revMonth + 1, 0);
          // Pass a string into addDays to prevent mutating baseDate. Directly
          // mutating the Date will corrupt subsequent iterations. See
          // revenue calendar fix notes.
          const contractEndDate = toDate(addDays(fmtDate(baseDate), (totalMonths - 1) * 28 + 14));
          if(contractEndDate instanceof Date && !isNaN(contractEndDate.getTime())){
            if(revMonthStart.getTime() > contractEndDate.getTime() || revMonthEnd.getTime() < baseDate.getTime()){
              return;
            }
          }
        }
      }

      // If no months defined, credit full commission on win/onboard date
      if(totalMonths <= 0){
        const win = winDateMap[c.id] || c.onboard;
        const d = toDate(win);
        if(!win || !(d instanceof Date) || isNaN(d.getTime())) return;
        if(d.getFullYear() === revYear && d.getMonth() === revMonth){
          const idx = d.getDate() - 1;
          totals[idx] += price * state.commissionPct;
        }
      } else {
        // Distribute commissions in half‑payments for each phase. Each
        // phase is 28 days long starting at the onboard date. A payment
        // is due on the phase start and another payment 14 days later.
        // Payments are clamped between the onboard date and the last
        // half‑payment date to ensure revenue does not leak before the
        // contract starts or beyond the end of the scheduled phases.
        const paymentAmount = price / 2;
        const commissionPerPay = paymentAmount * state.commissionPct;
        const base = toDate(c.onboard);
        // If onboarding date is invalid, skip this client
        if(!(base instanceof Date) || isNaN(base.getTime())) return;
        const startTime = base.getTime();
        // Compute last phase start date as a string using addDays on base
        // Avoid mutating the onboard date by using a string for addDays
        const endPhaseStartStr = addDays(fmtDate(base), (totalMonths - 1) * 28);
        const endPhaseStart = toDate(endPhaseStartStr);
        const endHalfDateStr = addDays(endPhaseStartStr, 14);
        const endHalfDate = toDate(endHalfDateStr);
        const endTime = endHalfDate instanceof Date ? endHalfDate.getTime() : NaN;
        for(let m = 0; m < totalMonths; m++){
          // Use a string when advancing the base date to avoid mutation
          const phaseStartStr = addDays(fmtDate(base), m * 28);
          const phaseStart = toDate(phaseStartStr);
          if(phaseStart instanceof Date && !isNaN(phaseStart.getTime())){
            const phaseTime = phaseStart.getTime();
            if(!isNaN(startTime) && !isNaN(endTime) && phaseTime >= startTime && phaseTime <= endTime){
              if(phaseStart.getFullYear() === revYear && phaseStart.getMonth() === revMonth){
                totals[phaseStart.getDate() - 1] += commissionPerPay;
              }
            }
          }
          const halfDateStr = addDays(phaseStartStr, 14);
          const halfDate = toDate(halfDateStr);
          if(halfDate instanceof Date && !isNaN(halfDate.getTime())){
            const halfTime = halfDate.getTime();
            if(!isNaN(startTime) && !isNaN(endTime) && halfTime >= startTime && halfTime <= endTime){
              if(halfDate.getFullYear() === revYear && halfDate.getMonth() === revMonth){
                totals[halfDate.getDate() - 1] += commissionPerPay;
              }
            }
          }
        }
      }
    });
    // Sort daily commissions by day index implicitly when drawing bars
    const max = Math.max(...totals, 1);
    const H = cvs.clientHeight || 140;
    const W = cvs.clientWidth || 200;
    const gap = 2;
    const barW = Math.max(4, Math.floor((W - 30 - (daysInMonth - 1) * gap) / daysInMonth));
    totals.forEach((v,i) => {
      const h = Math.round((v / max) * (H - 36));
      const x = 14 + i * (barW + gap);
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.left = x + 'px';
      bar.style.height = h + 'px';
      bar.style.width = barW + 'px';
      bar.title = `${i+1}: $${v.toFixed(0)}`;
      cvs.appendChild(bar);
      const lbl = document.createElement('div');
      lbl.style.position = 'absolute';
      lbl.style.left = x + 'px';
      lbl.style.bottom = (h + 6) + 'px';
      lbl.style.width = barW + 'px';
      lbl.style.textAlign = 'center';
      lbl.style.fontSize = '9px';
      lbl.style.color = '#9aa3b6';
      lbl.textContent = v ? `$${v.toFixed(0)}` : '';
      cvs.appendChild(lbl);
      // day label
      const dayLbl = document.createElement('div');
      dayLbl.style.position = 'absolute';
      dayLbl.style.left = x + 'px';
      dayLbl.style.bottom = '0px';
      dayLbl.style.width = barW + 'px';
      dayLbl.style.textAlign = 'center';
      dayLbl.style.fontSize = '9px';
      dayLbl.style.color = '#6f7893';
      dayLbl.textContent = String(i+1);
      cvs.appendChild(dayLbl);
    });
    const total = totals.reduce((sum, val) => sum + val, 0);
    const totEl = $("#revPersonTotal", cont);
    if(totEl) totEl.textContent = `Total: $${total.toFixed(0)}`;
  }
  // Draw initial revenue graphs after DOM has rendered. We schedule
  // drawPersonRevenue separately to avoid race conditions with element sizes.
  setTimeout(drawRevenue, 0);
  setTimeout(drawPersonRevenue, 0);
  // Update the personal revenue chart whenever the selected salesperson changes.
  const spSel = $("#salesPersonSelect", rev);
  if(spSel){ spSel.onchange = ()=>{ drawPersonRevenue(); }; }
  // Hook up month navigation for revenue charts. Adjust the selected
  // month and year and redraw both charts when navigation buttons
  // are clicked.  We update the persisted month/year on the state and
  // immediately redraw the revenue charts instead of calling render(),
  // which may reset event handlers. Using state.revYear/state.revMonth
  // ensures the header text updates correctly when drawRevenue runs.
  const prevBtn = document.getElementById('revPrev');
  const nextBtn = document.getElementById('revNext');
  if(prevBtn){
    prevBtn.onclick = () => {
      // decrement the month, rolling back the year as needed. Use
      // explicit null/undefined checks to allow January (0) as a valid
      // stored month. Using logical OR here would cause 0 to be
      // overwritten by the current month.
      let y = (state.revYear != null) ? state.revYear : new Date().getFullYear();
      let m = (state.revMonth != null) ? state.revMonth : new Date().getMonth();
      m--;
      if(m < 0){ m = 11; y--; }
      state.revYear = y;
      state.revMonth = m;
      // Persist the selection so that reloading the page does not reset
      // the chart to the current month. Save after updating the state.
      if(typeof save === 'function') save();
      // Update the month picker so the input reflects the new date
      const rp = document.getElementById('revPicker');
      if(rp){ rp.value = `${y}-${String(m+1).padStart(2,'0')}`; }
      // Redraw revenue charts without re-rendering the entire page. This
      // refreshes the graph and totals immediately and keeps the
      // navigation arrows functional.
      drawRevenue();
      drawPersonRevenue();
    };
  }
  if(nextBtn){
    nextBtn.onclick = () => {
      // increment the month, rolling forward the year as needed. Use
      // null/undefined checks to keep 0 (January) from being discarded.
      let y = (state.revYear != null) ? state.revYear : new Date().getFullYear();
      let m = (state.revMonth != null) ? state.revMonth : new Date().getMonth();
      m++;
      if(m > 11){ m = 0; y++; }
      state.revYear = y;
      state.revMonth = m;
      // Persist month selection to localStorage
      if(typeof save === 'function') save();
      const rp = document.getElementById('revPicker');
      if(rp){ rp.value = `${y}-${String(m+1).padStart(2,'0')}`; }
      drawRevenue();
      drawPersonRevenue();
    };
  }
  // Allow manual month selection via the month input. Update the
  // persisted month/year and redraw charts when changed.  Format of the
  // input is "YYYY-MM".
  const revPicker = document.getElementById('revPicker');
  if(revPicker){
    revPicker.onchange = () => {
      const val = revPicker.value || '';
      if(val){
        const parts = val.split('-');
        const y = Number(parts[0]);
        const m = Number(parts[1]);
        if(!isNaN(y) && !isNaN(m)){
          state.revYear = y;
          // HTML month input is 1-based
          state.revMonth = m - 1;
          // Persist the selection so reloading retains the chosen month
          if(typeof save === 'function') save();
          drawRevenue();
          drawPersonRevenue();
        }
      }
    };
  }

  $("#screen").innerHTML=""; $("#screen").appendChild(cont);
}

/*** SETTINGS ***/
function renderSettings(){
  const cont = document.createElement("div");
  // If logged in as a client, render only account settings for password
  // changes. Clients cannot adjust durations, prices or commission. They
  // may update their password here to improve security.
  if(isClient()){
    const cid = currentClientId();
    const client = state.clients[cid];
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <h3>Account Settings</h3>
      <div class="row wrap">
        <label style="flex:1;min-width:180px">Business name
          <input type="text" id="clientName" value="${client?.name||''}" disabled style="width:100%"/>
        </label>
      </div>
      <div class="row wrap" style="margin-top:12px">
        <label style="flex:1;min-width:180px">Current password
          <input type="password" id="currPwd" placeholder="Current password" style="width:100%"/>
        </label>
        <label style="flex:1;min-width:180px">New password
          <input type="password" id="newPwd" placeholder="New password" style="width:100%"/>
        </label>
        <label style="flex:1;min-width:180px">Confirm new password
          <input type="password" id="confPwd" placeholder="Confirm new password" style="width:100%"/>
        </label>
      </div>
      <div class="row right" style="margin-top:12px">
        <button class="btn secondary" id="savePwd">Save</button>
      </div>
    `;
    cont.appendChild(card);
    // Attach handler to save password
    setTimeout(() => {
      const saveBtn = document.getElementById('savePwd');
      if(saveBtn){
        saveBtn.onclick = () => {
          const curr = document.getElementById('currPwd').value;
          const np = document.getElementById('newPwd').value;
          const cp = document.getElementById('confPwd').value;
          if(!client) return;
          if(curr !== client.password){
            alert('Current password incorrect.');
            return;
          }
          if(!np || np !== cp){
            alert('New passwords do not match.');
            return;
          }
          client.password = np;
          save();
          alert('Password updated.');
          // clear fields
          document.getElementById('currPwd').value = '';
          document.getElementById('newPwd').value = '';
          document.getElementById('confPwd').value = '';
        };
      }
    }, 0);
    // Render and return
    document.getElementById('screen').innerHTML = '';
    document.getElementById('screen').appendChild(cont);
    return;
  }
  const box = document.createElement("div"); box.className="card";
  box.innerHTML = `<h3>Durations (hours)</h3>`;
  const g = document.createElement("div");
  // Use a responsive grid with vertical orientation for each duration input. The
  // extra class helps target custom styles in CSS. Each cell will stack the
  // label above its input rather than placing them side‑by‑side. This fixes
  // inconsistent alignment seen with Kickoff and Posting fields.
  g.className="grid3 durations-grid";
  const fields = [
    ["kickoff","Kickoff"],["monthlyCall","MonthlyCall"],
    ["loginsText","Logins Text"],["loginsCall","Logins Call"],
    ["influencerFind","Influencer Find"],["influencerConfirm","Influencer Confirm"],
    ["scriptingHour","Scripting Hour Per Unit"],["editingPer4","Editing Per4"],
    ["photoPerHour","Photo Per Hour"],["posting","Posting"],
    ["websitePlan","Website Plan"],["websiteCapture","Website Capture"],["websiteBuild","Website Build"],["websiteQA","Website Qa"],["websitePublish","Website Publish"],["websiteSend","Website Send"],
    ["emailSetup","Email Setup"],["emailSchedule","Email Schedule"],["emailReport","Email Report"],
    ["phoneSetup","Phone Setup"]
  ];
  g.innerHTML = fields.map(([k,label])=>`
    <div class="dur-field">
      <label class="dur-label" for="dur_${k}">${label}</label>
      <input id="dur_${k}" type="number" step="0.25" value="${state.durations[k]||0}"/>
    </div>
  `).join("");
  box.appendChild(g);
  const prices = document.createElement("div"); prices.className="section-title"; prices.textContent="Prices";
  const priceRow = document.createElement("div"); priceRow.className="row wrap";
  priceRow.innerHTML = `
    Trial $<input id="p_trial" type="number" value="${state.prices.trial}" style="width:100px"/>
    Regular $<input id="p_mini" type="number" value="${state.prices.mini}" style="width:100px"/>
    Medium $<input id="p_medium" type="number" value="${state.prices.medium}" style="width:100px"/>
    Large $<input id="p_large" type="number" value="${state.prices.large}" style="width:100px"/>
    Website $<input id="p_website" type="number" value="${state.prices.website}" style="width:100px"/>
    <button class="btn right" id="saveSet">Save</button>
  `;
  box.appendChild(prices);
  box.appendChild(priceRow);
  // Commission percentage configuration row. Allows setting the
  // salesperson commission used for revenue calculations. The value
  // persists across sessions.
  const commRow = document.createElement('div'); commRow.className = 'row wrap';
  commRow.style.marginTop = '12px';
  commRow.innerHTML = `Commission % <input id="setComm" type="number" step="0.01" value="${state.commissionPct}" style="width:100px"/>`;
  box.appendChild(commRow);
  cont.appendChild(box);

  // When logged in as the owner, provide a section to set usernames and
  // passwords for each client. This allows the owner to manage client
  // credentials instead of relying on auto‑generated defaults. Each row
  // displays the client name with editable fields for username and
  // password. An empty username or password means the client cannot
  // log in until values are set. This card appears only for the
  // owner role.
  if(!isClient() && state.users[state.currentUserId]?.role === 'owner'){
    const credCard = document.createElement('div'); credCard.className = 'card';
    let rows = '';
    Object.keys(state.clients).forEach(cid => {
      const c = state.clients[cid];
      rows += `
        <div class="row wrap" style="gap:12px;margin-bottom:8px;align-items:center">
          <div style="flex:1;min-width:120px">${c.name}</div>
          <input id="uname_${cid}" type="text" placeholder="Username" value="${c.username||''}" style="flex:1;min-width:140px"/>
          <input id="pwd_${cid}" type="text" placeholder="Password" value="${c.password||''}" style="flex:1;min-width:140px"/>
        </div>`;
    });
    credCard.innerHTML = `
      <h3>Client Credentials</h3>
      <div id="credRows">${rows}</div>
      <div class="row right" style="margin-top:12px">
        <button class="btn secondary" id="saveCreds">Save</button>
      </div>
    `;
    cont.appendChild(credCard);
    // Attach handler to save updated usernames and passwords
    setTimeout(() => {
      const sb = document.getElementById('saveCreds');
      if(sb){
        sb.onclick = () => {
          Object.keys(state.clients).forEach(cid => {
            const uInput = document.getElementById('uname_'+cid);
            const pInput = document.getElementById('pwd_'+cid);
            if(uInput) state.clients[cid].username = uInput.value.trim();
            if(pInput) state.clients[cid].password = pInput.value.trim();
          });
          save();
          alert('Client credentials saved.');
        };
      }
    }, 0);

    // Create a card for employee credentials. Similar to the client
    // credentials card, this lists all employees (including the
    // owner) and allows the owner to update their passwords. The
    // employees are drawn from state.users. Editing a password here
    // updates the stored password used on the login screen. Names
    // cannot be edited through this interface. An empty password
    // disables login for that employee until a new one is set.
    const empCard = document.createElement('div'); empCard.className = 'card';
    let empRows = '';
    Object.keys(state.users).forEach(uid => {
      const user = state.users[uid];
      empRows += `
        <div class="row wrap" style="gap:12px;margin-bottom:8px;align-items:center">
          <div style="flex:1;min-width:120px">${user.name}</div>
          <input id="empPwd_${uid}" type="text" placeholder="Password" value="${user.password||''}" style="flex:1;min-width:140px"/>
        </div>`;
    });
    empCard.innerHTML = `
      <h3>Employee Credentials</h3>
      <div id="empCredRows">${empRows}</div>
      <div class="row right" style="margin-top:12px">
        <button class="btn secondary" id="saveEmpCreds">Save</button>
      </div>
    `;
    cont.appendChild(empCard);
    // Handler to persist employee password changes. When the Save
    // button is clicked, iterate over all users and store the value
    // from the corresponding input. Trim whitespace to avoid
    // accidental leading/trailing spaces in the password. After
    // saving, alert the user for confirmation.
    setTimeout(() => {
      const se = document.getElementById('saveEmpCreds');
      if(se){
        se.onclick = () => {
          Object.keys(state.users).forEach(uid => {
            const pInput = document.getElementById('empPwd_'+uid);
            if(pInput) state.users[uid].password = pInput.value.trim();
          });
          save();
          alert('Employee credentials saved.');
        };
      }
    }, 0);

    // Date override card. Allows the owner to set an alternate 'today'
    // date which will be used by the dashboard when scheduling and
    // displaying tasks. This is useful when the browser clock is
    // incorrect or when previewing future/past schedules. The card
    // appears only for non‑client users (primarily the owner).
    const dateCard = document.createElement('div'); dateCard.className = 'card';
    dateCard.innerHTML = `
      <h3>Date Override</h3>
      <label style="display:block">Today's date
        <input type="date" id="setToday" value="${state.todayOverride || ''}" />
      </label>
      <div class="row right" style="margin-top:12px">
        <button class="btn secondary" id="saveToday">Save</button>
      </div>
    `;
    cont.appendChild(dateCard);
    setTimeout(() => {
      // Initialize the date input with the override or current date
      const dtInput = document.getElementById('setToday');
      if(dtInput){
        dtInput.value = state.todayOverride || todayStr();
      }
      const btn = document.getElementById('saveToday');
      if(btn){
        btn.onclick = () => {
          const val = document.getElementById('setToday').value;
          // Save override. Empty clears the override.
          state.todayOverride = val || null;
          save();
          alert('Today date updated.');
          // Re-render the dashboard to reflect the new date settings
          render();
        };
      }
    }, 0);
  }

  // Backup/restore quick
  const br = document.createElement("div"); br.className="card";
  br.innerHTML = `<h3>Backup / Restore</h3><div class="row"><button class="btn secondary" id="bk">Download backup</button><label class="btn ghost inline" for="restoreInput">Restore</label></div>`;
  cont.appendChild(br);

  // Theme toggle: allow switching between dark and light themes. This
  // control is inserted after the backup/restore section. The toggle
  // uses the same switch styling as elsewhere. When changed, it
  // updates the state's theme and reapplies the new palette.
  const themeCard = document.createElement('div'); themeCard.className='card';
  themeCard.innerHTML = `
    <h3>Appearance</h3>
    <div class="row" style="align-items:center;gap:12px">
      <div class="kv"><div class="k">Light theme</div></div>
      <label class="switch"><input id="themeToggle" type="checkbox"/><span></span></label>
    </div>
  `;
  cont.appendChild(themeCard);

  // Set the toggle based on current theme and wire change handler
  setTimeout(()=>{
    const tog = document.getElementById('themeToggle');
    if(tog){
      tog.checked = state.theme === 'light';
      tog.onchange = () => {
        state.theme = tog.checked ? 'light' : 'dark';
        save();
        applyTheme();
      };
    }
  });

  $("#saveSet", box).onclick=()=>{
    fields.forEach(([k])=> state.durations[k] = Number($("#dur_"+k).value)||0 );
    state.prices.trial=Number($("#p_trial").value)||state.prices.trial;
    state.prices.mini=Number($("#p_mini").value)||state.prices.mini;
    state.prices.medium=Number($("#p_medium").value)||state.prices.medium;
    state.prices.large=Number($("#p_large").value)||state.prices.large;
    state.prices.website=Number($("#p_website").value)||state.prices.website;
    // update commission percentage
    const cp = document.getElementById('setComm');
    if(cp){
      const pct = parseFloat(cp.value);
      if(!isNaN(pct)) state.commissionPct = pct;
    }
    save(); alert("Saved.");
  };
  $("#bk", br).onclick=()=>download("marlow_backup.json", JSON.stringify(state,null,2));

  $("#screen").innerHTML=""; $("#screen").appendChild(cont);
}

/*** backup/restore header buttons ***/
$("#backupBtn").onclick=()=>download("marlow_backup.json", JSON.stringify(state,null,2));
$("#restoreInput").addEventListener("change", (ev)=>{
  const file = ev.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = ()=>{
    try{ state = JSON.parse(reader.result); save(); render(); }
    catch(e){ alert("Invalid backup."); }
  };
  reader.readAsText(file);
});

/*** render ***/
function render(){
  // Ensure a user is logged in before rendering the dashboard. When
  // no currentUserId is set, show the login screen. Logging in
  // assigns state.currentUserId and persists it. A logout button
  // (added in renderTabs) allows the user to clear their session.
  if(!state.currentUserId){
    renderLogin();
    return;
  }
  renderTabs();
  setViewAsOptions();
  // When a client logs in, automatically schedule tasks and content
  // for that client if none exist. Some datasets may lack tasks for
  // the client, leading to a blank calendar. This ensures that
  // clients always see a populated work and content calendar on first
  // login. Only schedule once per client by checking existing tasks.
  try{
    if(isClient()){
      const cid = currentClientId();
      if(cid && !state.tasks.some(t => t.clientId === cid)){
        // Schedule production tasks and content posts for the client's
        // package. scheduleClientMonths populates state.tasks and
        // scheduleContentPosts populates the client.content array. Save
        // afterwards so the new entries persist.
        scheduleClientMonths(state.clients[cid]);
        scheduleContentPosts(state.clients[cid]);
        save();
      }
    }
  }catch(e){ /* ignore scheduling errors */ }
  applyTheme();
  if(currentTab==="Overview") renderOverview();
  if(currentTab==="Clients") renderClients();
  if(currentTab==="Content") renderContent();
  if(currentTab==="Employees") renderEmployees();
  if(currentTab==="Sales") renderSales();
  if(currentTab==="Settings") renderSettings();
}

// Global revenue calendar navigation handler. In some builds the inline
// navigation buttons for the revenue chart may not have working
// onclick handlers due to re-rendering or shadowed attributes. To
// ensure the previous/next arrows always change months, attach a
// single document-level click listener. When the user clicks the
// #revPrev or #revNext buttons, adjust state.revYear/state.revMonth
// accordingly, update the month input and redraw the revenue graphs.
document.addEventListener('click', (ev) => {
  const btn = ev.target && ev.target.closest && ev.target.closest('button');
  if(!btn) return;
  const id = btn.id;
  if(id === 'revPrev' || id === 'revNext'){
    // Determine current year and month from state, falling back to
    // today's date if not yet set. Using the fallback avoids
    // NaN/undefined issues when localStorage is empty.
    let y = state.revYear != null ? state.revYear : new Date().getFullYear();
    let m = state.revMonth != null ? state.revMonth : new Date().getMonth();
    if(id === 'revPrev'){
      m--;
      if(m < 0){ m = 11; y--; }
    } else if(id === 'revNext'){
      m++;
      if(m > 11){ m = 0; y++; }
    }
    state.revYear = y;
    state.revMonth = m;
    // Persist month navigation changes to localStorage so the selected
    // month/year remains consistent across page reloads. Without saving,
    // the state may revert to the current date on refresh.
    if(typeof save === 'function') save();
    // Update month picker value if present. Use zero‑padded month.
    const rp = document.getElementById('revPicker');
    if(rp){
      rp.value = `${y}-${String(m+1).padStart(2,'0')}`;
    }
    // Redraw revenue charts to reflect the new month. Avoid full
    // re-render to preserve event handlers.
    if(typeof drawRevenue === 'function') drawRevenue();
    if(typeof drawPersonRevenue === 'function') drawPersonRevenue();
  }
});

/***
 * When a client is viewing the overview calendar they can toggle
 * between their work (production tasks) and content (scheduled
 * social posts) calendars. This helper updates the global
 * clientViewModes object for the current client and triggers a
 * re‑render. Non‑client users should ignore toggles entirely.
 *
 * @param {string} mode Either 'work' or 'content'
 */
function switchOverviewMode(mode){
  // Only clients have an overview mode; employees and owners always
  // view the work calendar. Bail out if no client is logged in.
  if(!isClient()) return;
  const cid = currentClientId();
  if(!cid) return;
  if(clientViewModes[cid] !== mode){
    clientViewModes[cid] = mode;
    save();
    // Re‑render only the overview page rather than the entire
    // dashboard. This preserves the current tab and avoids flicker.
    renderOverview();
  }
}

/*** seed sample data once ***/
// Disable seeding of sample clients by default. In prior versions
// this function automatically populated the dashboard with demo
// clients on first load, which interfered with real workflows and
// produced confusing revenue when the user wanted a clean slate. To
// keep the initial state empty, we simply mark the state as
// "seeded" and do nothing else. The user can then add clients
// manually. If you wish to restore the old sample clients, reinsert
// the sample creation logic here.
(function seed(){
  if(state._seeded) return;
  state._seeded = true;
  save();
})();

/*** boot ***/
// === REVENUE REWRITE (month-accurate & tasks-driven) ===

// Get days in the shown month
function getDaysInMonth(y, m){ return new Date(y, m + 1, 0).getDate(); }

// Try to parse "$1234.56" out of "Payment due ($1234.56)"
function parseCurrencyFromName(name){
  const m = /\$([\d,]+(?:\.\d{1,2})?)/.exec(name || '');
  return m ? Number(m[1].replace(/,/g,'')) : null;
}

// Amount for a payment task: prefer explicit amount in the title,
// fall back to half the client's package price.
function amountForPaymentTask(t){
  const explicit = parseCurrencyFromName(t.name);
  if(explicit != null) return explicit;
  const c = state.clients && state.clients[t.clientId];
  if(!c) return 0;
  const pkgPrice = Number(c.price) || (state.prices && state.prices[c.package]) || 0;
  return pkgPrice / 2;
}

// --- Payment ledger shim: keep revenue after task completion ---
(function attachPaymentLedger(){
  // Only attach once
  if (window._archivePatched) return;
  window._archivePatched = true;
  const originalArchive = window.archiveTask;
  // Helper: parse amount from title or fallback to half package price (same logic used in revenue)
  function _parseCurrencyFromName(name){
    const m = /\$([\d,]+(?:\.\d{1,2})?)/.exec(name || '');
    return m ? Number(m[1].replace(/,/g,'')) : null;
  }
function _amountForPaymentTask(t){
    const explicit = _parseCurrencyFromName(t.name);
    if (explicit != null) return explicit;
    const c = state.clients && state.clients[t.clientId];
    const pkgPrice = Number(c?.price) || (state.prices && state.prices[c?.package]) || 0;
    return pkgPrice / 2;
  }
  window.archiveTask = function(id){
    try{
      const t = state.tasks.find(x => x.id === id);
      if (t && /payment\s+due/i.test(t.name)) {
        if (!Array.isArray(state.payments)) state.payments = [];
        state.payments.push({
          id: 'paid-' + t.id,
          taskId: t.id,
          clientId: t.clientId,
          // Persist the client name at the time of payment so that the
          // revenue modal continues to show the correct label even if the
          // client record is later removed or archived.  Fallback to
          // 'Client' if no client exists.
          clientName: (state.clients && state.clients[t.clientId]) ? state.clients[t.clientId].name : 'Client',
          date: t.date,
          amount: _amountForPaymentTask(t),
          // Persist the task name so that the payment retains its label.
          name: t.name,
          source: 'task'
        });
        save(false);
      }
    }catch(e){}
    // proceed with the original archive behavior
    if (typeof originalArchive === 'function') originalArchive(id);
    // redraw revenue to reflect persisted payment
    try{ if (typeof drawRevenue === 'function') drawRevenue(); }catch(e){}
  };
})();

// Build month totals strictly from "Payment due" tasks in that month
// --- Read scheduled + paid, with a mode toggle ---
// Add a simple view mode to state if missing: 'both' | 'scheduled' | 'paid'
if(!state.revMode){ state.revMode = 'both'; save(false); }
window.setRevMode = (m)=>{ state.revMode = m; save(false); drawRevenue(); };

function collectMonthPayments(y, m){
  const days = new Date(y, m + 1, 0).getDate();
  const totals = Array(days).fill(0);
  const tasksByDay = {};
  // helper to bucket a record
  function bump(dateStr, amount, record){
    const d = toDate(dateStr);
    if(!d || isNaN(d)) return;
    if(d.getFullYear() !== y || d.getMonth() !== m) return;
    const idx = d.getDate() - 1;
    totals[idx] += amount;
    (tasksByDay[idx] ||= []).push(record);
  }
  const mode = state.revMode || 'both';
  // Scheduled (unarchived) "Payment due" tasks
  if(mode !== 'paid'){
    (state.tasks || []).forEach(t=>{
      if(!/payment\s+due/i.test(t.name)) return;
      const explicit = /\$([\d,]+(?:\.\d{1,2})?)/.exec(t.name||'');
      const c = state.clients && state.clients[t.clientId];
      const pkgPrice = Number(c?.price) || (state.prices && state.prices[c?.package]) || 0;
      const amt = explicit ? Number(explicit[1].replace(/,/g,'')) : (pkgPrice/2);
      bump(t.date, amt, {kind:'scheduled', task:t});
    });
  }
  // Paid ledger (survives after ✓)
  if(mode !== 'scheduled'){
    (state.payments || []).forEach(p=>{
      bump(p.date, Number(p.amount)||0, {kind:'paid', payment:p});
    });
  }
  return { totals, tasksByDay };
}

// Wire up revenue mode chips selection
function wireRevMode(){
  const el = document.getElementById('revMode');
  if(!el) return;
  // Assign click handler once
  el.onclick = (e)=>{
    const m = e.target.closest('.chip')?.dataset.m;
    if(m){ setRevMode(m); el.querySelectorAll('.chip').forEach(c=>c.classList.toggle('active', c.dataset.m===m)); }
  };
  // Reflect current selection
  el.querySelectorAll('.chip').forEach(c=>c.classList.toggle('active', c.dataset.m===(state.revMode||'both')));
}

// New revenue drawing function – reads only Payment due tasks for the selected month
function drawRevenue(){
  const y = (state.revYear != null) ? state.revYear : new Date().getFullYear();
  const m = (state.revMonth != null) ? state.revMonth : new Date().getMonth();
  const cvs = document.getElementById('revCanvas');
  if(!cvs) return;
  // keep the month picker in sync
  const picker = document.getElementById('revPicker');
  if(picker) picker.value = `${y}-${String(m+1).padStart(2,'0')}`;
  const { totals, tasksByDay } = collectMonthPayments(y, m);
  // clear and redraw
  cvs.innerHTML = '';
  const days = totals.length;
  // Determine dimensions
  const H = cvs.clientHeight || 200;
  const W = cvs.clientWidth || 600;
  const gap = 2;
  const barW = Math.max(4, Math.floor((W - 30 - (days - 1) * gap) / days));
  const max = Math.max(1, ...totals);
  totals.forEach((v, i) => {
    const x = 14 + i * (barW + gap);
    const h = Math.round((v / max) * (H - 36));
    // bar
    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.left = x + 'px';
    bar.style.width = barW + 'px';
    bar.style.height = h + 'px';
    bar.title = `${MONTHS[m]} ${i+1}, ${y}: $${v.toFixed(0)}`;
    bar.style.position = 'absolute';
    bar.style.bottom = '12px';
    bar.style.background = v > 0 ? '#3a77ff' : 'transparent';
    if(v > 0){
      bar.style.cursor = 'pointer';
      bar.onclick = () => {
        const payments = tasksByDay[i] || [];
        // Build rows for payment records. Each record may represent a scheduled
        // task or a paid ledger entry. Use the appropriate fields to label
        // the client and amount. When we record payments into the ledger we
        // copy the task name and amount so that historical entries can be
        // displayed after the underlying task has been archived.
        const rows = payments.length
          ? payments.map(rec => {
              let clientName = 'Client';
              let name = 'Payment';
              let amt = 0;
              let delId = '';
              let kind = rec.kind || 'scheduled';
              if(kind === 'scheduled' && rec.task){
                const tsk = rec.task;
                clientName = (state.clients && state.clients[tsk.clientId]) ? state.clients[tsk.clientId].name : 'Client';
                name = tsk.name;
                amt = amountForPaymentTask(tsk);
                delId = tsk.id;
              } else if(kind === 'paid' && rec.payment){
                const pmt = rec.payment;
                // Use the persisted clientName from the ledger if present.
                // Fall back to the current client record, and finally to
                // 'Client' if no record exists.  This ensures that
                // payments continue to display the correct client even
                // after a client is archived or deleted.
                clientName = pmt.clientName || ((state.clients && state.clients[pmt.clientId]) ? state.clients[pmt.clientId].name : 'Client');
                // Use the persisted name from the ledger.  If none is
                // provided, fall back to 'Payment'.
                name = pmt.name || 'Payment';
                // Persisted ledger amount is trusted.  Fall back to 0 if
                // not provided.
                amt = Number(pmt.amount) || 0;
                delId = pmt.id;
              }
              return `<div class="row wrap" style="align-items:center;justify-content:space-between;margin-bottom:6px">
                        <span>${clientName} – ${name} • $${amt.toLocaleString()}</span>
                        <button class="btn small danger" data-delpay="${delId}" data-delkind="${kind}">Delete</button>
                      </div>`;
            }).join('')
          : '<div class="small">No payments</div>';
        openModal(
          `<h3>${MONTHS[m]} ${i+1}, ${y} • Payments</h3>
           ${rows}
           <div class="row right" style="margin-top:8px"><button class="btn secondary" id="closeRevDay">Close</button></div>`,
          () => {
            const closeBtn = document.getElementById('closeRevDay');
            if(closeBtn) closeBtn.onclick = closeModal;
            // delete individual payment tasks or ledger entries
            document.querySelectorAll('[data-delpay]').forEach(btn => {
              btn.onclick = () => {
                const id = btn.getAttribute('data-delpay');
                const kind = btn.getAttribute('data-delkind');
                if(kind === 'scheduled'){
                  const idx = state.tasks.findIndex(tt => tt.id === id);
                  if(idx >= 0){ state.tasks.splice(idx, 1); save(); }
                } else {
                  const pIdx = (state.payments || []).findIndex(p => p.id === id);
                  if(pIdx >= 0){ state.payments.splice(pIdx, 1); save(); }
                }
                closeModal();
                drawRevenue();
              };
            });
          }
        );
      };
    }
    cvs.appendChild(bar);
    // value label above bar
    const val = document.createElement('div');
    val.className = 'label';
    val.style.left = x + 'px';
    val.style.bottom = (h + 18) + 'px';
    val.style.width = barW + 'px';
    val.style.textAlign = 'center';
    val.style.position = 'absolute';
    val.textContent = v ? `$${v.toFixed(0)}` : '';
    cvs.appendChild(val);
    // day number along x‑axis (1..days)
    const dayLbl = document.createElement('div');
    dayLbl.style.position = 'absolute';
    dayLbl.style.left = x + 'px';
    dayLbl.style.bottom = '0px';
    dayLbl.style.width = barW + 'px';
    dayLbl.style.textAlign = 'center';
    dayLbl.style.fontSize = '9px';
    dayLbl.style.color = '#6f7893';
    dayLbl.textContent = String(i + 1);
    cvs.appendChild(dayLbl);
  });
  // monthly total
  const total = totals.reduce((a,b)=>a+b,0);
  const rt = document.getElementById('revTotal');
  if(rt){ rt.textContent = canSeeRevenue() ? `Total: $${total.toLocaleString()}` : ''; }
}

// Wire up month navigation explicitly (overrides any stale handlers)
(function wireRevenueNav(){
  const monthInput = document.getElementById('revPicker');
  if(monthInput){
    monthInput.onchange = (e)=>{
      const val = e.target.value || '';
      const [yy, mm] = val.split('-').map(Number);
      if(!isNaN(yy) && !isNaN(mm)){
        state.revYear = yy;
        state.revMonth = mm - 1;
        save();
        drawRevenue();
      }
    };
  }
  const prevBtn = document.getElementById('revPrev');
  const nextBtn = document.getElementById('revNext');
  if(prevBtn){
    prevBtn.onclick = () => {
      let y = state.revYear != null ? state.revYear : new Date().getFullYear();
      let m = state.revMonth != null ? state.revMonth : new Date().getMonth();
      m--;
      if(m < 0){ m = 11; y--; }
      state.revYear = y;
      state.revMonth = m;
      save();
      const rp = document.getElementById('revPicker');
      if(rp){ rp.value = `${y}-${String(m+1).padStart(2,'0')}`; }
      drawRevenue();
      if(typeof drawPersonRevenue === 'function') drawPersonRevenue();
    };
  }
  if(nextBtn){
    nextBtn.onclick = () => {
      let y = state.revYear != null ? state.revYear : new Date().getFullYear();
      let m = state.revMonth != null ? state.revMonth : new Date().getMonth();
      m++;
      if(m > 11){ m = 0; y++; }
      state.revYear = y;
      state.revMonth = m;
      save();
      const rp = document.getElementById('revPicker');
      if(rp){ rp.value = `${y}-${String(m+1).padStart(2,'0')}`; }
      drawRevenue();
      if(typeof drawPersonRevenue === 'function') drawPersonRevenue();
    };
  }
})();

// Initial draw for revenue
setTimeout(drawRevenue, 0);
applyTheme();
// Reassign tasks to appropriate employees based on their current skills.
Object.keys(state.users).forEach(id=>{ try{ reassignTasks(id); } catch(e){} });
render();
</script>
<!-- === PERSISTENCE BOOT PATCH (local + cloud) === -->
<script>
if(false){
/* ==== Persistence Patch v3 (clients + users/passwords) ==== */
(function () {
  const ORG_DOC_ID = 'org-marlow-media';
  const STORE_KEY  = 'marlow.dashboard.v23';

  function dbOrNull() {
    if (window.getDb) return window.getDb();
    if (window.firebase && firebase.apps && firebase.apps.length) {
      return firebase.firestore();
    }
    if (window.firebase && window.firebaseConfig && (!firebase.apps || !firebase.apps.length)) {
      try { firebase.initializeApp(window.firebaseConfig); } catch(_) {}
      try { return firebase.firestore(); } catch(_) {}
    }
    return null;
  }

  function getState() {
    // Use the global state object defined in the main script. Avoid
    // allocating window.state here because the application uses a
    // standalone `state` variable. Returning and updating `state`
    // ensures persistence operates on the same object used by the UI.
    return (state = state || {});
  }

  function saveLocal() {
    try { localStorage.setItem(STORE_KEY, JSON.stringify(state)); }
    catch (e) { console.error('[persist] local save failed', e); }
  }

  function loadLocalIntoState() {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return;
      const local = JSON.parse(raw);
      if (local && typeof local === 'object') {
        Object.assign(state, local);
      }
    } catch (e) {
      console.warn('[persist] local load failed', e);
    }
  }

  async function saveRemote() {
    try {
      const db = dbOrNull();
      if (!db) return;
      const s = state;
      const patch = {
        _ver: Date.now(),
        users:   s.users   || {},
        clients: s.clients || {}
      };
      // include tasks in remote patch; ensure tasks array exists
      patch.tasks = s.tasks || [];
      await db.collection('dashboards').doc(ORG_DOC_ID).set(patch, { merge: true });
      // log less verbosely to avoid console spam
      // console.log('[persist] Remote save ✓', Object.keys(patch));
    } catch (e) {
      console.error('[persist] remote save failed', e);
    }
  }

  async function loadRemoteMerge() {
    try {
      const db = dbOrNull();
      if (!db) return false;
      const snap = await db.collection('dashboards').doc(ORG_DOC_ID).get();
      if (!snap.exists) return false;
      const data = snap.data() || {};
      const s = state;
      // merge users and clients into existing state (don't overwrite)
      if (data.users)   s.users   = { ...(s.users || {}),   ...data.users };
      if (data.clients) s.clients = { ...(s.clients || {}), ...data.clients };
      // merge tasks: if local tasks are empty, copy remote; else union and dedupe
      if (Array.isArray(data.tasks)) {
        if (!Array.isArray(s.tasks) || s.tasks.length === 0) {
          s.tasks = data.tasks.slice(0);
        } else {
          const sig = t => (t && (t.id !== undefined && t.id !== null)) ? String(t.id)
                         : [t && t.date || '', t && t.clientId || '', t && t.type || ''].join('|');
          const seen = new Set(s.tasks.map(sig));
          data.tasks.forEach(t => {
            const k = sig(t);
            if (!seen.has(k)) {
              seen.add(k);
              s.tasks.push(t);
            }
          });
        }
      }
      return true;
    } catch (e) {
      console.warn('[persist] remote load failed', e);
      return false;
    }
  }

  async function hydrateThenRender() {
    loadLocalIntoState();
    await loadRemoteMerge();
    window.__hydrated = true;
    if (typeof window.render === 'function') {
      try { window.render(); }
      catch (e) { console.warn('[persist] render after hydrate failed', e); }
    }
  }

  const originalSave = window.save;
  window.save = async function () {
    if (typeof originalSave === 'function') {
      try { originalSave(); }
      catch (e) { console.warn('[persist] original save threw', e); }
    }
    saveLocal();
    await saveRemote();
  };

  window.addEventListener('state:changed', () => { saveLocal(); saveRemote(); });
  hydrateThenRender();
  window.addEventListener('beforeunload', saveLocal);
})();
}</script>
<script>
/* ==== Persistence Patch v3 (org + user fallback; includes tasks) ==== */
(function () {
  const ORG_DOC_ID = 'org-marlow-media';
  const STORE_KEY  = 'marlow.dashboard.v23';
  function dbOrNull() {
    if (window.getDb) return window.getDb();
    if (window.firebase && firebase.apps && firebase.apps.length) return firebase.firestore();
    if (window.firebase && window.firebaseConfig && (!firebase.apps || !firebase.apps.length)) {
      try { firebase.initializeApp(window.firebaseConfig); } catch(_) {}
      try { return firebase.firestore(); } catch(_) {}
    }
    return null;
  }
  // Always operate on the global `state` object used by the application
  function getState(){ return state; }
  function saveLocal(){
    try { localStorage.setItem(STORE_KEY, JSON.stringify(state)); }
    catch (e) { console.error('[persist] local save failed', e); }
  }
  function loadLocalIntoState(){
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return;
      const local = JSON.parse(raw);
      if (local && typeof local === 'object') Object.assign(state, local);
    } catch (e) { console.warn('[persist] local load failed', e); }
  }
  function mergeUsersClients(dst, src){
    if (src && src.users)   dst.users   = { ...(dst.users||{}),   ...src.users };
    if (src && src.clients) dst.clients = { ...(dst.clients||{}), ...src.clients };
  }
  function mergeTasks(dst, srcTasks){
    if (!Array.isArray(srcTasks) || !srcTasks.length) return;
    dst.tasks = Array.isArray(dst.tasks) ? dst.tasks.slice(0) : [];
    const sig = t => t?.id ?? [t?.date, t?.clientId, t?.type, t?.assigneeId, t?.start, t?.duration].join('|');
    const seen = new Set(dst.tasks.map(sig));
    srcTasks.forEach(t => {
      const k = sig(t);
      if (!seen.has(k)) { seen.add(k); dst.tasks.push(t); }
    });
  }
  async function saveRemote(){
    try {
      const db = dbOrNull(); if (!db) return;
      const s = getState();
      const patch = {
        _ver: Date.now(),
        users:   s.users   || {},
        clients: s.clients || {},
        tasks:   Array.isArray(s.tasks) ? s.tasks : []
      };
      await db.collection('dashboards').doc(ORG_DOC_ID).set(patch, { merge: true });
    } catch(e){ console.error('[persist] remote save failed', e); }
  }
  async function loadDoc(path){
    const db = dbOrNull(); if (!db) return null;
    try {
      const snap = await db.doc(path).get();
      return snap.exists ? (snap.data() || {}) : null;
    } catch(e){ console.warn('[persist] failed to read', path, e); return null; }
  }
  async function loadRemoteMerge(){
    // Pull the shared org document first.  If it exists, merge users/clients
    // and tasks from the organisation-level document into state.  Tasks
    // defined here take precedence over any loaded later.
    const org = await loadDoc(`dashboards/${ORG_DOC_ID}`);
    const s = getState();
    if (org) {
      mergeUsersClients(s, org);
      if (!Array.isArray(s.tasks) || s.tasks.length === 0) {
        s.tasks = Array.isArray(org.tasks) ? org.tasks.slice(0) : [];
      } else {
        mergeTasks(s, org.tasks);
      }
    }
    // If we still have no tasks after reading the org document, attempt to
    // merge tasks from *all* known user documents.  A fresh incognito tab
    // will only know about users once the org document (or local state)
    // populates state.users.  Iterate through each user id and merge tasks
    // from that user's dashboard document.  This ensures that tasks saved
    // under any user account are hydrated when the app is loaded in a new
    // session, even if the current user id is not yet known.
    if (!Array.isArray(s.tasks) || s.tasks.length === 0) {
      const userIds = Object.keys(s.users || {});
      for (const uid of userIds) {
        const userDoc = await loadDoc(`dashboards/${uid}`);
        if (!userDoc) continue;
        mergeUsersClients(s, userDoc);
        if (Array.isArray(userDoc.tasks)) mergeTasks(s, userDoc.tasks);
        // If we've merged tasks from one user, continue merging others to
        // accumulate tasks from all user docs.  Do not break; union tasks.
      }
    }
  }
  async function hydrateThenRender(){
    loadLocalIntoState();
    await loadRemoteMerge();
    const s = getState();
    if (!s.currentUserId) s.currentUserId = 'all';
    window.__hydrated = true;
    if (typeof window.render === 'function') {
      try { window.render(); } catch(e){ console.warn('[persist] render after hydrate failed:', e?.message); }
    }
  }
  const originalSave = window.save;
  window.save = async function(){
    if (typeof originalSave === 'function') {
      try { originalSave(); } catch(e){ console.warn('[persist] original save threw', e); }
    }
    saveLocal();
    await saveRemote();
  };
  window.addEventListener('state:changed', () => { saveLocal(); saveRemote(); });
  hydrateThenRender();
  window.addEventListener('beforeunload', saveLocal);
})();
</script>

  <script>
    (function patchSaveTasksOnly(){
      var db = (window.getDb && window.getDb()) || (firebase.firestore && firebase.firestore());
      if (!db) { console.warn('[patch] no db for save'); return; }
      function toStr(x){ return x==null ? '' : String(x); }
      function toNum(x){ var n = Number(x); return Number.isFinite(n) ? n : 0; }
      function iso(x){
        if (!x) return '';
        if (x instanceof Date) return x.toISOString().slice(0,10);
        var m = String(x).match(/^(\d{4}-\d{2}-\d{2})/); return m ? m[1] : toStr(x);
      }
      function whitelist(t){
        var o = {
          id:         t && t.id ? String(t.id) : undefined,
          date:       iso(t && t.date),
          start:      toStr((t && t.start) || '09:00'),
          duration:   toNum((t && t.duration) || 60),
          clientId:   toStr((t && t.clientId) || ''),
          type:       toStr((t && t.type) || 'task'),
          title:      toStr((t && t.title) || ''),
          assigneeId: (t && t.assigneeId) ? String(t.assigneeId) : undefined
        };
        var out = {}; for (var k in o) if (o[k] !== undefined) out[k] = o[k]; return out;
      }
      var originalSaveRemote = window.saveRemoteState;
      var originalSave = window.save;
      window.saveRemoteState = async function(){
        try {
          var s = window.state || {};
          var tasks = Array.isArray(s.tasks) ? s.tasks.map(whitelist) : [];
          await (window.getDb?window.getDb():firebase.firestore())
            .collection('dashboards').doc('org-marlow-media')
            .set({ tasks: tasks }, { merge: true });
          console.log('[save] org tasks saved ✓', tasks.length);
        } catch(e) {
          console.warn('[save] org tasks failed', e && e.message);
        }
      };
      window.save = async function(){
        try { if (typeof originalSave === 'function') originalSave(); } catch(_) {}
        try { await window.saveRemoteState(); } catch(_) {}
      };
      console.log('[patch] save() -> tasks-only org writer installed');
    })();
  </script>

  <script>
    (function patchSaveTasksClients(){
      var db = (window.getDb && window.getDb()) || (firebase.firestore && firebase.firestore());
      if (!db) { console.warn('[patch+] no db for save'); return; }
      function toStr(x){ return x==null ? '' : String(x); }
      function toNum(x){ var n = Number(x); return Number.isFinite(n) ? n : 0; }
      function iso(x){
        if (!x) return '';
        if (x instanceof Date) return x.toISOString().slice(0,10);
        var m = String(x).match(/^(\d{4}-\d{2}-\d{2})/); return m ? m[1] : toStr(x);
      }
      function whitelistTask(t){
        var o = {
          id:         t && t.id ? String(t.id) : undefined,
          date:       iso(t && t.date),
          start:      toStr((t && t.start) || '09:00'),
          duration:   toNum((t && t.duration) || 60),
          clientId:   toStr((t && t.clientId) || ''),
          type:       toStr((t && t.type) || 'task'),
          title:      toStr((t && t.title) || 'Task'),
          assigneeId: (t && t.assigneeId) ? String(t.assigneeId) : undefined
        };
        var out = {}; for (var k in o) if (o[k] !== undefined) out[k] = o[k]; return out;
      }
      function whitelistClients(map){
        var safe = {};
        if (map && typeof map === 'object'){
          Object.keys(map).forEach(function(id){
            var c = map[id] || {};
            safe[String(id)] = { name: toStr(c.name || id) };
          });
        }
        return safe;
      }
      var originalSave = window.save;
      window.saveRemoteState = async function(){
        try {
          var s = window.state || {};
          var tasks = Array.isArray(s.tasks) ? s.tasks.map(whitelistTask) : [];
          var clients = whitelistClients(s.clients);
          await (window.getDb?window.getDb():firebase.firestore())
            .collection('dashboards').doc('org-marlow-media')
            .set({ tasks: tasks, clients: clients }, { merge: true });
          console.log('[save+] org tasks+clients saved ✓', tasks.length, Object.keys(clients).length);
        } catch(e) {
          console.warn('[save+] org save failed', e && e.message);
        }
      };
      window.save = async function(){
        try { if (typeof originalSave === 'function') originalSave(); } catch(_) {}
        try { await window.saveRemoteState(); } catch(_) {}
      };
      console.log('[patch+] save() -> tasks+clients writer installed');
    })();
  </script>

  <script>
    (function installUnifiedSave(){
      var db = (window.getDb && window.getDb()) || (firebase.firestore && firebase.firestore());
      if (!db) { console.warn('[save] no db'); return; }
      function toStr(x){ return x==null ? '' : String(x); }
      function toNum(x){ var n = Number(x); return Number.isFinite(n) ? n : 0; }
      function iso(x){
        if (!x) return '';
        if (x instanceof Date) return x.toISOString().slice(0,10);
        var m = String(x).match(/^(\d{4}-\d{2}-\d{2})/); return m ? m[1] : toStr(x);
      }
      function whitelistTask(t){
        var o = {
          id:         t && t.id ? String(t.id) : undefined,
          date:       iso(t && t.date),
          start:      toStr((t && t.start) || '09:00'),
          duration:   toNum((t && t.duration) || 60),
          clientId:   toStr((t && t.clientId) || ''),
          type:       toStr((t && t.type) || 'task'),
          title:      toStr((t && t.title) || 'Task'),
          assigneeId: (t && t.assigneeId) ? String(t.assigneeId) : undefined
        };
        var out = {}; for (var k in o) if (o[k] !== undefined) out[k] = o[k]; return out;
      }
      function whitelistClients(map){
        var safe = {};
        if (map && typeof map === 'object'){
          Object.keys(map).forEach(function(id){
            var c = map[id] || {};
            safe[String(id)] = { name: toStr(c.name || id) };
          });
        }
        return safe;
      }
      async function saveRemoteState(){
        var s = window.state || {};
        var tasks = Array.isArray(s.tasks) ? s.tasks.map(whitelistTask) : [];
        var clients = whitelistClients(s.clients);
        await db.collection('dashboards').doc('org-marlow-media').set({ tasks: tasks, clients: clients }, { merge: true });
        console.log('[save] wrote', tasks.length, 'tasks and', Object.keys(clients).length, 'clients');
      }
      window.saveRemoteState = saveRemoteState;
      window.save = async function(){
        try { await saveRemoteState(); } catch(e){ console.warn('[save] failed', e && e.message); }
      };
      console.log('[save] unified writer installed');
    })();
  </script>
</body>
</html>
